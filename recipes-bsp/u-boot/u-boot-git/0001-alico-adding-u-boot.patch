diff -rupN u-boot-2010.06.orig/MAKEALL u-boot-2010.06.new/MAKEALL
--- u-boot-2010.06.orig/MAKEALL	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/MAKEALL	2011-06-10 12:41:22.934688001 -0700
@@ -656,6 +656,7 @@ LIST_ARM_CORTEX_A8="		\
 	omap3_sdp3430		\
 	omap3_zoom1		\
 	omap3_zoom2		\
+	omap3_alico		\
 	s5p_goni		\
 	smdkc100		\
 "
diff -rupN u-boot-2010.06.orig/Makefile u-boot-2010.06.new/Makefile
--- u-boot-2010.06.orig/Makefile	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/Makefile	2011-06-10 18:25:32.990688002 -0700
@@ -3190,6 +3190,9 @@ omap3_zoom1_config :	unconfig
 omap3_zoom2_config :	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 zoom2 logicpd omap3
 
+omap3_alico_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 alico logicpd omap3
+
 s5p_goni_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 goni samsung s5pc1xx
 
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/config.mk u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/config.mk
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/config.mk	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/config.mk	2009-08-10 01:39:12.000000000 -0700
@@ -20,7 +20,8 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 # MA 02111-1307 USA
 #
-PLATFORM_RELFLAGS += -fno-common -ffixed-r8 -msoft-float
+PLATFORM_RELFLAGS += -fno-strict-aliasing -fno-common -ffixed-r8 \
+		     -msoft-float
 
 # Make ARMv5 to allow more compilers to work, even though its v7a.
 PLATFORM_CPPFLAGS += -march=armv5
@@ -29,5 +30,6 @@ PLATFORM_CPPFLAGS += -march=armv5
 # Supply options according to compiler version
 #
 # =========================================================================
+PLATFORM_CPPFLAGS +=$(call cc-option,-mno-thumb-interwork,)
 PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,\
 		    $(call cc-option,-malignment-traps,))
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/cpu.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/cpu.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/cpu.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/cpu.c	2009-08-10 01:39:12.000000000 -0700
@@ -64,7 +64,7 @@ int cleanup_before_linux(void)
 	/* turn off L2 cache */
 	l2_cache_disable();
 	/* invalidate L2 cache also */
-	invalidate_dcache(get_device_type());
+	v7_flush_dcache_all(get_device_type());
 #endif
 	i = 0;
 	/* mem barrier to sync up things */
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/Makefile u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/Makefile
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/Makefile	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/Makefile	1969-12-31 16:00:00.000000000 -0800
@@ -1,48 +0,0 @@
-#
-# (C) Copyright 2000-2006
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# (C) Copyright 2009 Freescale Semiconductor, Inc.
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= $(obj)lib$(SOC).a
-
-COBJS	= soc.o clock.o iomux.o timer.o speed.o
-SOBJS = lowlevel_init.o
-
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
-
-all:	$(obj).depend $(LIB)
-
-$(LIB):	$(OBJS)
-	$(AR) $(ARFLAGS) $@ $(OBJS)
-
-#########################################################################
-
-# defines $(obj).depend target
-include $(SRCTREE)/rules.mk
-
-sinclude $(obj).depend
-
-#########################################################################
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/clock.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/clock.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/clock.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/clock.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,294 +0,0 @@
-/*
- * (C) Copyright 2007
- * Sascha Hauer, Pengutronix
- *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/errno.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/crm_regs.h>
-#include <asm/arch/clock.h>
-
-enum pll_clocks {
-	PLL1_CLOCK = 0,
-	PLL2_CLOCK,
-	PLL3_CLOCK,
-	PLL_CLOCKS,
-};
-
-struct mxc_pll_reg *mxc_plls[PLL_CLOCKS] = {
-	[PLL1_CLOCK] = (struct mxc_pll_reg *)PLL1_BASE_ADDR,
-	[PLL2_CLOCK] = (struct mxc_pll_reg *)PLL2_BASE_ADDR,
-	[PLL3_CLOCK] = (struct mxc_pll_reg *)PLL3_BASE_ADDR,
-};
-
-struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)MXC_CCM_BASE;
-
-/*
- * Calculate the frequency of this pll.
- */
-static u32 decode_pll(struct mxc_pll_reg *pll, u32 infreq)
-{
-	u32 mfi, mfn, mfd, pd;
-
-	mfn = __raw_readl(&pll->mfn);
-	mfd = __raw_readl(&pll->mfd) + 1;
-	mfi = __raw_readl(&pll->op);
-	pd = (mfi  & 0xF) + 1;
-	mfi = (mfi >> 4) & 0xF;
-	mfi = (mfi >= 5) ? mfi : 5;
-
-	return ((4 * (infreq / 1000) * (mfi * mfd + mfn)) / (mfd * pd)) * 1000;
-}
-
-/*
- * Get mcu main rate
- */
-u32 get_mcu_main_clk(void)
-{
-	u32 reg, freq;
-
-	reg = (__raw_readl(&mxc_ccm->cacrr) & MXC_CCM_CACRR_ARM_PODF_MASK) >>
-		MXC_CCM_CACRR_ARM_PODF_OFFSET;
-	freq = decode_pll(mxc_plls[PLL1_CLOCK], CONFIG_MX51_HCLK_FREQ);
-	return freq / (reg + 1);
-}
-
-/*
- * Get the rate of peripheral's root clock.
- */
-static u32 get_periph_clk(void)
-{
-	u32 reg;
-
-	reg = __raw_readl(&mxc_ccm->cbcdr);
-	if (!(reg & MXC_CCM_CBCDR_PERIPH_CLK_SEL))
-		return decode_pll(mxc_plls[PLL2_CLOCK], CONFIG_MX51_HCLK_FREQ);
-	reg = __raw_readl(&mxc_ccm->cbcmr);
-	switch ((reg & MXC_CCM_CBCMR_PERIPH_CLK_SEL_MASK) >>
-		MXC_CCM_CBCMR_PERIPH_CLK_SEL_OFFSET) {
-	case 0:
-		return decode_pll(mxc_plls[PLL1_CLOCK], CONFIG_MX51_HCLK_FREQ);
-	case 1:
-		return decode_pll(mxc_plls[PLL3_CLOCK], CONFIG_MX51_HCLK_FREQ);
-	default:
-		return 0;
-	}
-	/* NOTREACHED */
-}
-
-/*
- * Get the rate of ipg clock.
- */
-static u32 get_ipg_clk(void)
-{
-	u32 ahb_podf, ipg_podf;
-
-	ahb_podf = __raw_readl(&mxc_ccm->cbcdr);
-	ipg_podf = (ahb_podf & MXC_CCM_CBCDR_IPG_PODF_MASK) >>
-			MXC_CCM_CBCDR_IPG_PODF_OFFSET;
-	ahb_podf = (ahb_podf & MXC_CCM_CBCDR_AHB_PODF_MASK) >>
-			MXC_CCM_CBCDR_AHB_PODF_OFFSET;
-	return get_periph_clk() / ((ahb_podf + 1) * (ipg_podf + 1));
-}
-
-/*
- * Get the rate of ipg_per clock.
- */
-static u32 get_ipg_per_clk(void)
-{
-	u32 pred1, pred2, podf;
-
-	if (__raw_readl(&mxc_ccm->cbcmr) & MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL)
-		return get_ipg_clk();
-	/* Fixme: not handle what about lpm*/
-	podf = __raw_readl(&mxc_ccm->cbcdr);
-	pred1 = (podf & MXC_CCM_CBCDR_PERCLK_PRED1_MASK) >>
-		MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET;
-	pred2 = (podf & MXC_CCM_CBCDR_PERCLK_PRED2_MASK) >>
-		MXC_CCM_CBCDR_PERCLK_PRED2_OFFSET;
-	podf = (podf & MXC_CCM_CBCDR_PERCLK_PODF_MASK) >>
-		MXC_CCM_CBCDR_PERCLK_PODF_OFFSET;
-
-	return get_periph_clk() / ((pred1 + 1) * (pred2 + 1) * (podf + 1));
-}
-
-/*
- * Get the rate of uart clk.
- */
-static u32 get_uart_clk(void)
-{
-	unsigned int freq, reg, pred, podf;
-
-	reg = __raw_readl(&mxc_ccm->cscmr1);
-	switch ((reg & MXC_CCM_CSCMR1_UART_CLK_SEL_MASK) >>
-		MXC_CCM_CSCMR1_UART_CLK_SEL_OFFSET) {
-	case 0x0:
-		freq = decode_pll(mxc_plls[PLL1_CLOCK],
-				    CONFIG_MX51_HCLK_FREQ);
-		break;
-	case 0x1:
-		freq = decode_pll(mxc_plls[PLL2_CLOCK],
-				    CONFIG_MX51_HCLK_FREQ);
-		break;
-	case 0x2:
-		freq = decode_pll(mxc_plls[PLL3_CLOCK],
-				    CONFIG_MX51_HCLK_FREQ);
-		break;
-	default:
-		return 66500000;
-	}
-
-	reg = __raw_readl(&mxc_ccm->cscdr1);
-
-	pred = (reg & MXC_CCM_CSCDR1_UART_CLK_PRED_MASK) >>
-		MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET;
-
-	podf = (reg & MXC_CCM_CSCDR1_UART_CLK_PODF_MASK) >>
-		MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET;
-	freq /= (pred + 1) * (podf + 1);
-
-	return freq;
-}
-
-/*
- * This function returns the low power audio clock.
- */
-u32 get_lp_apm(void)
-{
-	u32 ret_val = 0;
-	u32 ccsr = __raw_readl(&mxc_ccm->ccsr);
-
-	if (((ccsr >> 9) & 1) == 0)
-		ret_val = CONFIG_MX51_HCLK_FREQ;
-	else
-		ret_val = ((32768 * 1024));
-
-	return ret_val;
-}
-
-/*
- * get cspi clock rate.
- */
-u32 imx_get_cspiclk(void)
-{
-	u32 ret_val = 0, pdf, pre_pdf, clk_sel;
-	u32 cscmr1 = __raw_readl(&mxc_ccm->cscmr1);
-	u32 cscdr2 = __raw_readl(&mxc_ccm->cscdr2);
-
-	pre_pdf = (cscdr2 & MXC_CCM_CSCDR2_CSPI_CLK_PRED_MASK) \
-			>> MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET;
-	pdf = (cscdr2 & MXC_CCM_CSCDR2_CSPI_CLK_PODF_MASK) \
-			>> MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET;
-	clk_sel = (cscmr1 & MXC_CCM_CSCMR1_CSPI_CLK_SEL_MASK) \
-			>> MXC_CCM_CSCMR1_CSPI_CLK_SEL_OFFSET;
-
-	switch (clk_sel) {
-	case 0:
-		ret_val = decode_pll(mxc_plls[PLL1_CLOCK],
-					CONFIG_MX51_HCLK_FREQ) /
-					((pre_pdf + 1) * (pdf + 1));
-		break;
-	case 1:
-		ret_val = decode_pll(mxc_plls[PLL2_CLOCK],
-					CONFIG_MX51_HCLK_FREQ) /
-					((pre_pdf + 1) * (pdf + 1));
-		break;
-	case 2:
-		ret_val = decode_pll(mxc_plls[PLL3_CLOCK],
-					CONFIG_MX51_HCLK_FREQ) /
-					((pre_pdf + 1) * (pdf + 1));
-		break;
-	default:
-		ret_val = get_lp_apm() / ((pre_pdf + 1) * (pdf + 1));
-		break;
-	}
-
-	return ret_val;
-}
-
-/*
- * The API of get mxc clockes.
- */
-unsigned int mxc_get_clock(enum mxc_clock clk)
-{
-	switch (clk) {
-	case MXC_ARM_CLK:
-		return get_mcu_main_clk();
-	case MXC_AHB_CLK:
-		break;
-	case MXC_IPG_CLK:
-		return get_ipg_clk();
-	case MXC_IPG_PERCLK:
-		return get_ipg_per_clk();
-	case MXC_UART_CLK:
-		return get_uart_clk();
-	case MXC_CSPI_CLK:
-		return imx_get_cspiclk();
-	case MXC_FEC_CLK:
-		return decode_pll(mxc_plls[PLL1_CLOCK],
-				    CONFIG_MX51_HCLK_FREQ);
-	default:
-		break;
-	}
-	return -1;
-}
-
-u32 imx_get_uartclk(void)
-{
-	return get_uart_clk();
-}
-
-
-u32 imx_get_fecclk(void)
-{
-	return mxc_get_clock(MXC_IPG_CLK);
-}
-
-/*
- * Dump some core clockes.
- */
-int do_mx51_showclocks(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
-{
-	u32 freq;
-
-	freq = decode_pll(mxc_plls[PLL1_CLOCK], CONFIG_MX51_HCLK_FREQ);
-	printf("mx51 pll1: %dMHz\n", freq / 1000000);
-	freq = decode_pll(mxc_plls[PLL2_CLOCK], CONFIG_MX51_HCLK_FREQ);
-	printf("mx51 pll2: %dMHz\n", freq / 1000000);
-	freq = decode_pll(mxc_plls[PLL3_CLOCK], CONFIG_MX51_HCLK_FREQ);
-	printf("mx51 pll3: %dMHz\n", freq / 1000000);
-	printf("ipg clock     : %dHz\n", mxc_get_clock(MXC_IPG_CLK));
-	printf("ipg per clock : %dHz\n", mxc_get_clock(MXC_IPG_PERCLK));
-
-	return 0;
-}
-
-/***************************************************/
-
-U_BOOT_CMD(
-	clockinfo,	CONFIG_SYS_MAXARGS,	1,	do_mx51_showclocks,
-	"display mx51 clocks\n",
-	""
-);
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/iomux.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/iomux.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/iomux.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/iomux.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,166 +0,0 @@
-/*
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/mx51_pins.h>
-#include <asm/arch/iomux.h>
-#include <asm/arch/sys_proto.h>
-
-/* IOMUX register (base) addresses */
-enum iomux_reg_addr {
-	IOMUXGPR0 = IOMUXC_BASE_ADDR,
-	IOMUXGPR1 = IOMUXC_BASE_ADDR + 0x004,
-	IOMUXSW_MUX_CTL = IOMUXC_BASE_ADDR,
-	IOMUXSW_MUX_END = IOMUXC_BASE_ADDR + MUX_I_END,
-	IOMUXSW_PAD_CTL = IOMUXC_BASE_ADDR + PAD_I_START,
-	IOMUXSW_INPUT_CTL = IOMUXC_BASE_ADDR,
-};
-
-#define MUX_PIN_NUM_MAX (((MUX_I_END - MUX_I_START) >> 2) + 1)
-
-/* Get the iomux register address of this pin */
-static inline u32 get_mux_reg(iomux_pin_name_t pin)
-{
-	u32 mux_reg = PIN_TO_IOMUX_MUX(pin);
-
-	if (is_soc_rev(CHIP_REV_2_0) < 0) {
-		/*
-		 * Fixup register address:
-		 *	i.MX51 TO1 has offset with the register
-		 * 	which is define as TO2.
-		 */
-		if ((pin == MX51_PIN_NANDF_RB5) ||
-			(pin == MX51_PIN_NANDF_RB6) ||
-			(pin == MX51_PIN_NANDF_RB7))
-			; /* Do nothing */
-		else if (mux_reg >= 0x2FC)
-			mux_reg += 8;
-		else if (mux_reg >= 0x130)
-			mux_reg += 0xC;
-	}
-	mux_reg += IOMUXSW_MUX_CTL;
-	return mux_reg;
-}
-
-/* Get the pad register address of this pin */
-static inline u32 get_pad_reg(iomux_pin_name_t pin)
-{
-	u32 pad_reg = PIN_TO_IOMUX_PAD(pin);
-
-	if (is_soc_rev(CHIP_REV_2_0) < 0) {
-		/*
-		 * Fixup register address:
-		 *	i.MX51 TO1 has offset with the register
-		 * 	which is define as TO2.
-		 */
-		if ((pin == MX51_PIN_NANDF_RB5) ||
-			(pin == MX51_PIN_NANDF_RB6) ||
-			(pin == MX51_PIN_NANDF_RB7))
-			; /* Do nothing */
-		else if (pad_reg == 0x4D0 - PAD_I_START)
-			pad_reg += 0x4C;
-		else if (pad_reg == 0x860 - PAD_I_START)
-			pad_reg += 0x9C;
-		else if (pad_reg >= 0x804 - PAD_I_START)
-			pad_reg += 0xB0;
-		else if (pad_reg >= 0x7FC - PAD_I_START)
-			pad_reg += 0xB4;
-		else if (pad_reg >= 0x4E4 - PAD_I_START)
-			pad_reg += 0xCC;
-		else
-			pad_reg += 8;
-	}
-	pad_reg += IOMUXSW_PAD_CTL;
-	return pad_reg;
-}
-
-/* Get the last iomux register address */
-static inline u32 get_mux_end(void)
-{
-	if (is_soc_rev(CHIP_REV_2_0) < 0)
-		return IOMUXC_BASE_ADDR + (0x3F8 - 4);
-	else
-		return IOMUXC_BASE_ADDR + (0x3F0 - 4);
-}
-
-/*
- * This function is used to configure a pin through the IOMUX module.
- * @param  pin		a pin number as defined in iomux_pin_name_t
- * @param  cfg		an output function as defined in iomux_pin_cfg_t
- *
- * @return 		0 if successful; Non-zero otherwise
- */
-static void iomux_config_mux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
-{
-	u32 mux_reg = get_mux_reg(pin);
-
-	if ((mux_reg > get_mux_end()) || (mux_reg < IOMUXSW_MUX_CTL))
-		return ;
-	if (cfg == IOMUX_CONFIG_GPIO)
-		writel(PIN_TO_ALT_GPIO(pin), mux_reg);
-	else
-		writel(cfg, mux_reg);
-}
-
-/*
- * Request ownership for an IO pin. This function has to be the first one
- * being called before that pin is used. The caller has to check the
- * return value to make sure it returns 0.
- *
- * @param  pin		a name defined by iomux_pin_name_t
- * @param  cfg		an input function as defined in iomux_pin_cfg_t
- *
- */
-void mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
-{
-	iomux_config_mux(pin, cfg);
-}
-
-/*
- * Release ownership for an IO pin
- *
- * @param  pin		a name defined by iomux_pin_name_t
- * @param  cfg		an input function as defined in iomux_pin_cfg_t
- */
-void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
-{
-}
-
-/*
- * This function configures the pad value for a IOMUX pin.
- *
- * @param  pin     a pin number as defined in iomux_pin_name_t
- * @param  config  the ORed value of elements defined in iomux_pad_config_t
- */
-void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
-{
-	u32 pad_reg = get_pad_reg(pin);
-	writel(config, pad_reg);
-}
-
-unsigned int mxc_iomux_get_pad(iomux_pin_name_t pin)
-{
-	u32 pad_reg = get_pad_reg(pin);
-	return readl(pad_reg);
-}
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/lowlevel_init.S u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/lowlevel_init.S
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/lowlevel_init.S	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/lowlevel_init.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,291 +0,0 @@
-/*
- * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
- *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/asm-offsets.h>
-
-/*
- * L2CC Cache setup/invalidation/disable
- */
-.macro init_l2cc
-	/* explicitly disable L2 cache */
-	mrc 15, 0, r0, c1, c0, 1
-	bic r0, r0, #0x2
-	mcr 15, 0, r0, c1, c0, 1
-
-	/* reconfigure L2 cache aux control reg */
-	mov r0, #0xC0			/* tag RAM */
-	add r0, r0, #0x4		/* data RAM */
-	orr r0, r0, #(1 << 24)		/* disable write allocate delay */
-	orr r0, r0, #(1 << 23)		/* disable write allocate combine */
-	orr r0, r0, #(1 << 22)		/* disable write allocate */
-
-	cmp r3, #0x10    /* r3 contains the silicon rev */
-
-	/* disable write combine for TO 2 and lower revs */
-	orrls r0, r0, #(1 << 25)
-
-	mcr 15, 1, r0, c9, c0, 2
-.endm /* init_l2cc */
-
-/* AIPS setup - Only setup MPROTx registers.
- * The PACR default values are good.*/
-.macro init_aips
-	/*
-	 * Set all MPROTx to be non-bufferable, trusted for R/W,
-	 * not forced to user-mode.
-	 */
-	ldr r0, =AIPS1_BASE_ADDR
-	ldr r1, =0x77777777
-	str r1, [r0, #0x0]
-	str r1, [r0, #0x4]
-	ldr r0, =AIPS2_BASE_ADDR
-	str r1, [r0, #0x0]
-	str r1, [r0, #0x4]
-	/*
-	 * Clear the on and off peripheral modules Supervisor Protect bit
-	 * for SDMA to access them. Did not change the AIPS control registers
-	 * (offset 0x20) access type
-	 */
-.endm /* init_aips */
-
-/* M4IF setup */
-.macro init_m4if
-	/* VPU and IPU given higher priority (0x4)
-	 * IPU accesses with ID=0x1 given highest priority (=0xA)
-	 */
-	ldr r0, =M4IF_BASE_ADDR
-
-	ldr r1, =0x00000203
-	str r1, [r0, #0x40]
-
-	ldr r1, =0x0
-	str r1, [r0, #0x44]
-
-	ldr r1, =0x00120125
-	str r1, [r0, #0x9C]
-
-	ldr r1, =0x001901A3
-	str r1, [r0, #0x48]
-
-.endm /* init_m4if */
-
-.macro setup_pll pll, freq
-	ldr r2, =\pll
-	ldr r1, =0x00001232
-	str r1, [r2, #PLL_DP_CTL] /* Set DPLL ON (set UPEN bit): BRMO=1 */
-	mov r1, #0x2
-	str r1, [r2, #PLL_DP_CONFIG] /* Enable auto-restart AREN bit */
-
-	str r3, [r2, #PLL_DP_OP]
-	str r3, [r2, #PLL_DP_HFS_OP]
-
-	str r4, [r2, #PLL_DP_MFD]
-	str r4, [r2, #PLL_DP_HFS_MFD]
-
-	str r5, [r2, #PLL_DP_MFN]
-	str r5, [r2, #PLL_DP_HFS_MFN]
-
-	ldr r1, =0x00001232
-	str r1, [r2, #PLL_DP_CTL]
-1:	ldr r1, [r2, #PLL_DP_CTL]
-	ands r1, r1, #0x1
-	beq 1b
-.endm
-
-.macro init_clock
-	ldr r0, =CCM_BASE_ADDR
-
-	/* Gate of clocks to the peripherals first */
-	ldr r1, =0x3FFFFFFF
-	str r1, [r0, #CLKCTL_CCGR0]
-	ldr r1, =0x0
-	str r1, [r0, #CLKCTL_CCGR1]
-	str r1, [r0, #CLKCTL_CCGR2]
-	str r1, [r0, #CLKCTL_CCGR3]
-
-	ldr r1, =0x00030000
-	str r1, [r0, #CLKCTL_CCGR4]
-	ldr r1, =0x00FFF030
-	str r1, [r0, #CLKCTL_CCGR5]
-	ldr r1, =0x00000300
-	str r1, [r0, #CLKCTL_CCGR6]
-
-	/* Disable IPU and HSC dividers */
-	mov r1, #0x60000
-	str r1, [r0, #CLKCTL_CCDR]
-
-	/* Make sure to switch the DDR away from PLL 1 */
-	ldr r1, =0x19239145
-	str r1, [r0, #CLKCTL_CBCDR]
-	/* make sure divider effective */
-1:	ldr r1, [r0, #CLKCTL_CDHIPR]
-	cmp r1, #0x0
-	bne 1b
-
-	/* Switch ARM to step clock */
-	mov r1, #0x4
-	str r1, [r0, #CLKCTL_CCSR]
-	mov r3, #DP_OP_800
-	mov r4, #DP_MFD_800
-	mov r5, #DP_MFN_800
-	setup_pll PLL1_BASE_ADDR
-
-	mov r3, #DP_OP_665
-	mov r4, #DP_MFD_665
-	mov r5, #DP_MFN_665
-	setup_pll PLL3_BASE_ADDR
-
-	/* Switch peripheral to PLL 3 */
-	ldr r0, =CCM_BASE_ADDR
-	ldr r1, =0x000010C0
-	orr r1,r1,#CONFIG_SYS_DDR_CLKSEL
-	str r1, [r0, #CLKCTL_CBCMR]
-	ldr r1, =0x13239145
-	str r1, [r0, #CLKCTL_CBCDR]
-	mov r3, #DP_OP_665
-	mov r4, #DP_MFD_665
-	mov r5, #DP_MFN_665
-	setup_pll PLL2_BASE_ADDR
-
-	/* Switch peripheral to PLL2 */
-	ldr r0, =CCM_BASE_ADDR
-	ldr r1, =0x19239145
-	str r1, [r0, #CLKCTL_CBCDR]
-	ldr r1, =0x000020C0
-	orr r1,r1,#CONFIG_SYS_DDR_CLKSEL
-	str r1, [r0, #CLKCTL_CBCMR]
-
-	mov r3, #DP_OP_216
-	mov r4, #DP_MFD_216
-	mov r5, #DP_MFN_216
-	setup_pll PLL3_BASE_ADDR
-
-
-	/* Set the platform clock dividers */
-	ldr r0, =ARM_BASE_ADDR
-	ldr r1, =0x00000725
-	str r1, [r0, #0x14]
-
-	ldr r0, =CCM_BASE_ADDR
-
-	/* Run 3.0 at Full speed, for other TO's wait till we increase VDDGP */
-	ldr r1, =0x0
-	ldr r3, [r1, #ROM_SI_REV]
-	cmp r3, #0x10
-	movls r1, #0x1
-	movhi r1, #0
-	str r1, [r0, #CLKCTL_CACRR]
-
-	/* Switch ARM back to PLL 1 */
-	mov r1, #0
-	str r1, [r0, #CLKCTL_CCSR]
-
-	/* setup the rest */
-	/* Use lp_apm (24MHz) source for perclk */
-	ldr r1, =0x000020C2
-	orr r1,r1,#CONFIG_SYS_DDR_CLKSEL
-	str r1, [r0, #CLKCTL_CBCMR]
-	/* ddr clock from PLL 1, all perclk dividers are 1 since using 24MHz */
-	ldr r1, =CONFIG_SYS_CLKTL_CBCDR
-	str r1, [r0, #CLKCTL_CBCDR]
-
-	/* Restore the default values in the Gate registers */
-	ldr r1, =0xFFFFFFFF
-	str r1, [r0, #CLKCTL_CCGR0]
-	str r1, [r0, #CLKCTL_CCGR1]
-	str r1, [r0, #CLKCTL_CCGR2]
-	str r1, [r0, #CLKCTL_CCGR3]
-	str r1, [r0, #CLKCTL_CCGR4]
-	str r1, [r0, #CLKCTL_CCGR5]
-	str r1, [r0, #CLKCTL_CCGR6]
-
-	/* Use PLL 2 for UART's, get 66.5MHz from it */
-	ldr r1, =0xA5A2A020
-	str r1, [r0, #CLKCTL_CSCMR1]
-	ldr r1, =0x00C30321
-	str r1, [r0, #CLKCTL_CSCDR1]
-
-	/* make sure divider effective */
-1:	ldr r1, [r0, #CLKCTL_CDHIPR]
-	cmp r1, #0x0
-	bne 1b
-
-	mov r1, #0x0
-	str r1, [r0, #CLKCTL_CCDR]
-
-	/* for cko - for ARM div by 8 */
-	mov r1, #0x000A0000
-	add r1, r1, #0x00000F0
-	str r1, [r0, #CLKCTL_CCOSR]
-.endm
-
-.macro setup_wdog
-	ldr r0, =WDOG1_BASE_ADDR
-	mov r1, #0x30
-	strh r1, [r0]
-.endm
-
-.section ".text.init", "x"
-
-.globl lowlevel_init
-lowlevel_init:
-	ldr r0, =GPIO1_BASE_ADDR
-	ldr r1, [r0, #0x0]
-	orr r1, r1, #(1 << 23)
-	str r1, [r0, #0x0]
-	ldr r1, [r0, #0x4]
-	orr r1, r1, #(1 << 23)
-	str r1, [r0, #0x4]
-
-#ifdef ENABLE_IMPRECISE_ABORT
-	mrs r1, spsr		/* save old spsr */
-	mrs r0, cpsr		/* read out the cpsr */
-	bic r0, r0, #0x100	/* clear the A bit */
-	msr spsr, r0		/* update spsr */
-	add lr, pc, #0x8	/* update lr */
-	movs pc, lr		/* update cpsr */
-	nop
-	nop
-	nop
-	nop
-	msr spsr, r1		/* restore old spsr */
-#endif
-
-	init_l2cc
-
-	init_aips
-
-	init_m4if
-
-	init_clock
-
-	/* r12 saved upper lr*/
-	mov pc,lr
-
-/* Board level setting value */
-DDR_PERCHARGE_CMD:	.word 0x04008008
-DDR_REFRESH_CMD:	.word 0x00008010
-DDR_LMR1_W:		.word 0x00338018
-DDR_LMR_CMD:		.word 0xB2220000
-DDR_TIMING_W:		.word 0xB02567A9
-DDR_MISC_W:		.word 0x000A0104
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/soc.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/soc.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/soc.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/soc.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,114 +0,0 @@
-/*
- * (C) Copyright 2007
- * Sascha Hauer, Pengutronix
- *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/clock.h>
-#include <asm/errno.h>
-#include <asm/io.h>
-
-#ifdef CONFIG_FSL_ESDHC
-#include <fsl_esdhc.h>
-#endif
-
-u32 get_cpu_rev(void)
-{
-	int reg;
-	int system_rev;
-
-	reg = __raw_readl(ROM_SI_REV);
-	switch (reg) {
-	case 0x02:
-		system_rev = 0x51000 | CHIP_REV_1_1;
-		break;
-	case 0x10:
-		if ((__raw_readl(GPIO1_BASE_ADDR + 0x0) & (0x1 << 22)) == 0)
-			system_rev = 0x51000 | CHIP_REV_2_5;
-		else
-			system_rev = 0x51000 | CHIP_REV_2_0;
-		break;
-	case 0x20:
-		system_rev = 0x51000 | CHIP_REV_3_0;
-		break;
-	return system_rev;
-	default:
-		system_rev = 0x51000 | CHIP_REV_1_0;
-		break;
-	}
-	return system_rev;
-}
-
-
-#if defined(CONFIG_DISPLAY_CPUINFO)
-int print_cpuinfo(void)
-{
-	u32 cpurev;
-
-	cpurev = get_cpu_rev();
-	printf("CPU:   Freescale i.MX51 family rev%d.%d at %d MHz\n",
-		(cpurev & 0xF0) >> 4,
-		(cpurev & 0x0F) >> 4,
-		mxc_get_clock(MXC_ARM_CLK) / 1000000);
-	return 0;
-}
-#endif
-
-/*
- * Initializes on-chip ethernet controllers.
- * to override, implement board_eth_init()
- */
-#if defined(CONFIG_FEC_MXC)
-extern int fecmxc_initialize(bd_t *bis);
-#endif
-
-int cpu_eth_init(bd_t *bis)
-{
-	int rc = -ENODEV;
-
-#if defined(CONFIG_FEC_MXC)
-	rc = fecmxc_initialize(bis);
-#endif
-
-	return rc;
-}
-
-/*
- * Initializes on-chip MMC controllers.
- * to override, implement board_mmc_init()
- */
-int cpu_mmc_init(bd_t *bis)
-{
-#ifdef CONFIG_FSL_ESDHC
-	return fsl_esdhc_mmc_init(bis);
-#else
-	return 0;
-#endif
-}
-
-
-void reset_cpu(ulong addr)
-{
-	__raw_writew(4, WDOG1_BASE_ADDR);
-}
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/speed.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/speed.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/speed.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/speed.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,39 +0,0 @@
-/*
- * (C) Copyright 2000-2003
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * Copyright (C) 2004-2007 Freescale Semiconductor, Inc.
- * TsiChung Liew (Tsi-Chung.Liew@freescale.com)
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/clock.h>
-
-int get_clocks(void)
-{
-	DECLARE_GLOBAL_DATA_PTR;
-
-#ifdef CONFIG_FSL_ESDHC
-	gd->sdhc_clk = mxc_get_clock(MXC_IPG_PERCLK);
-#endif
-	return 0;
-}
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/timer.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/timer.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/timer.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/timer.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,119 +0,0 @@
-/*
- * (C) Copyright 2007
- * Sascha Hauer, Pengutronix
- *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/imx-regs.h>
-
-/* General purpose timers registers */
-struct mxc_gpt {
-	unsigned int control;
-	unsigned int prescaler;
-	unsigned int status;
-	unsigned int nouse[6];
-	unsigned int counter;
-};
-
-static struct mxc_gpt *cur_gpt = (struct mxc_gpt *)GPT1_BASE_ADDR;
-
-/* General purpose timers bitfields */
-#define GPTCR_SWR       (1<<15)	/* Software reset */
-#define GPTCR_FRR       (1<<9)	/* Freerun / restart */
-#define GPTCR_CLKSOURCE_32 (4<<6)	/* Clock source */
-#define GPTCR_TEN       (1)	/* Timer enable */
-
-static ulong timestamp;
-static ulong lastinc;
-
-int timer_init(void)
-{
-	int i;
-
-	/* setup GP Timer 1 */
-	__raw_writel(GPTCR_SWR, &cur_gpt->control);
-
-	/* We have no udelay by now */
-	for (i = 0; i < 100; i++)
-		__raw_writel(0, &cur_gpt->control);
-
-	__raw_writel(0, &cur_gpt->prescaler); /* 32Khz */
-
-	/* Freerun Mode, PERCLK1 input */
-	i = __raw_readl(&cur_gpt->control);
-	__raw_writel(i | GPTCR_CLKSOURCE_32 | GPTCR_TEN, &cur_gpt->control);
-	reset_timer_masked();
-	return 0;
-}
-
-void reset_timer(void)
-{
-	reset_timer_masked();
-}
-
-void reset_timer_masked(void)
-{
-	ulong val = __raw_readl(&cur_gpt->counter);
-	lastinc = val / (CONFIG_MX51_CLK32 / CONFIG_SYS_HZ);
-	timestamp = 0;
-}
-
-ulong get_timer_masked(void)
-{
-	ulong val = __raw_readl(&cur_gpt->counter);
-	val /= (CONFIG_MX51_CLK32 / CONFIG_SYS_HZ);
-	if (val >= lastinc)
-		timestamp += (val - lastinc);
-	else
-		timestamp += ((0xFFFFFFFF / (CONFIG_MX51_CLK32 / CONFIG_SYS_HZ))
-				- lastinc) + val;
-	lastinc = val;
-	return val;
-}
-
-ulong get_timer(ulong base)
-{
-	return get_timer_masked() - base;
-}
-
-void set_timer(ulong t)
-{
-	timestamp = t;
-}
-
-/* delay x useconds AND preserve advance timestamp value */
-void __udelay(unsigned long usec)
-{
-	unsigned long now, start, tmo;
-	tmo = usec * (CONFIG_MX51_CLK32 / 1000) / 1000;
-
-	if (!tmo)
-		tmo = 1;
-
-	now = start = readl(&cur_gpt->counter);
-
-	while ((now - start) < tmo)
-		now = readl(&cur_gpt->counter);
-
-}
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/u-boot.lds u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/u-boot.lds
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/mx51/u-boot.lds	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/mx51/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
@@ -1,61 +0,0 @@
-/*
- * January 2004 - Changed to support H4 device
- * Copyright (c) 2004 Texas Instruments
- *
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
- *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
-OUTPUT_ARCH(arm)
-ENTRY(_start)
-SECTIONS
-{
-	. = 0x00000000;
-
-	. = ALIGN(4);
-	.text	   :
-	{
-	  arch/arm/cpu/arm_cortexa8/start.o
-	  *(.text)
-	}
-
-	. = ALIGN(4);
-	.rodata : { *(.rodata) }
-
-	. = ALIGN(4);
-	.data : { *(.data) }
-
-	. = ALIGN(4);
-	.got : { *(.got) }
-
-	. = .;
-	__u_boot_cmd_start = .;
-	.u_boot_cmd : { *(.u_boot_cmd) }
-	__u_boot_cmd_end = .;
-
-	. = ALIGN(4);
-	__bss_start = .;
-	.bss : { *(.bss) }
-	_end = .;
-}
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/Makefile u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/Makefile
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/Makefile	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/Makefile	2009-08-10 01:39:12.000000000 -0700
@@ -26,10 +26,10 @@ include $(TOPDIR)/config.mk
 LIB	=  $(obj)lib$(SOC).a
 
 SOBJS	:= lowlevel_init.o
-SOBJS	+= cache.o
 SOBJS	+= reset.o
 
 COBJS	+= board.o
+COBJS	+= cache.o
 COBJS	+= clock.o
 COBJS	+= gpio.o
 COBJS	+= mem.o
@@ -37,11 +37,8 @@ COBJS	+= syslib.o
 COBJS	+= sys_info.o
 COBJS	+= timer.o
 
-COBJS-$(CONFIG_EMIF4)	+= emif4.o
-COBJS-$(CONFIG_SDRC)	+= sdrc.o
-
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS) $(COBJS-y) $(SOBJS))
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
 
 all:	 $(obj).depend $(LIB)
 
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/board.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/board.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/board.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/board.c	2010-07-30 15:42:56.000000000 -0700
@@ -36,10 +36,13 @@
 #include <asm/io.h>
 #include <asm/arch/sys_proto.h>
 #include <asm/arch/mem.h>
+#include <nand.h>
 #include <asm/cache.h>
 
 extern omap3_sysinfo sysinfo;
 
+extern u32 is_mem_sdr(void);
+
 /******************************************************************************
  * Routine: delay
  * Description: spinning delay to use before udelay works
@@ -128,30 +131,32 @@ void setup_auxcr()
 {
 	unsigned long i;
 	volatile unsigned int j;
-	/* Save r0, r12 and restore them after usage */
-	__asm__ __volatile__("mov %0, r12":"=r"(j));
-	__asm__ __volatile__("mov %0, r0":"=r"(i));
 
-	/*
-	 * GP Device ROM code API usage here
-	 * r12 = AUXCR Write function and r0 value
-	 */
-	__asm__ __volatile__("mov r12, #0x3");
-	__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
-	/* Enabling ASA */
-	__asm__ __volatile__("orr r0, r0, #0x10");
-	/* Enable L1NEON */
-	__asm__ __volatile__("orr r0, r0, #1 << 5");
-	/* SMI instruction to call ROM Code API */
-	__asm__ __volatile__(".word 0xE1600070");
-	/* Set PLD_FWD bit in L2AUXCR (Cortex-A8 erratum 725233 workaround) */
-	__asm__ __volatile__("mov r12, #0x2");
-	__asm__ __volatile__("mrc p15, 1, r0, c9, c0, 2");
-	__asm__ __volatile__("orr r0, r0, #1 << 27");
-	/* SMI instruction to call ROM Code API */
-	__asm__ __volatile__(".word 0xE1600070");
-	__asm__ __volatile__("mov r0, %0":"=r"(i));
-	__asm__ __volatile__("mov r12, %0":"=r"(j));
+	if (get_cpu_rev() >= CPU_3XX_ES20) {
+		 __asm__ __volatile__("mrc p15, 0, %0, c1, c0, 1":"=r"(i));
+		 /* Enabling ASA and L1NEON */
+		 i |= 0x30;
+		 __asm__ __volatile__("mcr p15, 0, %0, c1, c0, 1"::"r"(i));
+	} else {
+		/* Save r0, r12 and restore them after usage */
+		__asm__ __volatile__("mov %0, r12":"=r"(j));
+		__asm__ __volatile__("mov %0, r0":"=r"(i));
+
+		/*
+		 * GP Device ROM code API usage here
+		 * r12 = AUXCR Write function and r0 value
+		 */
+		__asm__ __volatile__("mov r12, #0x3");
+		__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
+		/* Enabling ASA */
+		__asm__ __volatile__("orr r0, r0, #0x10");
+		/* Enable L1NEON */
+		__asm__ __volatile__("orr r0, r0, #1 << 5");
+		/* SMI instruction to call ROM Code API */
+		__asm__ __volatile__(".word 0xE1600070");
+		__asm__ __volatile__("mov r0, %0":"=r"(i));
+		__asm__ __volatile__("mov r12, %0":"=r"(j));
+	}
 }
 
 /******************************************************************************
@@ -205,7 +210,7 @@ void s_init(void)
 	 * Right now flushing at low MPU speed.
 	 * Need to move after clock init
 	 */
-	invalidate_dcache(get_device_type());
+	v7_flush_dcache_all(get_device_type());
 #ifndef CONFIG_ICACHE_OFF
 	icache_enable();
 #endif
@@ -231,7 +236,7 @@ void s_init(void)
 	per_clocks_enable();
 
 	if (!in_sdram)
-		mem_init();
+		sdrc_init();
 }
 
 /******************************************************************************
@@ -272,6 +277,45 @@ void watchdog_init(void)
 }
 
 /******************************************************************************
+ * Routine: dram_init
+ * Description: sets uboots idea of sdram size
+ *****************************************************************************/
+int dram_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	unsigned int size0 = 0, size1 = 0;
+
+	/*
+	 * If a second bank of DDR is attached to CS1 this is
+	 * where it can be started.  Early init code will init
+	 * memory on CS0.
+	 */
+	if ((sysinfo.mtype == DDR_COMBO) || (sysinfo.mtype == DDR_STACKED)) {
+		do_sdrc_init(CS1, NOT_EARLY);
+		make_cs1_contiguous();
+	}
+
+	size0 = get_sdr_cs_size(CS0);
+	size1 = get_sdr_cs_size(CS1);
+
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = size0;
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_1 + get_sdr_cs_offset(CS1);
+	gd->bd->bi_dram[1].size = size1;
+
+	return 0;
+}
+
+#if !defined(ALICO_CODE) /* kc */
+/******************************************************************************
+ * Dummy function to handle errors for EABI incompatibility
+ *****************************************************************************/
+void raise(void)
+{
+}
+#endif
+
+/******************************************************************************
  * Dummy function to handle errors for EABI incompatibility
  *****************************************************************************/
 void abort(void)
@@ -284,6 +328,25 @@ void abort(void)
  *****************************************************************************/
 static int do_switch_ecc(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 {
+	struct mtd_info *mtd;
+	struct nand_chip *nand;
+
+	/* the following commands operate on the current device */
+	if (nand_curr_device < 0 || nand_curr_device >= CONFIG_SYS_MAX_NAND_DEVICE ||
+	    !nand_info[nand_curr_device].name) {
+		puts("\nno devices available\n");
+		return 1;
+	}
+	mtd = &nand_info[nand_curr_device];
+	nand = mtd->priv;
+
+	if (argc == 1) {
+		if (nand->ecc.mode == NAND_ECC_SOFT)
+			printf("Software ECC\n");
+		else
+			printf("Hardware ECC\n");
+		return 0;
+	}	  
 	if (argc != 2)
 		goto usage;
 	if (strncmp(argv[1], "hw", 2) == 0)
@@ -302,7 +365,7 @@ usage:
 
 U_BOOT_CMD(
 	nandecc, 2, 1,	do_switch_ecc,
-	"switch OMAP3 NAND ECC calculation algorithm",
+	"nandecc - switch OMAP3 NAND ECC calculation algorithm",
 	"[hw/sw] - Switch between NAND hardware (hw) or software (sw) ecc algorithm"
 );
 
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/cache.S u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/cache.S
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/cache.S	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/cache.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,191 +0,0 @@
-/*
- * Copyright (c) 2009 Wind River Systems, Inc.
- * Tom Rix <Tom.Rix@windriver.com>
- *
- * This file is based on and replaces the existing cache.c file
- * The copyrights for the cache.c file are:
- *
- * (C) Copyright 2008 Texas Insturments
- *
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Marius Groeger <mgroeger@sysgo.de>
- *
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <asm/arch/omap3.h>
-
-/*
- * omap3 cache code
- */
-
-.align 5
-.global invalidate_dcache
-.global l2_cache_enable
-.global l2_cache_disable
-
-/*
- *	invalidate_dcache()
- *
- *	Invalidate the whole D-cache.
- *
- *	Corrupted registers: r0-r5, r7, r9-r11
- *
- *	- mm	- mm_struct describing address space
- */
-invalidate_dcache:
-	stmfd	r13!, {r0 - r5, r7, r9 - r12, r14}
-
-	mov	r7, r0				@ take a backup of device type
-	cmp	r0, #0x3			@ check if the device type is
-						@ GP
-	moveq r12, #0x1				@ set up to invalide L2
-smi:	.word 0x01600070			@ Call SMI monitor (smieq)
-	cmp	r7, #0x3			@ compare again in case its
-						@ lost
-	beq	finished_inval			@ if GP device, inval done
-						@ above
-
-	mrc	p15, 1, r0, c0, c0, 1		@ read clidr
-	ands	r3, r0, #0x7000000		@ extract loc from clidr
-	mov	r3, r3, lsr #23			@ left align loc bit field
-	beq	finished_inval			@ if loc is 0, then no need to
-						@ clean
-	mov	r10, #0				@ start clean at cache level 0
-inval_loop1:
-	add	r2, r10, r10, lsr #1		@ work out 3x current cache
-						@ level
-	mov	r1, r0, lsr r2			@ extract cache type bits from
-						@ clidr
-	and	r1, r1, #7			@ mask of the bits for current
-						@ cache only
-	cmp	r1, #2				@ see what cache we have at
-						@ this level
-	blt	skip_inval			@ skip if no cache, or just
-						@ i-cache
-	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level
-						@ in cssr
-	mov	r2, #0				@ operand for mcr SBZ
-	mcr	p15, 0, r2, c7, c5, 4		@ flush prefetch buffer to
-						@ sych the new cssr&csidr,
-						@ with armv7 this is 'isb',
-						@ but we compile with armv5
-	mrc	p15, 1, r1, c0, c0, 0		@ read the new csidr
-	and	r2, r1, #7			@ extract the length of the
-						@ cache lines
-	add	r2, r2, #4			@ add 4 (line length offset)
-	ldr	r4, =0x3ff
-	ands	r4, r4, r1, lsr #3		@ find maximum number on the
-						@ way size
-	clz	r5, r4				@ find bit position of way
-						@ size increment
-	ldr	r7, =0x7fff
-	ands	r7, r7, r1, lsr #13		@ extract max number of the
-						@ index size
-inval_loop2:
-	mov	r9, r4				@ create working copy of max
-						@ way size
-inval_loop3:
-	orr	r11, r10, r9, lsl r5		@ factor way and cache number
-						@ into r11
-	orr	r11, r11, r7, lsl r2		@ factor index number into r11
-	mcr	p15, 0, r11, c7, c6, 2		@ invalidate by set/way
-	subs	r9, r9, #1			@ decrement the way
-	bge	inval_loop3
-	subs	r7, r7, #1			@ decrement the index
-	bge	inval_loop2
-skip_inval:
-	add	r10, r10, #2			@ increment cache number
-	cmp	r3, r10
-	bgt	inval_loop1
-finished_inval:
-	mov	r10, #0				@ swith back to cache level 0
-	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level
-						@ in cssr
-	mcr	p15, 0, r10, c7, c5, 4		@ flush prefetch buffer,
-						@ with armv7 this is 'isb',
-						@ but we compile with armv5
-
-	ldmfd	r13!, {r0 - r5, r7, r9 - r12, pc}
-
-
-l2_cache_enable:
-	stmfd	r13!, {r0, r1, r2, lr}
-	@ ES2 onwards we can disable/enable L2 ourselves
-	bl	get_cpu_rev
-	cmp	r0, #CPU_3XX_ES20
-	blt	l2_cache_disable_EARLIER_THAN_ES2
-	mrc	15, 0, r3, cr1, cr0, 1
-	orr	r3, r3, #2
-	mcr	15, 0, r3, cr1, cr0, 1
-	b	l2_cache_enable_END
-l2_cache_enable_EARLIER_THAN_ES2:
-	@ Save r0, r12 and restore them after usage
-	mov	r3, ip
-	str	r3, [sp, #4]
-	mov	r3, r0
-	@
-	@ GP Device ROM code API usage here
-	@ r12 = AUXCR Write function and r0 value
-	@
-	mov	ip, #3
-	mrc	15, 0, r0, cr1, cr0, 1
-	orr	r0, r0, #2
-	@ SMI instruction to call ROM Code API
-	.word	0xe1600070
-	mov	r0, r3
-	mov	ip, r3
-	str	r3, [sp, #4]
-l2_cache_enable_END:
-	ldmfd	r13!, {r1, r2, r3, pc}
-
-
-l2_cache_disable:
-	stmfd	r13!, {r0, r1, r2, lr}
-	@ ES2 onwards we can disable/enable L2 ourselves
-	bl	get_cpu_rev
-	cmp	r0, #CPU_3XX_ES20
-	blt	l2_cache_disable_EARLIER_THAN_ES2
-	mrc	15, 0, r3, cr1, cr0, 1
-	bic	r3, r3, #2
-	mcr	15, 0, r3, cr1, cr0, 1
-	b	l2_cache_disable_END
-l2_cache_disable_EARLIER_THAN_ES2:
-	@ Save r0, r12 and restore them after usage
-	mov	r3, ip
-	str	r3, [sp, #4]
-	mov	r3, r0
-	@
-	@ GP Device ROM code API usage here
-	@ r12 = AUXCR Write function and r0 value
-	@
-	mov	ip, #3
-	mrc	15, 0, r0, cr1, cr0, 1
-	bic	r0, r0, #2
-	@ SMI instruction to call ROM Code API
-	.word	0xe1600070
-	mov	r0, r3
-	mov	ip, r3
-	str	r3, [sp, #4]
-l2_cache_disable_END:
-	ldmfd	r13!, {r1, r2, r3, pc}
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/cache.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/cache.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/cache.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/cache.c	2010-06-25 11:38:14.000000000 -0700
@@ -0,0 +1,95 @@
+/*
+ * (C) Copyright 2008 Texas Insturments
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * omap3 L2 cache code
+ */
+
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/cache.h>
+
+void l2_cache_enable(void)
+{
+	unsigned long i;
+	volatile unsigned int j;
+
+	/* ES2 onwards we can disable/enable L2 ourselves */
+	if (get_cpu_rev() >= CPU_3XX_ES20) {
+		__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 1":"=r"(i));
+		__asm__ __volatile__("orr %0, %0, #0x2":"=r"(i));
+		__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 1"::"r"(i));
+	} else {
+		/* Save r0, r12 and restore them after usage */
+		__asm__ __volatile__("mov %0, r12":"=r"(j));
+		__asm__ __volatile__("mov %0, r0":"=r"(i));
+
+		/*
+		 * GP Device ROM code API usage here
+		 * r12 = AUXCR Write function and r0 value
+		 */
+		__asm__ __volatile__("mov r12, #0x3");
+		__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
+		__asm__ __volatile__("orr r0, r0, #0x2");
+		/* SMI instruction to call ROM Code API */
+		__asm__ __volatile__(".word 0xE1600070");
+		__asm__ __volatile__("mov r0, %0":"=r"(i));
+		__asm__ __volatile__("mov r12, %0":"=r"(j));
+	}
+
+}
+
+void l2_cache_disable(void)
+{
+	unsigned long i;
+	volatile unsigned int j;
+
+	/* ES2 onwards we can disable/enable L2 ourselves */
+	if (get_cpu_rev() >= CPU_3XX_ES20) {
+		__asm__ __volatile__("mrc p15, 0, %0, c1, c0, 1":"=r"(i));
+		__asm__ __volatile__("bic %0, %0, #0x2":"=r"(i));
+		__asm__ __volatile__("mcr p15, 0, %0, c1, c0, 1"::"r"(i));
+	} else {
+		/* Save r0, r12 and restore them after usage */
+		__asm__ __volatile__("mov %0, r12":"=r"(j));
+		__asm__ __volatile__("mov %0, r0":"=r"(i));
+
+		/*
+		 * GP Device ROM code API usage here
+		 * r12 = AUXCR Write function and r0 value
+		 */
+		__asm__ __volatile__("mov r12, #0x3");
+		__asm__ __volatile__("mrc p15, 0, r0, c1, c0, 1");
+		__asm__ __volatile__("bic r0, r0, #0x2");
+		/* SMI instruction to call ROM Code API */
+		__asm__ __volatile__(".word 0xE1600070");
+		__asm__ __volatile__("mov r0, %0":"=r"(i));
+		__asm__ __volatile__("mov r12, %0":"=r"(j));
+	}
+}
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/clock.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/clock.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/clock.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/clock.c	2009-08-10 01:39:12.000000000 -0700
@@ -40,7 +40,7 @@
  *****************************************************************************/
 u32 get_osc_clk_speed(void)
 {
-	u32 start, cstart, cend, cdiff, cdiv, val;
+	u32 start, cstart, cend, cdiff, val;
 	struct prcm *prcm_base = (struct prcm *)PRCM_BASE;
 	struct prm *prm_base = (struct prm *)PRM_BASE;
 	struct gptimer *gpt1_base = (struct gptimer *)OMAP34XX_GPT1;
@@ -48,15 +48,9 @@ u32 get_osc_clk_speed(void)
 
 	val = readl(&prm_base->clksrc_ctrl);
 
-	if (val & SYSCLKDIV_2)
-		cdiv = 2;
-	else if (val & SYSCLKDIV_1)
-		cdiv = 1;
-	else
-		/*
-		 * Should never reach here! (Assume divider as 1)
-		 */
-		cdiv = 1;
+	/* If SYS_CLK is being divided by 2, remove for now */
+	val = (val & (~SYSCLKDIV_2)) | SYSCLKDIV_1;
+	writel(val, &prm_base->clksrc_ctrl);
 
 	/* enable timer2 */
 	val = readl(&prcm_base->clksel_wkup) | CLKSEL_GPT1;
@@ -67,7 +61,6 @@ u32 get_osc_clk_speed(void)
 	/* Enable I and F Clocks for GPT1 */
 	val = readl(&prcm_base->iclken_wkup) | EN_GPT1 | EN_32KSYNC;
 	writel(val, &prcm_base->iclken_wkup);
-
 	val = readl(&prcm_base->fclken_wkup) | EN_GPT1;
 	writel(val, &prcm_base->fclken_wkup);
 
@@ -90,11 +83,6 @@ u32 get_osc_clk_speed(void)
 	cend = readl(&gpt1_base->tcrr);		/* get end sys_clk count */
 	cdiff = cend - cstart;			/* get elapsed ticks */
 
-	if (cdiv == 2)
-	{
-		cdiff *= 2;
-	}
-
 	/* based on number of ticks assign speed */
 	if (cdiff > 19000)
 		return S38_4M;
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/emif4.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/emif4.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/emif4.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/emif4.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,168 +0,0 @@
-/*
- * Author :
- *     Vaibhav Hiremath <hvaibhav@ti.com>
- *
- * Based on mem.c and sdrc.c
- *
- * Copyright (C) 2010
- * Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/mem.h>
-#include <asm/arch/sys_proto.h>
-#include <asm/arch/emif4.h>
-
-extern omap3_sysinfo sysinfo;
-
-static emif4_t *emif4_base = (emif4_t *)OMAP34XX_SDRC_BASE;
-
-/*
- * is_mem_sdr -
- *  - Return 1 if mem type in use is SDR
- */
-u32 is_mem_sdr(void)
-{
-	return 0;
-}
-
-/*
- * get_sdr_cs_size -
- *  - Get size of chip select 0/1
- */
-u32 get_sdr_cs_size(u32 cs)
-{
-	u32 size;
-
-	/* TODO: Calculate the size based on EMIF4 configuration */
-	size = CONFIG_SYS_CS0_SIZE;
-
-	return size;
-}
-
-/*
- * get_sdr_cs_offset -
- *  - Get offset of cs from cs0 start
- */
-u32 get_sdr_cs_offset(u32 cs)
-{
-	u32 offset = 0;
-
-	return offset;
-}
-
-/*
- * do_emif4_init -
- *  - Init the emif4 module for DDR access
- *  - Early init routines, called from flash or SRAM.
- */
-void do_emif4_init(void)
-{
-	unsigned int regval;
-	/* Set the DDR PHY parameters in PHY ctrl registers */
-	regval = (EMIF4_DDR1_READ_LAT | EMIF4_DDR1_PWRDN_DIS |
-		EMIF4_DDR1_EXT_STRB_DIS);
-	writel(regval, &emif4_base->ddr_phyctrl1);
-	writel(regval, &emif4_base->ddr_phyctrl1_shdw);
-	writel(0, &emif4_base->ddr_phyctrl2);
-
-	/* Reset the DDR PHY and wait till completed */
-	regval = readl(&emif4_base->sdram_iodft_tlgc);
-	regval |= (1<<10);
-	writel(regval, &emif4_base->sdram_iodft_tlgc);
-	/*Wait till that bit clears*/
-	while ((readl(&emif4_base->sdram_iodft_tlgc) & (1<<10)) == 0x1);
-	/*Re-verify the DDR PHY status*/
-	while ((readl(&emif4_base->sdram_sts) & (1<<2)) == 0x0);
-
-	regval |= (1<<0);
-	writel(regval, &emif4_base->sdram_iodft_tlgc);
-	/* Set SDR timing registers */
-	regval = (EMIF4_TIM1_T_WTR | EMIF4_TIM1_T_RRD |
-		EMIF4_TIM1_T_RC | EMIF4_TIM1_T_RAS |
-		EMIF4_TIM1_T_WR | EMIF4_TIM1_T_RCD |
-		EMIF4_TIM1_T_RP);
-	writel(regval, &emif4_base->sdram_time1);
-	writel(regval, &emif4_base->sdram_time1_shdw);
-
-	regval = (EMIF4_TIM2_T_CKE | EMIF4_TIM2_T_RTP |
-		EMIF4_TIM2_T_XSRD | EMIF4_TIM2_T_XSNR |
-		EMIF4_TIM2_T_ODT | EMIF4_TIM2_T_XP);
-	writel(regval, &emif4_base->sdram_time2);
-	writel(regval, &emif4_base->sdram_time2_shdw);
-
-	regval = (EMIF4_TIM3_T_RAS_MAX | EMIF4_TIM3_T_RFC);
-	writel(regval, &emif4_base->sdram_time3);
-	writel(regval, &emif4_base->sdram_time3_shdw);
-
-	/* Set the PWR control register */
-	regval = (EMIF4_PWR_PM_TIM | EMIF4_PWR_LP_MODE |
-		EMIF4_PWR_DPD_DIS | EMIF4_PWR_IDLE_MODE);
-	writel(regval, &emif4_base->sdram_pwr_mgmt);
-	writel(regval, &emif4_base->sdram_pwr_mgmt_shdw);
-
-	/* Set the DDR refresh rate control register */
-	regval = (EMIF4_REFRESH_RATE | EMIF4_INITREF_DIS);
-	writel(regval, &emif4_base->sdram_refresh_ctrl);
-	writel(regval, &emif4_base->sdram_refresh_ctrl_shdw);
-
-	/* set the SDRAM configuration register */
-	regval = (EMIF4_CFG_PGSIZE | EMIF4_CFG_EBANK |
-		EMIF4_CFG_IBANK | EMIF4_CFG_ROWSIZE |
-		EMIF4_CFG_CL | EMIF4_CFG_NARROW_MD |
-		EMIF4_CFG_SDR_DRV | EMIF4_CFG_DDR_DIS_DLL |
-		EMIF4_CFG_DDR2_DDQS | EMIF4_CFG_DDR_TERM |
-		EMIF4_CFG_IBANK_POS | EMIF4_CFG_SDRAM_TYP);
-	writel(regval, &emif4_base->sdram_config);
-}
-
-/*
- * dram_init -
- *  - Sets uboots idea of sdram size
- */
-int dram_init(void)
-{
-	DECLARE_GLOBAL_DATA_PTR;
-	unsigned int size0 = 0, size1 = 0;
-
-	size0 = get_sdr_cs_size(CS0);
-	/*
-	 * If a second bank of DDR is attached to CS1 this is
-	 * where it can be started.  Early init code will init
-	 * memory on CS0.
-	 */
-	if ((sysinfo.mtype == DDR_COMBO) || (sysinfo.mtype == DDR_STACKED))
-		size1 = get_sdr_cs_size(CS1);
-
-	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
-	gd->bd->bi_dram[0].size = size0;
-	gd->bd->bi_dram[1].start = PHYS_SDRAM_1 + get_sdr_cs_offset(CS1);
-	gd->bd->bi_dram[1].size = size1;
-
-	return 0;
-}
-
-/*
- * mem_init() -
- *  - Initialize memory subsystem
- */
-void mem_init(void)
-{
-	do_emif4_init();
-}
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/mem.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/mem.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/mem.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/mem.c	2010-07-28 18:25:38.000000000 -0700
@@ -44,7 +44,7 @@ volatile unsigned int boot_flash_env_add
 struct gpmc *gpmc_cfg;
 
 #if defined(CONFIG_CMD_NAND)
-static const u32 gpmc_m_nand[GPMC_MAX_REG] = {
+static u32 gpmc_m_nand[GPMC_MAX_REG] = {
 	M_NAND_GPMC_CONFIG1,
 	M_NAND_GPMC_CONFIG2,
 	M_NAND_GPMC_CONFIG3,
@@ -62,7 +62,7 @@ static const u32 gpmc_m_nand[GPMC_MAX_RE
 #endif
 
 #if defined(CONFIG_CMD_ONENAND)
-static const u32 gpmc_onenand[GPMC_MAX_REG] = {
+static u32 gpmc_onenand[GPMC_MAX_REG] = {
 	ONENAND_GPMC_CONFIG1,
 	ONENAND_GPMC_CONFIG2,
 	ONENAND_GPMC_CONFIG3,
@@ -79,6 +79,26 @@ static const u32 gpmc_onenand[GPMC_MAX_R
 
 #endif
 
+static struct sdrc *sdrc_base = (struct sdrc *)OMAP34XX_SDRC_BASE;
+
+/**************************************************************************
+ * make_cs1_contiguous() - for es2 and above remap cs1 behind cs0 to allow
+ *  command line mem=xyz use all memory with out discontinuous support
+ *  compiled in.  Could do it at the ATAG, but there really is two banks...
+ * Called as part of 2nd phase DDR init.
+ **************************************************************************/
+void make_cs1_contiguous(void)
+{
+	u32 size, a_add_low, a_add_high;
+
+	size = get_sdr_cs_size(CS0);
+	size /= SZ_32M;			/* find size to offset CS1 */
+	a_add_high = (size & 3) << 8;	/* set up low field */
+	a_add_low = (size & 0x3C) >> 2;	/* set up high field */
+	writel((a_add_high | a_add_low), &sdrc_base->cs_cfg);
+
+}
+
 /********************************************************
  *  mem_ok() - test used to see if timings are correct
  *             for a part. Helps in guessing which part
@@ -103,6 +123,75 @@ u32 mem_ok(u32 cs)
 		return 1;
 }
 
+/********************************************************
+ *  sdrc_init() - init the sdrc chip selects CS0 and CS1
+ *  - early init routines, called from flash or
+ *  SRAM.
+ *******************************************************/
+void sdrc_init(void)
+{
+	/* only init up first bank here */
+	do_sdrc_init(CS0, EARLY_INIT);
+}
+
+/*************************************************************************
+ * do_sdrc_init(): initialize the SDRAM for use.
+ *  -code sets up SDRAM basic SDRC timings for CS0
+ *  -optimal settings can be placed here, or redone after i2c
+ *      inspection of board info
+ *
+ *  - code called once in C-Stack only context for CS0 and a possible 2nd
+ *      time depending on memory configuration from stack+global context
+ **************************************************************************/
+
+void do_sdrc_init(u32 cs, u32 early)
+{
+	struct sdrc_actim *sdrc_actim_base;
+
+	if(cs)
+		sdrc_actim_base = (struct sdrc_actim *)SDRC_ACTIM_CTRL1_BASE;
+	else
+		sdrc_actim_base = (struct sdrc_actim *)SDRC_ACTIM_CTRL0_BASE;
+
+	if (early) {
+		/* reset sdrc controller */
+		writel(SOFTRESET, &sdrc_base->sysconfig);
+		wait_on_value(RESETDONE, RESETDONE, &sdrc_base->status,
+			      12000000);
+		writel(0, &sdrc_base->sysconfig);
+
+		/* setup sdrc to ball mux */
+		writel(SDRC_SHARING, &sdrc_base->sharing);
+
+		/* Disable Power Down of CKE cuz of 1 CKE on combo part */
+		writel(SRFRONRESET | PAGEPOLICY_HIGH, &sdrc_base->power);
+
+		writel(ENADLL | DLLPHASE_90, &sdrc_base->dlla_ctrl);
+		sdelay(0x20000);
+	}
+
+	writel(RASWIDTH_13BITS | CASWIDTH_10BITS | ADDRMUXLEGACY |
+		RAMSIZE_128 | BANKALLOCATION | B32NOT16 | B32NOT16 |
+		DEEPPD | DDR_SDRAM, &sdrc_base->cs[cs].mcfg);
+	writel(ARCV | ARE_ARCV_1, &sdrc_base->cs[cs].rfr_ctrl);
+	writel(V_ACTIMA_165, &sdrc_actim_base->ctrla);
+	writel(V_ACTIMB_165, &sdrc_actim_base->ctrlb);
+
+	writel(CMD_NOP, &sdrc_base ->cs[cs].manual);
+	writel(CMD_PRECHARGE, &sdrc_base->cs[cs].manual);
+	writel(CMD_AUTOREFRESH, &sdrc_base->cs[cs].manual);
+	writel(CMD_AUTOREFRESH, &sdrc_base->cs[cs].manual);
+
+	/*
+	 * CAS latency 3, Write Burst = Read Burst, Serial Mode,
+	 * Burst length = 4
+	 */
+	writel(CASL3 | BURSTLENGTH4, &sdrc_base->cs[cs].mr);
+
+	if (!mem_ok(cs))
+		writel(0, &sdrc_base->cs[cs].mcfg);
+}
+
 void enable_gpmc_cs_config(const u32 *gpmc_config, struct gpmc_cs *cs, u32 base,
 			u32 size)
 {
@@ -129,16 +218,12 @@ void enable_gpmc_cs_config(const u32 *gp
 void gpmc_init(void)
 {
 	/* putting a blanket check on GPMC based on ZeBu for now */
+	u32 *gpmc_config = NULL;
 	gpmc_cfg = (struct gpmc *)GPMC_BASE;
-#if defined(CONFIG_CMD_NAND) || defined(CONFIG_CMD_ONENAND)
-	const u32 *gpmc_config = NULL;
 	u32 base = 0;
 	u32 size = 0;
-#if defined(CONFIG_ENV_IS_IN_NAND) || defined(CONFIG_ENV_IS_IN_ONENAND)
 	u32 f_off = CONFIG_SYS_MONITOR_LEN;
 	u32 f_sec = 0;
-#endif
-#endif
 	u32 config = 0;
 
 	/* global settings */
@@ -164,7 +249,7 @@ void gpmc_init(void)
 	enable_gpmc_cs_config(gpmc_config, &gpmc_cfg->cs[0], base, size);
 #if defined(CONFIG_ENV_IS_IN_NAND)
 	f_off = SMNAND_ENV_OFFSET;
-	f_sec = (128 << 10);	/* 128 KiB */
+	f_sec = SZ_128K;
 	/* env setup */
 	boot_flash_base = base;
 	boot_flash_off = f_off;
@@ -180,7 +265,7 @@ void gpmc_init(void)
 	enable_gpmc_cs_config(gpmc_config, &gpmc_cfg->cs[0], base, size);
 #if defined(CONFIG_ENV_IS_IN_ONENAND)
 	f_off = ONENAND_ENV_OFFSET;
-	f_sec = (128 << 10);	/* 128 KiB */
+	f_sec = SZ_128K;
 	/* env setup */
 	boot_flash_base = base;
 	boot_flash_off = f_off;
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/sdrc.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/sdrc.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/sdrc.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/sdrc.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,202 +0,0 @@
-/*
- * Functions related to OMAP3 SDRC.
- *
- * This file has been created after exctracting and consolidating
- * the SDRC related content from mem.c and board.c, also created
- * generic init function (mem_init).
- *
- * Copyright (C) 2004-2010
- * Texas Instruments Incorporated - http://www.ti.com/
- *
- * Author :
- *     Vaibhav Hiremath <hvaibhav@ti.com>
- *
- * Original implementation by (mem.c, board.c) :
- *      Sunil Kumar <sunilsaini05@gmail.com>
- *      Shashi Ranjan <shashiranjanmca05@gmail.com>
- *      Manikandan Pillai <mani.pillai@ti.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/mem.h>
-#include <asm/arch/sys_proto.h>
-
-extern omap3_sysinfo sysinfo;
-
-static struct sdrc *sdrc_base = (struct sdrc *)OMAP34XX_SDRC_BASE;
-
-/*
- * is_mem_sdr -
- *  - Return 1 if mem type in use is SDR
- */
-u32 is_mem_sdr(void)
-{
-	if (readl(&sdrc_base->cs[CS0].mr) == SDRC_MR_0_SDR)
-		return 1;
-	return 0;
-}
-
-/*
- * make_cs1_contiguous -
- *  - For es2 and above remap cs1 behind cs0 to allow command line
- *    mem=xyz use all memory with out discontinuous support compiled in.
- *    Could do it at the ATAG, but there really is two banks...
- *  - Called as part of 2nd phase DDR init.
- */
-void make_cs1_contiguous(void)
-{
-	u32 size, a_add_low, a_add_high;
-
-	size = get_sdr_cs_size(CS0);
-	size >>= 25;	/* divide by 32 MiB to find size to offset CS1 */
-	a_add_high = (size & 3) << 8;	/* set up low field */
-	a_add_low = (size & 0x3C) >> 2;	/* set up high field */
-	writel((a_add_high | a_add_low), &sdrc_base->cs_cfg);
-
-}
-
-
-/*
- * get_sdr_cs_size -
- *  - Get size of chip select 0/1
- */
-u32 get_sdr_cs_size(u32 cs)
-{
-	u32 size;
-
-	/* get ram size field */
-	size = readl(&sdrc_base->cs[cs].mcfg) >> 8;
-	size &= 0x3FF;		/* remove unwanted bits */
-	size <<= 21;		/* multiply by 2 MiB to find size in MB */
-	return size;
-}
-
-/*
- * get_sdr_cs_offset -
- *  - Get offset of cs from cs0 start
- */
-u32 get_sdr_cs_offset(u32 cs)
-{
-	u32 offset;
-
-	if (!cs)
-		return 0;
-
-	offset = readl(&sdrc_base->cs_cfg);
-	offset = (offset & 15) << 27 | (offset & 0x30) >> 17;
-
-	return offset;
-}
-
-/*
- * do_sdrc_init -
- *  - Initialize the SDRAM for use.
- *  - Sets up SDRC timings for CS0
- *  - code called once in C-Stack only context for CS0 and a possible 2nd
- *    time depending on memory configuration from stack+global context
- */
-void do_sdrc_init(u32 cs, u32 early)
-{
-	struct sdrc_actim *sdrc_actim_base;
-
-	if (cs)
-		sdrc_actim_base = (struct sdrc_actim *)SDRC_ACTIM_CTRL1_BASE;
-	else
-		sdrc_actim_base = (struct sdrc_actim *)SDRC_ACTIM_CTRL0_BASE;
-
-	if (early) {
-		/* reset sdrc controller */
-		writel(SOFTRESET, &sdrc_base->sysconfig);
-		wait_on_value(RESETDONE, RESETDONE, &sdrc_base->status,
-				12000000);
-		writel(0, &sdrc_base->sysconfig);
-
-		/* setup sdrc to ball mux */
-		writel(SDRC_SHARING, &sdrc_base->sharing);
-
-		/* Disable Power Down of CKE cuz of 1 CKE on combo part */
-		writel(WAKEUPPROC | SRFRONRESET | PAGEPOLICY_HIGH,
-				&sdrc_base->power);
-
-		writel(ENADLL | DLLPHASE_90, &sdrc_base->dlla_ctrl);
-		sdelay(0x20000);
-	}
-
-	writel(RASWIDTH_13BITS | CASWIDTH_10BITS | ADDRMUXLEGACY |
-			RAMSIZE_128 | BANKALLOCATION | B32NOT16 | B32NOT16 |
-			DEEPPD | DDR_SDRAM, &sdrc_base->cs[cs].mcfg);
-	writel(ARCV | ARE_ARCV_1, &sdrc_base->cs[cs].rfr_ctrl);
-	writel(V_ACTIMA_165, &sdrc_actim_base->ctrla);
-	writel(V_ACTIMB_165, &sdrc_actim_base->ctrlb);
-
-	writel(CMD_NOP, &sdrc_base->cs[cs].manual);
-	writel(CMD_PRECHARGE, &sdrc_base->cs[cs].manual);
-	writel(CMD_AUTOREFRESH, &sdrc_base->cs[cs].manual);
-	writel(CMD_AUTOREFRESH, &sdrc_base->cs[cs].manual);
-
-	/*
-	 * CAS latency 3, Write Burst = Read Burst, Serial Mode,
-	 * Burst length = 4
-	 */
-	writel(CASL3 | BURSTLENGTH4, &sdrc_base->cs[cs].mr);
-
-	if (!mem_ok(cs))
-		writel(0, &sdrc_base->cs[cs].mcfg);
-}
-
-/*
- * dram_init -
- *  - Sets uboots idea of sdram size
- */
-int dram_init(void)
-{
-	DECLARE_GLOBAL_DATA_PTR;
-	unsigned int size0 = 0, size1 = 0;
-
-	size0 = get_sdr_cs_size(CS0);
-	/*
-	 * If a second bank of DDR is attached to CS1 this is
-	 * where it can be started.  Early init code will init
-	 * memory on CS0.
-	 */
-	if ((sysinfo.mtype == DDR_COMBO) || (sysinfo.mtype == DDR_STACKED)) {
-		do_sdrc_init(CS1, NOT_EARLY);
-		make_cs1_contiguous();
-
-		size1 = get_sdr_cs_size(CS1);
-	}
-
-	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
-	gd->bd->bi_dram[0].size = size0;
-	gd->bd->bi_dram[1].start = PHYS_SDRAM_1 + get_sdr_cs_offset(CS1);
-	gd->bd->bi_dram[1].size = size1;
-
-	return 0;
-}
-
-/*
- * mem_init -
- *  - Init the sdrc chip,
- *  - Selects CS0 and CS1,
- */
-void mem_init(void)
-{
-	/* only init up first bank here */
-	do_sdrc_init(CS0, EARLY_INIT);
-}
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/sys_info.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/sys_info.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/omap3/sys_info.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/omap3/sys_info.c	2010-07-28 18:26:41.000000000 -0700
@@ -32,6 +32,7 @@
 #include <i2c.h>
 
 extern omap3_sysinfo sysinfo;
+static struct sdrc *sdrc_base = (struct sdrc *)OMAP34XX_SDRC_BASE;
 static struct ctrl *ctrl_base = (struct ctrl *)OMAP34XX_CTRL_BASE;
 static char *rev_s[CPU_3XX_MAX_REV] = {
 				"1.0",
@@ -103,6 +104,46 @@ u32 get_cpu_rev(void)
 	}
 }
 
+/****************************************************
+ * is_mem_sdr() - return 1 if mem type in use is SDR
+ ****************************************************/
+u32 is_mem_sdr(void)
+{
+	if (readl(&sdrc_base->cs[CS0].mr) == SDRC_MR_0_SDR)
+		return 1;
+	return 0;
+}
+
+/***********************************************************************
+ * get_cs0_size() - get size of chip select 0/1
+ ************************************************************************/
+u32 get_sdr_cs_size(u32 cs)
+{
+	u32 size;
+
+	/* get ram size field */
+	size = readl(&sdrc_base->cs[cs].mcfg) >> 8;
+	size &= 0x3FF;		/* remove unwanted bits */
+	size *= SZ_2M;		/* find size in MB */
+	return size;
+}
+
+/***********************************************************************
+ * get_sdr_cs_offset() - get offset of cs from cs0 start
+ ************************************************************************/
+u32 get_sdr_cs_offset(u32 cs)
+{
+	u32 offset;
+
+	if (!cs)
+		return 0;
+
+	offset = readl(&sdrc_base->cs_cfg);
+	offset = (offset & 15) << 27 | (offset & 0x30) >> 17;
+
+	return offset;
+}
+
 /***************************************************************************
  *  get_gpmc0_base() - Return current address hardware will be
  *     fetching from. The below effectively gives what is correct, its a bit
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/Makefile u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/Makefile
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/Makefile	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/Makefile	1969-12-31 16:00:00.000000000 -0800
@@ -1,54 +0,0 @@
-#
-# (C) Copyright 2000-2003
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# (C) Copyright 2008
-# Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= $(obj)lib$(SOC).a
-
-SOBJS	= cache.o
-SOBJS	+= reset.o
-
-COBJS	+= clock.o
-COBJS	+= cpu_info.o
-COBJS	+= sromc.o
-COBJS	+= timer.o
-
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
-
-all:	 $(obj).depend $(LIB)
-
-$(LIB):	$(OBJS)
-	$(AR) $(ARFLAGS) $@ $(OBJS)
-
-#########################################################################
-
-# defines $(obj).depend target
-include $(SRCTREE)/rules.mk
-
-sinclude $(obj).depend
-
-#########################################################################
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/cache.S u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/cache.S
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/cache.S	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/cache.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,120 +0,0 @@
-/*
- * Copyright (C) 2009 Samsung Electronics
- * Minkyu Kang <mk7.kang@samsung.com>
- *
- * based on arch/arm/cpu/arm_cortexa8/omap3/cache.S
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <asm/arch/cpu.h>
-
-.align 5
-.global invalidate_dcache
-.global l2_cache_enable
-.global l2_cache_disable
-
-/*
- * invalidate_dcache()
- * Invalidate the whole D-cache.
- *
- * Corrupted registers: r0-r5, r7, r9-r11
- */
-invalidate_dcache:
-	stmfd	r13!, {r0 - r5, r7, r9 - r12, r14}
-
-	cmp	r0, #0xC100			@ check if the cpu is s5pc100
-
-	beq	finished_inval			@ s5pc100 doesn't need this
-						@ routine
-	mrc	p15, 1, r0, c0, c0, 1		@ read clidr
-	ands	r3, r0, #0x7000000		@ extract loc from clidr
-	mov	r3, r3, lsr #23			@ left align loc bit field
-	beq	finished_inval			@ if loc is 0, then no need to
-						@ clean
-	mov	r10, #0				@ start clean at cache level 0
-inval_loop1:
-	add	r2, r10, r10, lsr #1		@ work out 3x current cache
-						@ level
-	mov	r1, r0, lsr r2			@ extract cache type bits from
-						@ clidr
-	and	r1, r1, #7			@ mask of the bits for current
-						@ cache only
-	cmp	r1, #2				@ see what cache we have at
-						@ this level
-	blt	skip_inval			@ skip if no cache, or just
-						@ i-cache
-	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level
-						@ in cssr
-	mov	r2, #0				@ operand for mcr SBZ
-	mcr	p15, 0, r2, c7, c5, 4		@ flush prefetch buffer to
-						@ sych the new cssr&csidr,
-						@ with armv7 this is 'isb',
-						@ but we compile with armv5
-	mrc	p15, 1, r1, c0, c0, 0		@ read the new csidr
-	and	r2, r1, #7			@ extract the length of the
-						@ cache lines
-	add	r2, r2, #4			@ add 4 (line length offset)
-	ldr	r4, =0x3ff
-	ands	r4, r4, r1, lsr #3		@ find maximum number on the
-						@ way size
-	clz	r5, r4				@ find bit position of way
-						@ size increment
-	ldr	r7, =0x7fff
-	ands	r7, r7, r1, lsr #13		@ extract max number of the
-						@ index size
-inval_loop2:
-	mov	r9, r4				@ create working copy of max
-						@ way size
-inval_loop3:
-	orr	r11, r10, r9, lsl r5		@ factor way and cache number
-						@ into r11
-	orr	r11, r11, r7, lsl r2		@ factor index number into r11
-	mcr	p15, 0, r11, c7, c6, 2		@ invalidate by set/way
-	subs	r9, r9, #1			@ decrement the way
-	bge	inval_loop3
-	subs	r7, r7, #1			@ decrement the index
-	bge	inval_loop2
-skip_inval:
-	add	r10, r10, #2			@ increment cache number
-	cmp	r3, r10
-	bgt	inval_loop1
-finished_inval:
-	mov	r10, #0				@ swith back to cache level 0
-	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level
-						@ in cssr
-	mcr	p15, 0, r10, c7, c5, 4		@ flush prefetch buffer,
-						@ with armv7 this is 'isb',
-						@ but we compile with armv5
-
-	ldmfd	r13!, {r0 - r5, r7, r9 - r12, pc}
-
-l2_cache_enable:
-	push	{r0, r1, r2, lr}
-	mrc	15, 0, r3, cr1, cr0, 1
-	orr	r3, r3, #2
-	mcr	15, 0, r3, cr1, cr0, 1
-	pop	{r1, r2, r3, pc}
-
-l2_cache_disable:
-	push	{r0, r1, r2, lr}
-	mrc	15, 0, r3, cr1, cr0, 1
-	bic	r3, r3, #2
-	mcr	15, 0, r3, cr1, cr0, 1
-	pop	{r1, r2, r3, pc}
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/clock.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/clock.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/clock.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/clock.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,303 +0,0 @@
-/*
- * Copyright (C) 2009 Samsung Electronics
- * Minkyu Kang <mk7.kang@samsung.com>
- * Heungjun Kim <riverful.kim@samsung.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/clk.h>
-
-#define CLK_M	0
-#define CLK_D	1
-#define CLK_P	2
-
-#ifndef CONFIG_SYS_CLK_FREQ_C100
-#define CONFIG_SYS_CLK_FREQ_C100	12000000
-#endif
-#ifndef CONFIG_SYS_CLK_FREQ_C110
-#define CONFIG_SYS_CLK_FREQ_C110	24000000
-#endif
-
-unsigned long (*get_pclk)(void);
-unsigned long (*get_arm_clk)(void);
-unsigned long (*get_pll_clk)(int);
-
-/* s5pc110: return pll clock frequency */
-static unsigned long s5pc100_get_pll_clk(int pllreg)
-{
-	struct s5pc100_clock *clk = (struct s5pc100_clock *)S5PC1XX_CLOCK_BASE;
-	unsigned long r, m, p, s, mask, fout;
-	unsigned int freq;
-
-	switch (pllreg) {
-	case APLL:
-		r = readl(&clk->apll_con);
-		break;
-	case MPLL:
-		r = readl(&clk->mpll_con);
-		break;
-	case EPLL:
-		r = readl(&clk->epll_con);
-		break;
-	case HPLL:
-		r = readl(&clk->hpll_con);
-		break;
-	default:
-		printf("Unsupported PLL (%d)\n", pllreg);
-		return 0;
-	}
-
-	/*
-	 * APLL_CON: MIDV [25:16]
-	 * MPLL_CON: MIDV [23:16]
-	 * EPLL_CON: MIDV [23:16]
-	 * HPLL_CON: MIDV [23:16]
-	 */
-	if (pllreg == APLL)
-		mask = 0x3ff;
-	else
-		mask = 0x0ff;
-
-	m = (r >> 16) & mask;
-
-	/* PDIV [13:8] */
-	p = (r >> 8) & 0x3f;
-	/* SDIV [2:0] */
-	s = r & 0x7;
-
-	/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
-	freq = CONFIG_SYS_CLK_FREQ_C100;
-	fout = m * (freq / (p * (1 << s)));
-
-	return fout;
-}
-
-/* s5pc100: return pll clock frequency */
-static unsigned long s5pc110_get_pll_clk(int pllreg)
-{
-	struct s5pc110_clock *clk = (struct s5pc110_clock *)S5PC1XX_CLOCK_BASE;
-	unsigned long r, m, p, s, mask, fout;
-	unsigned int freq;
-
-	switch (pllreg) {
-	case APLL:
-		r = readl(&clk->apll_con);
-		break;
-	case MPLL:
-		r = readl(&clk->mpll_con);
-		break;
-	case EPLL:
-		r = readl(&clk->epll_con);
-		break;
-	case VPLL:
-		r = readl(&clk->vpll_con);
-		break;
-	default:
-		printf("Unsupported PLL (%d)\n", pllreg);
-		return 0;
-	}
-
-	/*
-	 * APLL_CON: MIDV [25:16]
-	 * MPLL_CON: MIDV [25:16]
-	 * EPLL_CON: MIDV [24:16]
-	 * VPLL_CON: MIDV [24:16]
-	 */
-	if (pllreg == APLL || pllreg == MPLL)
-		mask = 0x3ff;
-	else
-		mask = 0x1ff;
-
-	m = (r >> 16) & mask;
-
-	/* PDIV [13:8] */
-	p = (r >> 8) & 0x3f;
-	/* SDIV [2:0] */
-	s = r & 0x7;
-
-	freq = CONFIG_SYS_CLK_FREQ_C110;
-	if (pllreg == APLL) {
-		if (s < 1)
-			s = 1;
-		/* FOUT = MDIV * FIN / (PDIV * 2^(SDIV - 1)) */
-		fout = m * (freq / (p * (1 << (s - 1))));
-	} else
-		/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
-		fout = m * (freq / (p * (1 << s)));
-
-	return fout;
-}
-
-/* s5pc110: return ARM clock frequency */
-static unsigned long s5pc110_get_arm_clk(void)
-{
-	struct s5pc110_clock *clk = (struct s5pc110_clock *)S5PC1XX_CLOCK_BASE;
-	unsigned long div;
-	unsigned long dout_apll, armclk;
-	unsigned int apll_ratio;
-
-	div = readl(&clk->div0);
-
-	/* APLL_RATIO: [2:0] */
-	apll_ratio = div & 0x7;
-
-	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
-	armclk = dout_apll;
-
-	return armclk;
-}
-
-/* s5pc100: return ARM clock frequency */
-static unsigned long s5pc100_get_arm_clk(void)
-{
-	struct s5pc100_clock *clk = (struct s5pc100_clock *)S5PC1XX_CLOCK_BASE;
-	unsigned long div;
-	unsigned long dout_apll, armclk;
-	unsigned int apll_ratio, arm_ratio;
-
-	div = readl(&clk->div0);
-
-	/* ARM_RATIO: [6:4] */
-	arm_ratio = (div >> 4) & 0x7;
-	/* APLL_RATIO: [0] */
-	apll_ratio = div & 0x1;
-
-	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
-	armclk = dout_apll / (arm_ratio + 1);
-
-	return armclk;
-}
-
-/* s5pc100: return HCLKD0 frequency */
-static unsigned long get_hclk(void)
-{
-	struct s5pc100_clock *clk = (struct s5pc100_clock *)S5PC1XX_CLOCK_BASE;
-	unsigned long hclkd0;
-	uint div, d0_bus_ratio;
-
-	div = readl(&clk->div0);
-	/* D0_BUS_RATIO: [10:8] */
-	d0_bus_ratio = (div >> 8) & 0x7;
-
-	hclkd0 = get_arm_clk() / (d0_bus_ratio + 1);
-
-	return hclkd0;
-}
-
-/* s5pc100: return PCLKD1 frequency */
-static unsigned long get_pclkd1(void)
-{
-	struct s5pc100_clock *clk = (struct s5pc100_clock *)S5PC1XX_CLOCK_BASE;
-	unsigned long d1_bus, pclkd1;
-	uint div, d1_bus_ratio, pclkd1_ratio;
-
-	div = readl(&clk->div0);
-	/* D1_BUS_RATIO: [14:12] */
-	d1_bus_ratio = (div >> 12) & 0x7;
-	/* PCLKD1_RATIO: [18:16] */
-	pclkd1_ratio = (div >> 16) & 0x7;
-
-	/* ASYNC Mode */
-	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
-	pclkd1 = d1_bus / (pclkd1_ratio + 1);
-
-	return pclkd1;
-}
-
-/* s5pc110: return HCLKs frequency */
-static unsigned long get_hclk_sys(int dom)
-{
-	struct s5pc110_clock *clk = (struct s5pc110_clock *)S5PC1XX_CLOCK_BASE;
-	unsigned long hclk;
-	unsigned int div;
-	unsigned int offset;
-	unsigned int hclk_sys_ratio;
-
-	if (dom == CLK_M)
-		return get_hclk();
-
-	div = readl(&clk->div0);
-
-	/*
-	 * HCLK_MSYS_RATIO: [10:8]
-	 * HCLK_DSYS_RATIO: [19:16]
-	 * HCLK_PSYS_RATIO: [27:24]
-	 */
-	offset = 8 + (dom << 0x3);
-
-	hclk_sys_ratio = (div >> offset) & 0xf;
-
-	hclk = get_pll_clk(MPLL) / (hclk_sys_ratio + 1);
-
-	return hclk;
-}
-
-/* s5pc110: return PCLKs frequency */
-static unsigned long get_pclk_sys(int dom)
-{
-	struct s5pc110_clock *clk = (struct s5pc110_clock *)S5PC1XX_CLOCK_BASE;
-	unsigned long pclk;
-	unsigned int div;
-	unsigned int offset;
-	unsigned int pclk_sys_ratio;
-
-	div = readl(&clk->div0);
-
-	/*
-	 * PCLK_MSYS_RATIO: [14:12]
-	 * PCLK_DSYS_RATIO: [22:20]
-	 * PCLK_PSYS_RATIO: [30:28]
-	 */
-	offset = 12 + (dom << 0x3);
-
-	pclk_sys_ratio = (div >> offset) & 0x7;
-
-	pclk = get_hclk_sys(dom) / (pclk_sys_ratio + 1);
-
-	return pclk;
-}
-
-/* s5pc110: return peripheral clock frequency */
-static unsigned long s5pc110_get_pclk(void)
-{
-	return get_pclk_sys(CLK_P);
-}
-
-/* s5pc100: return peripheral clock frequency */
-static unsigned long s5pc100_get_pclk(void)
-{
-	return get_pclkd1();
-}
-
-void s5pc1xx_clock_init(void)
-{
-	if (cpu_is_s5pc110()) {
-		get_pll_clk = s5pc110_get_pll_clk;
-		get_arm_clk = s5pc110_get_arm_clk;
-		get_pclk = s5pc110_get_pclk;
-	} else {
-		get_pll_clk = s5pc100_get_pll_clk;
-		get_arm_clk = s5pc100_get_arm_clk;
-		get_pclk = s5pc100_get_pclk;
-	}
-}
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/cpu_info.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/cpu_info.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/cpu_info.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/cpu_info.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2009 Samsung Electronics
- * Minkyu Kang <mk7.kang@samsung.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/clk.h>
-
-/* Default is s5pc100 */
-unsigned int s5pc1xx_cpu_id = 0xC100;
-
-#ifdef CONFIG_ARCH_CPU_INIT
-int arch_cpu_init(void)
-{
-	s5pc1xx_cpu_id = readl(S5PC1XX_PRO_ID);
-	s5pc1xx_cpu_id = 0xC000 | ((s5pc1xx_cpu_id & 0x00FFF000) >> 12);
-
-	s5pc1xx_clock_init();
-
-	return 0;
-}
-#endif
-
-u32 get_device_type(void)
-{
-	return s5pc1xx_cpu_id;
-}
-
-#ifdef CONFIG_DISPLAY_CPUINFO
-int print_cpuinfo(void)
-{
-	char buf[32];
-
-	printf("CPU:\tS5P%X@%sMHz\n",
-			s5pc1xx_cpu_id, strmhz(buf, get_arm_clk()));
-
-	return 0;
-}
-#endif
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/reset.S u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/reset.S
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/reset.S	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/reset.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,47 +0,0 @@
-/*
- * Copyright (c) 2009 Samsung Electronics.
- * Minkyu Kang <mk7.kang@samsung.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <asm/arch/cpu.h>
-
-#define S5PC100_SWRESET			0xE0200000
-#define S5PC110_SWRESET			0xE0102000
-
-.globl reset_cpu
-reset_cpu:
-	ldr	r1, =S5PC1XX_PRO_ID
-	ldr	r2, [r1]
-	ldr	r4, =0x00010000
-	and	r4, r2, r4
-	cmp	r4, #0
-	bne	110f
-	/* S5PC100 */
-	ldr	r1, =S5PC100_SWRESET
-	ldr	r2, =0xC100
-	b	200f
-110:	/* S5PC110 */
-	ldr	r1, =S5PC110_SWRESET
-	mov	r2, #1
-200:
-	str	r2, [r1]
-_loop_forever:
-	b	_loop_forever
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/sromc.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/sromc.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/sromc.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/sromc.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2010 Samsung Electronics
- * Naveen Krishna Ch <ch.naveen@samsung.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/smc.h>
-
-/*
- * s5pc1xx_config_sromc() - select the proper SROMC Bank and configure the
- * 		    band width control and bank control registers
- * srom_bank	- SROM Bank 0 to 5
- * smc_bw_conf  - SMC Band witdh reg configuration value
- * smc_bc_conf  - SMC Bank Control reg configuration value
- */
-void s5pc1xx_config_sromc(u32 srom_bank, u32 smc_bw_conf, u32 smc_bc_conf)
-{
-	u32 tmp;
-	struct s5pc1xx_smc *srom;
-
-	if (cpu_is_s5pc100())
-		srom = (struct s5pc1xx_smc *)S5PC100_SROMC_BASE;
-	else
-		srom = (struct s5pc1xx_smc *)S5PC110_SROMC_BASE;
-
-	/* Configure SMC_BW register to handle proper SROMC bank */
-	tmp = srom->bw;
-	tmp &= ~(0xF << (srom_bank * 4));
-	tmp |= smc_bw_conf;
-	srom->bw = tmp;
-
-	/* Configure SMC_BC register */
-	srom->bc[srom_bank] = smc_bc_conf;
-}
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/timer.c u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/timer.c
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/s5pc1xx/timer.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/s5pc1xx/timer.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,195 +0,0 @@
-/*
- * Copyright (C) 2009 Samsung Electronics
- * Heungjun Kim <riverful.kim@samsung.com>
- * Inki Dae <inki.dae@samsung.com>
- * Minkyu Kang <mk7.kang@samsung.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/pwm.h>
-#include <asm/arch/clk.h>
-
-#define PRESCALER_1		(16 - 1)	/* prescaler of timer 2, 3, 4 */
-#define MUX_DIV_2		1		/* 1/2 period */
-#define MUX_DIV_4		2		/* 1/4 period */
-#define MUX_DIV_8		3		/* 1/8 period */
-#define MUX_DIV_16		4		/* 1/16 period */
-#define MUX4_DIV_SHIFT		16
-
-#define TCON_TIMER4_SHIFT	20
-
-static unsigned long count_value;
-
-/* Internal tick units */
-static unsigned long long timestamp;	/* Monotonic incrementing timer */
-static unsigned long lastdec;		/* Last decremneter snapshot */
-
-/* macro to read the 16 bit timer */
-static inline struct s5pc1xx_timer *s5pc1xx_get_base_timer(void)
-{
-	if (cpu_is_s5pc110())
-		return (struct s5pc1xx_timer *)S5PC110_TIMER_BASE;
-	else
-		return (struct s5pc1xx_timer *)S5PC100_TIMER_BASE;
-}
-
-int timer_init(void)
-{
-	struct s5pc1xx_timer *const timer = s5pc1xx_get_base_timer();
-	u32 val;
-
-	/*
-	 * @ PWM Timer 4
-	 * Timer Freq(HZ) =
-	 *	PCLK / { (prescaler_value + 1) * (divider_value) }
-	 */
-
-	/* set prescaler : 16 */
-	/* set divider : 2 */
-	writel((PRESCALER_1 & 0xff) << 8, &timer->tcfg0);
-	writel((MUX_DIV_2 & 0xf) << MUX4_DIV_SHIFT, &timer->tcfg1);
-
-	if (count_value == 0) {
-		/* reset initial value */
-		/* count_value = 2085937.5(HZ) (per 1 sec)*/
-		count_value = get_pclk() / ((PRESCALER_1 + 1) *
-				(MUX_DIV_2 + 1));
-
-		/* count_value / 100 = 20859.375(HZ) (per 10 msec) */
-		count_value = count_value / 100;
-	}
-
-	/* set count value */
-	writel(count_value, &timer->tcntb4);
-	lastdec = count_value;
-
-	val = (readl(&timer->tcon) & ~(0x07 << TCON_TIMER4_SHIFT)) |
-		S5PC1XX_TCON4_AUTO_RELOAD;
-
-	/* auto reload & manual update */
-	writel(val | S5PC1XX_TCON4_UPDATE, &timer->tcon);
-
-	/* start PWM timer 4 */
-	writel(val | S5PC1XX_TCON4_START, &timer->tcon);
-
-	timestamp = 0;
-
-	return 0;
-}
-
-/*
- * timer without interrupts
- */
-void reset_timer(void)
-{
-	reset_timer_masked();
-}
-
-unsigned long get_timer(unsigned long base)
-{
-	return get_timer_masked() - base;
-}
-
-void set_timer(unsigned long t)
-{
-	timestamp = t;
-}
-
-/* delay x useconds */
-void __udelay(unsigned long usec)
-{
-	unsigned long tmo, tmp;
-
-	if (usec >= 1000) {
-		/*
-		 * if "big" number, spread normalization
-		 * to seconds
-		 * 1. start to normalize for usec to ticks per sec
-		 * 2. find number of "ticks" to wait to achieve target
-		 * 3. finish normalize.
-		 */
-		tmo = usec / 1000;
-		tmo *= (CONFIG_SYS_HZ * count_value / 10);
-		tmo /= 1000;
-	} else {
-		/* else small number, don't kill it prior to HZ multiply */
-		tmo = usec * CONFIG_SYS_HZ * count_value / 10;
-		tmo /= (1000 * 1000);
-	}
-
-	/* get current timestamp */
-	tmp = get_timer(0);
-
-	/* if setting this fordward will roll time stamp */
-	/* reset "advancing" timestamp to 0, set lastdec value */
-	/* else, set advancing stamp wake up time */
-	if ((tmo + tmp + 1) < tmp)
-		reset_timer_masked();
-	else
-		tmo += tmp;
-
-	/* loop till event */
-	while (get_timer_masked() < tmo)
-		;	/* nop */
-}
-
-void reset_timer_masked(void)
-{
-	struct s5pc1xx_timer *const timer = s5pc1xx_get_base_timer();
-
-	/* reset time */
-	lastdec = readl(&timer->tcnto4);
-	timestamp = 0;
-}
-
-unsigned long get_timer_masked(void)
-{
-	struct s5pc1xx_timer *const timer = s5pc1xx_get_base_timer();
-	unsigned long now = readl(&timer->tcnto4);
-
-	if (lastdec >= now)
-		timestamp += lastdec - now;
-	else
-		timestamp += lastdec + count_value - now;
-
-	lastdec = now;
-
-	return timestamp;
-}
-
-/*
- * This function is derived from PowerPC code (read timebase as long long).
- * On ARM it just returns the timer value.
- */
-unsigned long long get_ticks(void)
-{
-	return get_timer(0);
-}
-
-/*
- * This function is derived from PowerPC code (timebase clock frequency).
- * On ARM it returns the number of timer ticks per second.
- */
-unsigned long get_tbclk(void)
-{
-	return CONFIG_SYS_HZ;
-}
diff -rupN u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/start.S u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/start.S
--- u-boot-2010.06.orig/arch/arm/cpu/arm_cortexa8/start.S	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/cpu/arm_cortexa8/start.S	2011-06-10 17:54:31.774688002 -0700
@@ -164,7 +164,7 @@ stack_setup:
 	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ + CONFIG_STACKSIZE_FIQ)
 #endif
 	sub	sp, r0, #12		@ leave 3 words for abort-stack
-	bic	sp, sp, #7		@ 8-byte alignment for ABI compliance
+	and	sp, sp, #~7		@ 8 byte alinged for (ldr/str)d
 
 	/* Clear BSS (if any). Is below tx (watch load addr - need space) */
 clear_bss:
@@ -414,3 +414,94 @@ fiq:
 	bl	do_fiq
 
 #endif
+
+/*
+ *	v7_flush_dcache_all()
+ *
+ *	Flush the whole D-cache.
+ *
+ *	Corrupted registers: r0-r5, r7, r9-r11
+ *
+ *	- mm	- mm_struct describing address space
+ */
+	.align 5
+.global v7_flush_dcache_all
+v7_flush_dcache_all:
+	stmfd	r13!, {r0 - r5, r7, r9 - r12, r14}
+
+	mov	r7, r0				@ take a backup of device type
+	cmp	r0, #0x3			@ check if the device type is
+						@ GP
+	moveq r12, #0x1				@ set up to invalide L2
+#ifndef CONFIG_OMAP3_ALICO
+	@ On OMAP3_LOGIC boards, u-boot is launched from LoLo
+	@ which does the SMI call to invalidate the cache.  If done
+	@ twice, the OMAP35x chip resets....
+smi:	.word 0x01600070			@ Call SMI monitor (smieq)
+	cmp	r7, #0x3			@ compare again in case its
+						@ lost
+	beq	finished_inval			@ if GP device, inval done
+						@ above
+#endif
+
+	mrc	p15, 1, r0, c0, c0, 1		@ read clidr
+	ands	r3, r0, #0x7000000		@ extract loc from clidr
+	mov	r3, r3, lsr #23			@ left align loc bit field
+	beq	finished_inval			@ if loc is 0, then no need to
+						@ clean
+	mov	r10, #0				@ start clean at cache level 0
+inval_loop1:
+	add	r2, r10, r10, lsr #1		@ work out 3x current cache
+						@ level
+	mov	r1, r0, lsr r2			@ extract cache type bits from
+						@ clidr
+	and	r1, r1, #7			@ mask of the bits for current
+						@ cache only
+	cmp	r1, #2				@ see what cache we have at
+						@ this level
+	blt	skip_inval			@ skip if no cache, or just
+						@ i-cache
+	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level
+						@ in cssr
+	mov	r2, #0				@ operand for mcr SBZ
+	mcr	p15, 0, r2, c7, c5, 4		@ flush prefetch buffer to
+						@ sych the new cssr&csidr,
+						@ with armv7 this is 'isb',
+						@ but we compile with armv5
+	mrc	p15, 1, r1, c0, c0, 0		@ read the new csidr
+	and	r2, r1, #7			@ extract the length of the
+						@ cache lines
+	add	r2, r2, #4			@ add 4 (line length offset)
+	ldr	r4, =0x3ff
+	ands	r4, r4, r1, lsr #3		@ find maximum number on the
+						@ way size
+	clz	r5, r4				@ find bit position of way
+						@ size increment
+	ldr	r7, =0x7fff
+	ands	r7, r7, r1, lsr #13		@ extract max number of the
+						@ index size
+inval_loop2:
+	mov	r9, r4				@ create working copy of max
+						@ way size
+inval_loop3:
+	orr	r11, r10, r9, lsl r5		@ factor way and cache number
+						@ into r11
+	orr	r11, r11, r7, lsl r2		@ factor index number into r11
+	mcr	p15, 0, r11, c7, c6, 2		@ invalidate by set/way
+	subs	r9, r9, #1			@ decrement the way
+	bge	inval_loop3
+	subs	r7, r7, #1			@ decrement the index
+	bge	inval_loop2
+skip_inval:
+	add	r10, r10, #2			@ increment cache number
+	cmp	r3, r10
+	bgt	inval_loop1
+finished_inval:
+	mov	r10, #0				@ swith back to cache level 0
+	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level
+						@ in cssr
+	mcr	p15, 0, r10, c7, c5, 4		@ flush prefetch buffer,
+						@ with armv7 this is 'isb',
+						@ but we compile with armv5
+
+	ldmfd	r13!, {r0 - r5, r7, r9 - r12, pc}
diff -rupN u-boot-2010.06.orig/arch/arm/include/asm/arch-omap3/omap3.h u-boot-2010.06.new/arch/arm/include/asm/arch-omap3/omap3.h
--- u-boot-2010.06.orig/arch/arm/include/asm/arch-omap3/omap3.h	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/include/asm/arch-omap3/omap3.h	2010-07-26 17:36:50.000000000 -0700
@@ -144,6 +144,7 @@ struct gpio {
 #define SRAM_OFFSET2			0x0000F800
 #define SRAM_VECT_CODE			(SRAM_OFFSET0 | SRAM_OFFSET1 | \
 					 SRAM_OFFSET2)
+#define SRAM_BASE (SRAM_OFFSET0|SRAM_OFFSET1)
 
 #define LOW_LEVEL_SRAM_STACK		0x4020FFFC
 
@@ -180,6 +181,8 @@ struct gpio {
 
 #define CPU_3XX_ID_SHIFT	28
 
+#define TYPE_READTYPE           0x20000000  // Readtype, 1==sync in gpmc
+
 #define WIDTH_8BIT		0x0000
 #define WIDTH_16BIT		0x1000	/* bit pos for 16 bit in gpmc */
 
diff -rupN u-boot-2010.06.orig/arch/arm/lib/board.c u-boot-2010.06.new/arch/arm/lib/board.c
--- u-boot-2010.06.orig/arch/arm/lib/board.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/arch/arm/lib/board.c	2011-06-10 12:41:48.858688002 -0700
@@ -337,6 +337,11 @@ void start_armboot (void)
 	puts ("NAND:  ");
 	nand_init();		/* go init the NAND */
 #endif
+#ifdef ALICO_CODE
+#if defined(CONFIG_OMAP3_ALICO)
+	omap_nand_switch_ecc(1);	/* switch to HW ECC mode */
+#endif
+#endif
 
 #if defined(CONFIG_CMD_ONENAND)
 	onenand_init();
diff -rupN u-boot-2010.06.orig/board/logicpd/alico/Makefile u-boot-2010.06.new/board/logicpd/alico/Makefile
--- u-boot-2010.06.orig/board/logicpd/alico/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/alico/Makefile	2011-06-10 18:18:11.790688001 -0700
@@ -0,0 +1,49 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= alico.o alico-data.o alico-gpio.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -rupN u-boot-2010.06.orig/board/logicpd/alico/alico-data.c u-boot-2010.06.new/board/logicpd/alico/alico-data.c
--- u-boot-2010.06.orig/board/logicpd/alico/alico-data.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/alico/alico-data.c	2011-06-10 18:21:06.594688002 -0700
@@ -0,0 +1,785 @@
+/*
+ * (C) Copyright 2008
+ * Logic Produc Development, <www.logicpd.com>
+ * Peter Barada <peter.barada@logicpd.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/arch/cpu.h>
+#include <asm/io.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/clocks.h>
+#include <asm/arch/mem.h>
+#include <i2c.h>
+#include <asm/mach-types.h>
+#include "product_id.h"
+#include "alico-gpio.h"
+
+// GPIO i2c code to access at88 chip
+
+enum {
+	RX_MODE_FIRST_BYTE,
+	RX_MODE_MIDDLE_BYTE,
+	RX_MODE_NEXT_TO_LAST_BYTE,
+	RX_MODE_LAST_BYTE,
+	RX_MODE_ONE_BYTE
+} I2C_RX_MODE;
+
+typedef enum {
+	GPIO_I2C_SDATA,
+	GPIO_I2C_SCLK,
+} GPIO_I2C_PIN;
+
+static enum {
+	GPIO_I2C_UNINIT,
+	GPIO_I2C_STOPPED,
+	GPIO_I2C_STARTED,
+} gpio_i2c_bus_state;
+
+typedef enum {
+	GPIO_I2C_INPUT,
+	GPIO_I2C_OUTPUT,
+} GPIO_I2C_DIRECTION;
+
+static int gpio_i2c_clock_high_width, gpio_i2c_clock_low_width;
+static int gpio_i2c_coarse_delay;
+
+#define DEBUG_PRODUCTION_DATA 0
+#define DEBUG_PRODUCTION_DATA_BUF 0
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ * The commented string gives the final mux configuration for that pin
+ */
+
+/* Put SCLK/SDA pins connected to the product ID into GPIO mode */
+static void gpio_i2c_config_pins(void)
+{
+	MUX_VAL(CP(I2C3_SCL),       (IEN  | PTU | EN  | M4)); /*I2C3_SCL*/
+	MUX_VAL(CP(I2C3_SDA),       (IEN  | PTU | EN  | M4)); /*I2C3_SDA*/
+}
+
+/* Restore SCLK/SDA pins connected to the product ID back to I2C mode */
+
+static void gpio_i2c_restore_pins(void)
+{
+	MUX_VAL(CP(I2C3_SCL),       (IEN  | PTU | EN  | M0)); /*I2C3_SCL*/
+	MUX_VAL(CP(I2C3_SDA),       (IEN  | PTU | EN  | M0)); /*I2C3_SDA*/
+}
+
+#define GPIO_I2C_GPIO_SCLK  184
+#define GPIO_I2C_GPIO_SDATA 185
+
+static void gpio_i2c_config_pin(GPIO_I2C_PIN pin, GPIO_I2C_DIRECTION dir)
+{
+	if (dir == GPIO_I2C_INPUT) {
+		if (pin == GPIO_I2C_SCLK)
+			pin_init_gpio(GPIO_I2C_GPIO_SCLK, 1);
+		else
+			pin_init_gpio(GPIO_I2C_GPIO_SDATA, 1);
+	} else if (dir == GPIO_I2C_OUTPUT) {
+		if (pin == GPIO_I2C_SCLK)
+			pin_init_gpio(GPIO_I2C_GPIO_SCLK, 0);
+		else
+			pin_init_gpio(GPIO_I2C_GPIO_SDATA, 0);
+	}
+}
+
+static int gpio_i2c_read_pin(GPIO_I2C_PIN pin)
+{
+	if (pin == GPIO_I2C_SCLK)
+		return pin_get_gpio_input(GPIO_I2C_GPIO_SCLK);
+	else
+		return pin_get_gpio_input(GPIO_I2C_GPIO_SDATA);
+	return 0;
+}
+
+static void gpio_i2c_set_pin_level(GPIO_I2C_PIN pin, int level)
+{
+	uint8_t pin_level;
+
+	if (pin == GPIO_I2C_SCLK) {
+		pin_level = pin_get_gpio_input(GPIO_I2C_GPIO_SCLK);
+		if (((level == 1) && (pin_level == 0)) ||
+		    ((level == 0) && (pin_level == 1)))
+			pin_set_gpio_dataout(GPIO_I2C_GPIO_SCLK, level);
+	} else if (pin == GPIO_I2C_SDATA) {
+		if (level == 0) {
+			gpio_i2c_config_pin(pin, GPIO_I2C_OUTPUT);
+			pin_set_gpio_dataout(GPIO_I2C_GPIO_SDATA, 0);
+		} else {
+			gpio_i2c_config_pin(pin, GPIO_I2C_INPUT);
+		}
+	}
+}
+
+
+static void gpio_i2c_init(int bps)
+{
+	gpio_i2c_bus_state = GPIO_I2C_UNINIT;
+
+	// Config SCLK, SDATA pins
+	gpio_i2c_config_pin(GPIO_I2C_SCLK, GPIO_I2C_OUTPUT);
+	gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+
+	gpio_i2c_config_pin(GPIO_I2C_SDATA, GPIO_I2C_INPUT);
+
+	gpio_i2c_config_pins();
+
+	// Assume 1:1 clock duty cycle
+	gpio_i2c_clock_high_width = gpio_i2c_clock_low_width
+	  = 1000000 / bps / 2;
+
+	gpio_i2c_coarse_delay = gpio_i2c_clock_high_width;
+}
+
+static int gpio_i2c_busy(void)
+{
+	return (gpio_i2c_bus_state == GPIO_I2C_STARTED);
+}
+
+static void gpio_i2c_tx_stop(void)
+{
+	if (gpio_i2c_bus_state == GPIO_I2C_STARTED) {
+		udelay(gpio_i2c_coarse_delay);
+
+		// Pull SDATA low
+		gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 0);
+		udelay(gpio_i2c_coarse_delay);
+
+		// Push SCLK high
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+		udelay(gpio_i2c_coarse_delay);
+
+		// Now drive SDATA high - thats a STOP.
+		gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 1);
+		udelay(gpio_i2c_coarse_delay);
+		gpio_i2c_bus_state = GPIO_I2C_STOPPED;
+	}
+}
+
+static void gpio_i2c_tx_start(void)
+{
+	if (gpio_i2c_bus_state == GPIO_I2C_UNINIT
+	    || gpio_i2c_bus_state == GPIO_I2C_STOPPED) {
+		udelay(gpio_i2c_coarse_delay);
+		gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 1);
+		udelay(gpio_i2c_coarse_delay);
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+		udelay(gpio_i2c_coarse_delay);
+		gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 0);
+		udelay(gpio_i2c_coarse_delay);
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 0);
+		udelay(gpio_i2c_coarse_delay);
+		gpio_i2c_bus_state = GPIO_I2C_STARTED;
+	}
+}
+
+// Return !0 if NACK
+static int gpio_i2c_tx_byte(uint8_t data)
+{
+	uint8_t clock, tx_bit_mask=0x80, nack;
+
+	if (gpio_i2c_bus_state != GPIO_I2C_STARTED)
+		printf("%s: Unexpected I2C bus state!\n", __FUNCTION__);
+
+	udelay(gpio_i2c_coarse_delay);
+
+	for (clock=0; clock <= 7; ++clock) {
+		if (data & tx_bit_mask)
+			gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 1);
+		else
+			gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 0);
+		udelay(gpio_i2c_clock_low_width);
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+		udelay(gpio_i2c_clock_high_width);
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 0);
+		tx_bit_mask >>= 1;
+	}
+	gpio_i2c_config_pin(GPIO_I2C_SDATA, GPIO_I2C_INPUT);
+	udelay(gpio_i2c_clock_low_width);
+	gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+	udelay(gpio_i2c_clock_high_width);
+	nack = gpio_i2c_read_pin(GPIO_I2C_SDATA);
+	gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 0);
+	return (nack != 0);
+}
+
+static int gpio_i2c_rx_byte(uint8_t *data, int rx_mode)
+{
+	uint8_t clock, data_bit;
+
+	*data = 0;
+
+	gpio_i2c_config_pin(GPIO_I2C_SDATA, GPIO_I2C_INPUT);
+
+	udelay(gpio_i2c_coarse_delay);
+
+	for (clock=0; clock<=8; ++clock) {
+		if (clock < 8) {
+			gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+			udelay(gpio_i2c_clock_high_width);
+			data_bit = gpio_i2c_read_pin(GPIO_I2C_SDATA);
+			gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 0);
+			*data = (*data << 1) | data_bit;
+		} else {
+			if ((rx_mode == RX_MODE_LAST_BYTE) || (rx_mode == RX_MODE_ONE_BYTE))
+				gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 1);
+			else
+				gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 0);
+
+			gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+			udelay(gpio_i2c_clock_high_width);
+			gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 0);
+		}
+		udelay(gpio_i2c_clock_low_width);
+	}
+
+	return 0;
+}
+
+
+static int send_packet(uint8_t *data, int len, uint8_t *rxbuf, int rxlen)
+{
+	int timeout = 1000;
+	int retry;
+	int rx_mode;
+	int tick, err, idx;
+
+	if (DEBUG_PRODUCTION_DATA) {
+		char buf[3 * len + 2];
+		int i, offset;
+		for (offset = 0, i=0; i<len; ++i) {
+			if (!i)
+				offset = sprintf(buf, "%02x", data[i]);
+			else
+				offset += sprintf(&buf[offset], " %02x", data[i]);
+		}
+		printf("%s: %s\n", __FUNCTION__, buf);
+	}
+
+	// Wait for bus
+	while (gpio_i2c_busy() && timeout--)
+		udelay(100);
+
+	if (!timeout)
+		printf("%s:%d i2c_busy never return zero!\n", __FUNCTION__, __LINE__);
+
+	retry = 0;
+	do {
+		tick = 0;
+		do {
+			gpio_i2c_tx_stop();
+			gpio_i2c_tx_start();
+
+			// send cmd
+			err = gpio_i2c_tx_byte(data[0]);
+			tick++;
+		} while (err && tick < 100);
+
+		if (tick > 3)
+			printf("I2C ACK polling tick %d!\n", tick);
+
+		for (idx = 1; idx<len; ++idx) {
+			err = gpio_i2c_tx_byte(data[idx]);
+			if (err) {
+				printf("%s:%d NACK idx %d\n", __FUNCTION__, __LINE__, idx);
+			}
+		}
+	} while (err && (retry++ < 5));
+
+	if (err)
+		return err;
+
+	// Are we expecting a response?
+	if (rxbuf) {
+		for (idx = 0; idx < rxlen; ++idx) {
+			if (rxlen == 1)
+				rx_mode = RX_MODE_ONE_BYTE;
+			else if (idx == (rxlen - 1))
+				rx_mode = RX_MODE_LAST_BYTE;
+			else if (idx == (rxlen - 2))
+				rx_mode = RX_MODE_NEXT_TO_LAST_BYTE;
+			else if (idx == 0)
+				rx_mode = RX_MODE_FIRST_BYTE;
+			else
+				rx_mode = RX_MODE_MIDDLE_BYTE;
+
+			err = gpio_i2c_rx_byte(&rxbuf[idx], rx_mode);
+			if (DEBUG_PRODUCTION_DATA) {
+				if (err)
+					printf("%s:%d err idx %d\n", __FUNCTION__, __LINE__, idx);
+			}
+		}
+	}
+
+	gpio_i2c_tx_stop();
+	return err;
+}
+
+/*
+ * Identify the device
+ */
+struct device_param {
+	char *name;
+	unsigned char reset[8];	// ATR for part
+	unsigned int zones;		// number of zones
+	unsigned int zonesize;	// bytes per zone
+};
+
+static const struct device_param answers[] = {
+
+  {
+	.name = "AT88SC0104C",
+	.reset = {0x3B, 0xB2, 0x11, 0x00, 0x10, 0x80, 0x00, 0x01},
+	.zones = 4,
+	.zonesize = 32
+  },
+  {
+	.name = "AT88SC0204C",
+	.reset = {0x3B, 0xB2, 0x11, 0x00, 0x10, 0x80, 0x00, 0x02},
+	.zones = 4,
+	.zonesize = 64
+  },
+  {
+	.name = "AT88SC0404C",
+	.reset = {0x3B, 0xB2, 0x11, 0x00, 0x10, 0x80, 0x00, 0x04},
+	.zones = 4,
+	.zonesize = 128
+  },
+  {
+	.name = "AT88SC0808C",
+	.reset = {0x3B, 0xB2, 0x11, 0x00, 0x10, 0x80, 0x00, 0x08},
+	.zones = 8,
+	.zonesize = 128
+  },
+  {
+	.name = "AT88SC1616C",
+	.reset = {0x3B, 0xB2, 0x11, 0x00, 0x10, 0x80, 0x00, 0x16},
+	.zones = 16,
+	.zonesize = 128
+  },
+  {
+	.name = "AT88SC3216C",
+	.reset = {0x3B, 0xB3, 0x11, 0x00, 0x00, 0x00, 0x00, 0x32},
+	.zones = 16,
+	.zonesize = 256
+  },
+  {
+	.name = "AT88SC6416C",
+	.reset = {0x3B, 0xB3, 0x11, 0x00, 0x00, 0x00, 0x00, 0x64},
+	.zones = 16,
+	.zonesize = 512
+  },
+  {
+	.name = "AT88SC12816C",
+	.reset = {0x3B, 0xB3, 0x11, 0x00, 0x00, 0x00, 0x01, 0x28},
+	.zones = 16,
+	.zonesize = 1024
+  },
+  {
+	.name = "AT88SC25616C",
+	.reset = {0x3B, 0xB3, 0x11, 0x00, 0x00, 0x00, 0x02, 0x56},
+	.zones = 16,
+	.zonesize = 2048
+  },
+};
+
+static const struct device_param *devptr; /* pointer to ID'd device */
+
+#define CMD_SYSTEM_READ	0xB6
+
+static int
+identify_device(void)
+{
+	const struct device_param *p;
+	unsigned char cmd[] = { CMD_SYSTEM_READ, 0x00, 0x00, 0x00 };
+	unsigned char buf[8];
+	int err;
+	int i,j;
+
+	err = send_packet(cmd, sizeof(cmd), buf, sizeof(buf));
+	if (err)
+		return err;
+
+	if (DEBUG_PRODUCTION_DATA)
+		printf("%s: ident %02x %02x %02x %02x %02x %02x %02x %02x\n", __FUNCTION__,
+		       buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);
+
+	for (p=answers,i=0; i<sizeof(answers)/sizeof(answers[0]); ++i,++p) {
+		for (j=0; j<8 && (p->reset[j] == buf[j]); ++j)
+			;
+		if (j==8) {
+			devptr = p;
+
+		if (DEBUG_PRODUCTION_DATA)
+			printf("%s: device %s zones %u zonesize %u\n", __FUNCTION__,
+			       devptr->name, devptr->zones, devptr->zonesize);
+
+		return 0;
+		}
+	}
+
+	printf("%s: ID %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x unknown!\n", __FUNCTION__,
+	       buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);
+
+	return -1;
+}
+
+#define CMD_SYSTEM_WRITE    0xB4
+
+static int
+set_user_zone(int zone)
+{
+	unsigned char cmd[] = { CMD_SYSTEM_WRITE, 0x03, 0x00, 0x00 };
+
+	if (DEBUG_PRODUCTION_DATA)
+		printf("%s: zone %d\n", __FUNCTION__, zone);
+	cmd[2] = zone;
+	return send_packet(cmd, sizeof(cmd), NULL, 0);
+}
+
+#define CMD_READ_USER_ZONE  0xB2
+
+static int
+read_user_zone(unsigned int offset, unsigned char *buf, int len)
+{
+	unsigned char cmd[] = { CMD_READ_USER_ZONE, 0x00, 0x00, 0x00 };
+	int ret;
+	unsigned int startzone, endzone;
+
+	if (DEBUG_PRODUCTION_DATA)
+		printf("%s: offset %u len %d\n", __FUNCTION__, offset, len);
+
+	// abort if we're not in one zone, or past the end of the device
+	startzone = offset / devptr->zonesize;
+	endzone = (offset + (len - 1)) / devptr->zonesize;
+	if (startzone != endzone) {
+	  printf("%s: startzone %d != endzone %d (len %d, offset %d)\n", __FUNCTION__, startzone, endzone, offset, len);
+		return -1;
+	}  
+	if (endzone > devptr->zones) {
+		printf("%s: endzone %d > numzones\n", __FUNCTION__, endzone);
+		return -1;
+	}
+
+	// Set the zone
+	if (set_user_zone(startzone))
+		return -1;
+
+	cmd[2] = offset % devptr->zonesize;
+	cmd[3] = len;
+	ret = send_packet(cmd, sizeof(cmd), buf, len);
+
+	if (DEBUG_PRODUCTION_DATA_BUF) {
+		char obuf[128];
+		int i,j,offset;
+		for (i = 0, offset=0; i<len; i+=16) {
+			for (j = 0; j<16 && i+j<len; ++j)
+				if (!j)
+					offset = sprintf(obuf, "%02x", buf[i+j]);
+				else
+					offset += sprintf(&obuf[offset], " %02x", buf[i+j]);
+			printf("%s\n", obuf);
+		}
+	}
+	return ret;
+}
+
+#define XMK_STR(x)	#x
+#define MK_STR(x)	XMK_STR(x)
+int production_data_valid;
+
+struct product_id_data product_id_data;
+
+int valid_mac_address(unsigned char mac[3])
+{
+	if (mac[0] == 0xff && mac[1] == 0xff && mac[2] == 0xff)
+		return 0;
+	if (mac[0] == 0x00 && mac[1] == 0x00 && mac[2] == 0x00)
+		return 0;
+	return !0;
+}
+
+/*
+ * Extract/set an ethernet address.
+ * Which is the address in the environment, position is which MAC address
+ * in the product ID data
+ */
+void board_get_nth_enetaddr (unsigned char *enetaddr, int which, int position)
+{
+	unsigned char *mac = &product_id_data.d.zone2.mac[position][0];
+	char *s = NULL, *e;
+	int i;
+	char ethbuf[18];
+
+	// We only handle the first two interfaces (LAN/WiFi)...
+	if (which >= 2)
+		return;
+
+	if (DEBUG_PRODUCTION_DATA)
+		printf("%s: valid %d which %d %02x:%02x:%02x\n", __FUNCTION__,
+		       production_data_valid, which,
+		       mac[0], mac[1], mac[2]);
+
+	memset(enetaddr, '\0', 6);
+	if (!production_data_valid || 
+		!valid_mac_address(mac)) {
+		s = getenv("ethaddr");
+
+#ifdef CONFIG_ETHADDR
+		if (!s)
+			s = MK_STR(CONFIG_ETHADDR);
+#endif
+
+		/* If no ethaddr found in productID or environment, then punt*/
+		if (!s)
+			return;
+
+		for (i = 0; i < 6; ++i) {
+			enetaddr[i] = s ? simple_strtoul (s, &e, 16) : 0;
+			if (s)
+				s = (*e) ? e + 1 : e;
+		}
+		goto set_it;
+	}
+
+	// Use Logic's prefix
+	enetaddr[0] = 0x00;
+	enetaddr[1] = 0x08;
+	enetaddr[2] = 0xee;
+	enetaddr[3] = mac[0];
+	enetaddr[4] = mac[1];
+	enetaddr[5] = mac[2];
+
+ set_it:
+	if (which == 0) {
+		sprintf(ethbuf, "%02x:%02x:%02x:%02x:%02x:%02x", enetaddr[0], enetaddr[1], enetaddr[2], enetaddr[3], enetaddr[4], enetaddr[5]);
+		setenv("ethaddr", ethbuf);
+	} else {
+		char buf[32];
+		sprintf(ethbuf, "%02x:%02x:%02x:%02x:%02x:%02x", enetaddr[0], enetaddr[1], enetaddr[2], enetaddr[3], enetaddr[4], enetaddr[5]);
+		sprintf(buf, "eth%daddr", which);
+		setenv(buf, ethbuf);
+	}
+}
+
+static int extract_product_id_part_number(struct product_id_data *p, char *buf, int buflen)
+{
+	int size;
+
+	buf[0] = '\0';
+	if (p->d.u_zone0.pz_0r0.header_version == LOGIC_HEADER_VERSION_0) {
+		size = sizeof(p->d.u_zone0.pz_0r0.part_number);
+		if (buflen < sizeof(p->d.u_zone0.pz_0r0.part_number))
+			size = buflen;
+		strncpy(buf, p->d.u_zone0.pz_0r0.part_number, sizeof(p->d.u_zone0.pz_0r0.part_number));
+		buf[sizeof(p->d.u_zone0.pz_0r0.part_number)] = '\0';
+		return 0;
+	}
+
+	if (p->d.u_zone0.pz_0r0.header_version == LOGIC_HEADER_VERSION_1) {
+		size = sizeof(p->d.u_zone0.pz_0r1.part_number);
+		if (buflen < sizeof(p->d.u_zone0.pz_0r1.part_number))
+			size = buflen;
+		strncpy(buf, p->d.u_zone0.pz_0r1.part_number, sizeof(p->d.u_zone0.pz_0r1.part_number));
+		buf[sizeof(p->d.u_zone0.pz_0r1.part_number)] = '\0';
+		return 0;
+	}
+
+	return -1;
+}
+
+
+static int extract_header_version(struct product_id_data *p, int *header_version)
+{
+	if (p->d.u_zone0.pz_0r0.header_version == LOGIC_HEADER_VERSION_0) {
+		*header_version = p->d.u_zone0.pz_0r0.header_version;
+		return 0;
+	}
+
+	if (p->d.u_zone0.pz_0r1.header_version == LOGIC_HEADER_VERSION_1) {
+		*header_version = p->d.u_zone0.pz_0r1.header_version;
+		return 0;
+	}
+
+	*header_version = p->d.u_zone0.pz_0r0.header_version;
+	return -1;
+  
+}
+
+static int extract_serial_number(struct product_id_data *p, char *buf, int buflen)
+{
+	buf[0] = '\0';
+	if (p->d.u_zone0.pz_0r0.header_version == LOGIC_HEADER_VERSION_0) {
+		sprintf(buf, "%02d%02d%c%05d", p->d.u_zone0.pz_0r0.sn_week,
+			 p->d.u_zone0.pz_0r0.sn_year, p->d.u_zone0.pz_0r0.sn_site,
+			 p->d.u_zone0.pz_0r0.sn_cnt);
+		return 0;
+	}
+	if (p->d.u_zone0.pz_0r1.header_version == LOGIC_HEADER_VERSION_1) {
+		sprintf(buf, "%02d%02d%c%05d", p->d.u_zone0.pz_0r1.sn_week,
+			 p->d.u_zone0.pz_0r1.sn_year, p->d.u_zone0.pz_0r1.sn_site,
+			 p->d.u_zone0.pz_0r1.sn_cnt);
+		return 0;
+	}
+	return -1;
+}
+
+static void extract_model_number_revision(struct product_id_data *p, char *buf, int buflen)
+{
+	int i;
+
+	strncpy(buf, product_id_data.d.zone1.model_number, buflen);
+	buf[buflen-1] = '\0';
+	i = strlen(buf);
+	if (i && (i + 3 < buflen)) {
+		buf[i] = '-';
+		buf[i+1] = product_id_data.d.zone1.model_revision;
+		buf[i+2] = '\0';
+	}
+}
+
+/* Return positive non-zero if productID indicates there's
+ * NOR flash on the device - return is size of flash as log2 in bytes */
+int productID_has_NOR_flash(void)
+{
+	if (!production_data_valid)
+		return -1;
+
+	/* Flash exists if its size is non-zero, but 0xff is known to be
+	 * a non-programmed value */
+	if (product_id_data.d.zone2.nor0_size == 0x00
+	    || product_id_data.d.zone2.nor0_size == 0xff)
+		return 0;
+
+	return product_id_data.d.zone2.nor0_size;
+}
+
+int fetch_production_data(void)
+{
+	int err = 0;
+	int header_version;
+	int checksum;
+	int i;
+
+	// Make sure voltage is to productID chip!
+	gpio_i2c_init(50000);
+
+	/* The productID chip wants at least 5 clocks to wake it up... */
+	gpio_i2c_config_pin(GPIO_I2C_SCLK, GPIO_I2C_OUTPUT);
+	gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+	for (i=0; i<10; ++i) {
+		udelay(100);
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 0);
+		udelay(100);
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+	}
+
+	printf("Read production data: ");
+
+	if (identify_device()) {
+		printf("failed to identify device!\n");
+		err = -1;
+		goto out;
+	}
+
+	if (read_user_zone(0, (unsigned char *)&product_id_data.d.u_zone0, sizeof(product_id_data.d.u_zone0))) {
+		printf("failed!\n");
+		err = -1;
+		goto out;
+	}
+
+	// If the header doesn't match, we can't map any of the data
+	if (extract_header_version(&product_id_data, &header_version)) {
+		printf("failed - invalid header version %d!\n", header_version);
+		err = -2;
+		goto out;
+	}
+
+	if (read_user_zone(32, (unsigned char *)&product_id_data.d.zone1, sizeof(product_id_data.d.zone1))) {
+		printf("failed!\n");
+		err = -3;
+		goto out;
+	}
+
+	if (read_user_zone(64, (unsigned char *)&product_id_data.d.zone2, sizeof(product_id_data.d.zone2))) {
+		printf("failed!\n");
+		err = -4;
+		goto out;
+	}
+
+	printf("done\n");
+
+	// Correct endianess issues
+	product_id_data.d.zone2.processor_type = le16_to_cpu(product_id_data.d.zone2.processor_type);
+	product_id_data.d.zone2.features = le32_to_cpu(product_id_data.d.zone2.features);
+	product_id_data.d.zone2.platform_bits = le32_to_cpu(product_id_data.d.zone2.platform_bits);
+
+ out:
+	production_data_valid = !err;
+
+	// Restore pins back to their intended use
+	gpio_i2c_restore_pins();
+
+	// Clone the production data into SRAM
+	checksum = calculate_checksum(&product_id_data.d, sizeof(product_id_data.d));
+	product_id_data.checksum = checksum;
+	*(struct product_id_data *)(SRAM_BASE) = product_id_data;
+
+	return err;
+}
+
+void dump_production_data(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	char buf[36];
+
+	if (!production_data_valid)
+		return;
+
+	// Print out the name, model number, and set MAC addresses
+	extract_product_id_part_number(&product_id_data, buf, sizeof(buf));
+
+	printf("Part Number  : %s\n", buf);
+	extract_model_number_revision(&product_id_data, buf, sizeof(buf));
+	if (strlen(buf))
+		printf("Model Name   : %s\n", buf);
+	extract_serial_number(&product_id_data, buf, sizeof(buf));
+	printf("Serial Number: %s\n", buf);
+	if (valid_mac_address(product_id_data.d.zone2.mac[1]))
+		printf("Wired Lan MAC: 00:08:ee:%02x:%02x:%02x\n",
+			product_id_data.d.zone2.mac[0][0],
+			product_id_data.d.zone2.mac[0][1],
+			product_id_data.d.zone2.mac[0][2]);
+
+	if (gd->bd->bi_arch_number == MACH_TYPE_OMAP3530_LV_SOM)
+		if (valid_mac_address(product_id_data.d.zone2.mac[1]))
+			printf("Wirless   MAC: 00:08:ee:%02x:%02x:%02x\n",
+				product_id_data.d.zone2.mac[1][0],
+				product_id_data.d.zone2.mac[1][1],
+				product_id_data.d.zone2.mac[1][2]);
+}
diff -rupN u-boot-2010.06.orig/board/logicpd/alico/alico-gpio.c u-boot-2010.06.new/board/logicpd/alico/alico-gpio.c
--- u-boot-2010.06.orig/board/logicpd/alico/alico-gpio.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/alico/alico-gpio.c	2011-06-10 18:21:27.826688002 -0700
@@ -0,0 +1,161 @@
+/*
+ * (C) Copyright 2008
+ * Logic Produc Development, <www.logicpd.com>
+ * Peter Barada <peter.barada@logicpd.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/cpu.h>
+#include <asm/io.h>
+// #include <asm/arch/bits.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+// #include <asm/arch/sys_info.h>
+#include <asm/arch/clocks.h>
+#include <asm/arch/mem.h>
+#include <i2c.h>
+#include <asm/mach-types.h>
+#include "alico-gpio.h"
+
+#define NUM_OF_BITS_IN_REG                 32
+#define MAX_GPIO_PINS                      192
+#define GPIO_PIN                           1
+#define GPIO_MAX_MODULES			       6
+
+/* GPIO base address */
+#define	GPIO1_MODULE_BA                    0x48310000
+#define	GPIO2_MODULE_BA                    0x49050000
+#define GPIO3_MODULE_BA                    0x49052000
+#define GPIO4_MODULE_BA                    0x49054000
+#define GPIO5_MODULE_BA                    0x49056000
+#define GPIO6_MODULE_BA                    0x49058000
+
+#define GPIO_DATAIN			((uint32_t)0x038)
+#define GPIO_DATAOUT			((uint32_t)0x03C)
+#define GPIO_OE				((uint32_t)0x034)
+
+/* int and long both fit to 32 bits */
+typedef volatile uint32_t*  PREG_U32;
+typedef volatile int32_t*  PREG_S32;
+
+#define in_regl(offSet)			(*(PREG_U32)(offSet))
+#define out_regl(offSet, value)       (*(PREG_U32)(offSet) = (uint32_t)(value))
+
+static uint32_t g_gpio_module_base_address[GPIO_MAX_MODULES]
+				= {GPIO1_MODULE_BA, GPIO2_MODULE_BA, GPIO3_MODULE_BA,
+					 GPIO4_MODULE_BA, GPIO5_MODULE_BA, GPIO6_MODULE_BA};
+
+uint32_t check_gpio_pin_num(uint32_t pin_num)
+{
+  return (pin_num > MAX_GPIO_PINS);
+}
+
+uint32_t get_module_pin_mask(uint32_t pin_num, uint32_t *module_num, uint32_t *offset, uint32_t *pinmask)
+{
+  uint32_t snum, ret_val;
+
+  *module_num = pin_num / NUM_OF_BITS_IN_REG + 1;
+  snum = (*module_num-1)*NUM_OF_BITS_IN_REG;
+  *offset = pin_num - snum;
+  ret_val = check_gpio_pin_num(pin_num);
+  if (ret_val)
+    return ret_val;
+
+  *pinmask = GPIO_PIN<<*offset;
+  return 0;
+}
+
+
+void gpio_write_output_pin(int module_num, uint32_t pin_mask, uint32_t data)
+{
+  uint32_t temp, gpio_data_out_reg;
+
+  gpio_data_out_reg = (g_gpio_module_base_address[module_num-1]+GPIO_DATAOUT);
+
+  temp = in_regl(gpio_data_out_reg);
+  temp = temp & ~pin_mask;
+
+  out_regl(gpio_data_out_reg, (temp | (data & pin_mask)));
+}
+
+void gpio_read_input_pin(uint32_t module_num, uint32_t pin_mask, uint32_t *data)
+{
+  uint32_t gpio_data_in_reg, temp;
+
+  gpio_data_in_reg = (g_gpio_module_base_address[module_num-1]+GPIO_DATAIN);
+
+  temp = in_regl(gpio_data_in_reg);
+  *data = temp & pin_mask;
+}
+
+uint32_t pin_get_gpio_input(uint32_t pin_num)
+{
+  uint32_t module_num, pinmask, offset, data;
+
+  get_module_pin_mask(pin_num, &module_num, &offset, &pinmask);
+
+  gpio_read_input_pin(module_num, (1<<offset), &data);
+  data >>= offset;
+
+  // printf("%s:%d pin %d data %d\n", __FUNCTION__, __LINE__, pin_num, data);
+
+  return data;
+}
+
+
+uint32_t pin_set_gpio_dataout(uint32_t pin_num, uint32_t set)
+{
+  uint32_t module_num, pinmask, offset, ret_val;
+
+  // printf("%s:%d pin %d set %d\n", __FUNCTION__, __LINE__, pin_num, set);
+
+  ret_val = get_module_pin_mask(pin_num, &module_num, &offset, &pinmask);
+
+  if (set)
+    gpio_write_output_pin(module_num, (1<<offset), (1<<offset));
+  else
+    gpio_write_output_pin(module_num, (1<<offset), (0<<offset));
+
+  return ret_val;
+}
+
+uint32_t set_gpio_in_out(uint32_t module_num, uint32_t pin_mask, uint32_t io_mask)
+{
+  uint32_t temp_oe, gpio_pin_output_en_reg;
+
+  gpio_pin_output_en_reg = (g_gpio_module_base_address[module_num-1]+GPIO_OE);
+
+  temp_oe = in_regl(gpio_pin_output_en_reg);
+  temp_oe &= ~pin_mask;
+  temp_oe |= io_mask;
+
+  out_regl(gpio_pin_output_en_reg, temp_oe);
+
+  return 0;
+}
+
+uint32_t pin_init_gpio(uint32_t pin_num, uint32_t in_out)
+{
+	uint32_t module_num, pinmask, offset, ret_val;
+
+	ret_val = get_module_pin_mask(pin_num, &module_num, &offset, &pinmask);
+
+	set_gpio_in_out(module_num, pinmask, in_out<<offset);
+
+	return ret_val;
+}
diff -rupN u-boot-2010.06.orig/board/logicpd/alico/alico-gpio.h u-boot-2010.06.new/board/logicpd/alico/alico-gpio.h
--- u-boot-2010.06.orig/board/logicpd/alico/alico-gpio.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/alico/alico-gpio.h	2010-06-25 11:38:14.000000000 -0700
@@ -0,0 +1,7 @@
+// GPIO
+extern unsigned int pin_get_gpio_input(unsigned int pin);
+extern unsigned int pin_set_gpio_dataout(unsigned int pin, unsigned int set);
+extern unsigned int pin_init_gpio(unsigned int pin_num, unsigned int in_out);
+
+// Turn on VAUX1 voltage for Product ID
+extern void init_vaux1_voltage(void);
diff -rupN u-boot-2010.06.orig/board/logicpd/alico/alico.c u-boot-2010.06.new/board/logicpd/alico/alico.c
--- u-boot-2010.06.orig/board/logicpd/alico/alico.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/alico/alico.c	2011-06-10 18:23:33.610688002 -0700
@@ -0,0 +1,458 @@
+/*
+ * (C) Copyright 2009
+ * Logic Product Development, <www.logicpd.com>
+ *
+ * Author :
+ *	Peter Barada <peterb@logicpd.com>
+ *
+ * Derived from Beagle Board and 3430 SDP code by
+ *	Richard Woodruff <r-woodruff2@ti.com>
+ *	Syed Mohammed Khasim <khasim@ti.com>
+ *
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <netdev.h>
+#include <twl4030.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/gpio.h>
+#include <asm/mach-types.h>
+#include "alico.h"
+#include "product_id.h"
+#include <nand.h>
+
+/*
+ * Routine: logic_identify
+ * Description: Detect if we are running on a Logic or Torpedo.
+ *              This can be done by GPIO_189. If its low after driving it high,
+ *              then its an LOGIC, else Torpedo.
+ */
+unsigned int logic_identify(void)
+{
+	unsigned int val = 0;
+	int i;
+
+	MUX_LOGIC_HSUSB0_D5_GPIO_MUX();
+
+	if (!omap_request_gpio(189)) {
+
+		omap_set_gpio_direction(189, 0);
+		omap_set_gpio_dataout(189, 1);
+
+		// Let it soak for a bit
+		for (i=0; i<0x100; ++i)
+			asm("nop");
+
+		omap_set_gpio_direction(189, 1);
+		val = omap_get_gpio_datain(189);
+		omap_free_gpio(189);
+
+		printf("Board: ");
+		if (val) {
+			printf("Torpedo\n");
+			val = MACH_TYPE_OMAP3_TORPEDO;
+		} else {
+			printf("LV SOM\n");
+			val = MACH_TYPE_OMAP3530_LV_SOM;
+		}
+	}
+	return val;
+}
+
+
+#define LOGIC_NAND_GPMC_CONFIG1	0x00001800
+#define LOGIC_NAND_GPMC_CONFIG2	0x00070700
+#define LOGIC_NAND_GPMC_CONFIG3	0x00070700
+#define LOGIC_NAND_GPMC_CONFIG4	0x05000500
+#define LOGIC_NAND_GPMC_CONFIG5	0x00060707
+#define LOGIC_NAND_GPMC_CONFIG6	0x000002CF
+#define LOGIC_NAND_GPMC_CONFIG7	0x00000C70
+
+static void setup_nand_settings(void)
+{
+	/* Configure GPMC registers */
+	writel(0x00000000, &gpmc_cfg->cs[0].config7);
+	sdelay(1000);
+	writel(LOGIC_NAND_GPMC_CONFIG1, &gpmc_cfg->cs[0].config1);
+	writel(LOGIC_NAND_GPMC_CONFIG2, &gpmc_cfg->cs[0].config2);
+	writel(LOGIC_NAND_GPMC_CONFIG3, &gpmc_cfg->cs[0].config3);
+	writel(LOGIC_NAND_GPMC_CONFIG4, &gpmc_cfg->cs[0].config4);
+	writel(LOGIC_NAND_GPMC_CONFIG5, &gpmc_cfg->cs[0].config5);
+	writel(LOGIC_NAND_GPMC_CONFIG6, &gpmc_cfg->cs[0].config6);
+	writel(LOGIC_NAND_GPMC_CONFIG7, &gpmc_cfg->cs[0].config7);
+	sdelay(2000);
+}
+
+#define LOGIC_CF_GPMC_CONFIG1	0x00001210
+#define LOGIC_CF_GPMC_CONFIG2	0x00131000
+#define LOGIC_CF_GPMC_CONFIG3	0x001f1f01
+#define LOGIC_CF_GPMC_CONFIG4	0x10030e03
+#define LOGIC_CF_GPMC_CONFIG5	0x010f1411
+#define LOGIC_CF_GPMC_CONFIG6	0x80030600
+#define LOGIC_CF_GPMC_CONFIG7	0x00000f58
+
+static void setup_cf_gpmc_setup(void)
+{
+	/* Configure GPMC registers */
+	writel(0x00000000, &gpmc_cfg->cs[3].config7);
+	sdelay(1000);
+	writel(LOGIC_CF_GPMC_CONFIG1, &gpmc_cfg->cs[3].config1);
+	writel(LOGIC_CF_GPMC_CONFIG2, &gpmc_cfg->cs[3].config2);
+	writel(LOGIC_CF_GPMC_CONFIG3, &gpmc_cfg->cs[3].config3);
+	writel(LOGIC_CF_GPMC_CONFIG4, &gpmc_cfg->cs[3].config4);
+	writel(LOGIC_CF_GPMC_CONFIG5, &gpmc_cfg->cs[3].config5);
+	writel(LOGIC_CF_GPMC_CONFIG6, &gpmc_cfg->cs[3].config6);
+	writel(LOGIC_CF_GPMC_CONFIG7, &gpmc_cfg->cs[3].config7);
+	sdelay(2000);
+}
+
+/*
+ * Routine: board_init
+ * Description: Early hardware init.
+ */
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gpmc_init(); /* in SRAM or SDRAM, finish GPMC */
+
+	/* Update NAND settings */
+	setup_nand_settings();
+
+#if 0
+	/* Update CF settings */
+	setup_cf_gpmc_setup();
+#endif
+
+	/* board id for Linux (placeholder until can ID board) */
+	gd->bd->bi_arch_number = MACH_TYPE_OMAP3530_LV_SOM;
+	/* boot param addr */
+	gd->bd->bi_boot_params = (OMAP34XX_SDRC_CS0 + 0x100);
+
+	return 0;
+}
+
+static void setup_net_chip(void);
+static void setup_isp1760_chip(void);
+static void fix_flash_sync(void);
+
+/* Turn on VAUX1 voltage to 3.0 volts to drive level shifters and
+ * power 3.0v parts (tsc2004 and Product ID chip) */
+#define I2C_TRITON2 0x4b /* Address of Triton power group */
+
+void init_vaux1_voltage(void)
+{
+#ifdef CONFIG_DRIVER_OMAP34XX_I2C
+	unsigned char data;
+	unsigned short msg;
+
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+
+	// Select the output voltage
+	data = 0x04;
+	i2c_write(I2C_TRITON2, 0x72, 1, &data, 1);
+	// Select the Processor resource group
+	data = 0x20;
+	i2c_write(I2C_TRITON2, 0x72, 1, &data, 1);
+	// Enable I2C access to the Power bus
+	data = 0x02;
+	i2c_write(I2C_TRITON2, 0x4a, 1, &data, 1);
+	// Send message MSB
+	msg = (1<<13) | (1<<4) | (0xd<<0); // group(process_grp1):resource(vaux1):res_active;
+	data = msg >> 8;
+	i2c_write(I2C_TRITON2, 0x4b, 1, &data, 1);
+	// Send message LSB
+	data = msg & 0xff;
+	i2c_write(I2C_TRITON2, 0x4c, 1, &data, 1);
+#endif
+}
+
+/*
+ * Routine: misc_init_r
+ * Description: Configure board specific parts
+ */
+int misc_init_r(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	struct gpio *gpio5_base = (struct gpio *)OMAP34XX_GPIO5_BASE;
+	struct gpio *gpio6_base = (struct gpio *)OMAP34XX_GPIO6_BASE;
+
+#ifdef CONFIG_DRIVER_OMAP34XX_I2C
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+#endif
+
+	/* Turn on vaux1 to make sure voltage is to the product ID chip.
+	 * Extract production data from ID chip, used to selectively
+	 * initialize portions of the system */
+	init_vaux1_voltage();
+	fetch_production_data();
+
+#if defined(CONFIG_CMD_NET)
+	setup_net_chip();
+#endif
+
+	/* Setup access to the isp1760 chip on CS6 */
+	setup_isp1760_chip();
+
+	twl4030_power_init();
+
+	/* kc: 07/26/2010 */
+	twl4030_led_init(TWL4030_LED_LEDEN_LEDAON | TWL4030_LED_LEDEN_LEDBON);
+
+
+	/* Configure GPIOs to output */
+	writel(~(GPIO23 | GPIO10 | GPIO8 | GPIO2 | GPIO1), &gpio6_base->oe);
+	writel(~(GPIO31 | GPIO30 | GPIO29 | GPIO28 | GPIO22 | GPIO21 |
+		GPIO15 | GPIO14 | GPIO13 | GPIO12), &gpio5_base->oe);
+
+	/* Set GPIOs */
+	writel(GPIO23 | GPIO10 | GPIO8 | GPIO2 | GPIO1,
+		&gpio6_base->setdataout);
+	writel(GPIO31 | GPIO30 | GPIO29 | GPIO28 | GPIO22 | GPIO21 |
+		GPIO15 | GPIO14 | GPIO13 | GPIO12, &gpio5_base->setdataout);
+
+	gd->bd->bi_arch_number = logic_identify();
+
+	/* Fix the flash sync */
+	fix_flash_sync();
+
+	dieid_num_r();
+
+	return 0;
+}
+
+
+/******************************************************************************
+ * Routine: late_board_init
+ * Description: Late hardware init.
+ *****************************************************************************/
+int board_late_init(void)
+{
+	unsigned char enetaddr[6];
+
+	// DECLARE_GLOBAL_DATA_PTR;
+
+	dump_production_data(); // Dump production data
+
+	// Fetch the ethaddr of the LAN
+	board_get_nth_enetaddr(enetaddr, 0, 0);
+#ifdef CONFIG_HAS_ETH1
+	// Fetch the ethaddr of the WiFi
+	board_get_nth_enetaddr(enetaddr, 1, 1);
+#endif
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	// Unlock the whole chip
+	nand_unlock(&nand_info[0], 0x0, nand_info[0].size);
+#endif
+	return 0;
+}
+
+/*
+ * Routine: set_muxconf_regs
+ * Description: Setting up the configuration Mux registers specific to the
+ *		hardware. Many pins need to be moved from protect to primary
+ *		mode.
+ */
+void set_muxconf_regs(void)
+{
+	MUX_LOGIC();
+}
+
+// GPMC settings for LV SOM Ethernet chip
+#define LOGIC_NET_GPMC_CONFIG1  0x00001000
+#define LOGIC_NET_GPMC_CONFIG2  0x00080701
+#define LOGIC_NET_GPMC_CONFIG3  0x00000000
+#define LOGIC_NET_GPMC_CONFIG4  0x08010702
+#define LOGIC_NET_GPMC_CONFIG5  0x00080a0a
+#define LOGIC_NET_GPMC_CONFIG6  0x03000280
+#define LOGIC_NET_GPMC_CONFIG7  0x00000f48
+
+/*
+ * Routine: setup_net_chip
+ * Description: Setting up the configuration GPMC registers specific to the
+ *		Ethernet hardware.
+ */
+static void setup_net_chip(void)
+{
+	struct ctrl *ctrl_base = (struct ctrl *)OMAP34XX_CTRL_BASE;
+
+	/* Configure GPMC registers */
+	writel(LOGIC_NET_GPMC_CONFIG1, &gpmc_cfg->cs[1].config1);
+	writel(LOGIC_NET_GPMC_CONFIG2, &gpmc_cfg->cs[1].config2);
+	writel(LOGIC_NET_GPMC_CONFIG3, &gpmc_cfg->cs[1].config3);
+	writel(LOGIC_NET_GPMC_CONFIG4, &gpmc_cfg->cs[1].config4);
+	writel(LOGIC_NET_GPMC_CONFIG5, &gpmc_cfg->cs[1].config5);
+	writel(LOGIC_NET_GPMC_CONFIG6, &gpmc_cfg->cs[1].config6);
+	writel(LOGIC_NET_GPMC_CONFIG7, &gpmc_cfg->cs[1].config7);
+
+	/* Enable off mode for NWE in PADCONF_GPMC_NWE register */
+	writew(readw(&ctrl_base ->gpmc_nwe) | 0x0E00, &ctrl_base->gpmc_nwe);
+	/* Enable off mode for NOE in PADCONF_GPMC_NADV_ALE register */
+	writew(readw(&ctrl_base->gpmc_noe) | 0x0E00, &ctrl_base->gpmc_noe);
+	/* Enable off mode for ALE in PADCONF_GPMC_NADV_ALE register */
+	writew(readw(&ctrl_base->gpmc_nadv_ale) | 0x0E00,
+		&ctrl_base->gpmc_nadv_ale);
+
+}
+
+// GPMC settings for LOGIC 1760 chip
+#define LOGIC_ISP1760_GPMC_CONFIG1  0x00001200
+#define LOGIC_ISP1760_GPMC_CONFIG2  0x00090901
+#define LOGIC_ISP1760_GPMC_CONFIG3  0x00091001
+#define LOGIC_ISP1760_GPMC_CONFIG4  0x07031002
+#define LOGIC_ISP1760_GPMC_CONFIG5  0x00080c0a
+#define LOGIC_ISP1760_GPMC_CONFIG6  0x08030200
+#define LOGIC_ISP1760_GPMC_CONFIG7  0x00000f5c
+
+/*
+ * Routine: setup_isp1760_chip
+ * Description: Setting up the configuration GPMC registers specific to the
+ *		ISP1760 USB hardware.
+ */
+static void setup_isp1760_chip(void)
+{
+	/* Configure GPMC registers */
+	writel(LOGIC_ISP1760_GPMC_CONFIG1, &gpmc_cfg->cs[6].config1);
+	writel(LOGIC_ISP1760_GPMC_CONFIG2, &gpmc_cfg->cs[6].config2);
+	writel(LOGIC_ISP1760_GPMC_CONFIG3, &gpmc_cfg->cs[6].config3);
+	writel(LOGIC_ISP1760_GPMC_CONFIG4, &gpmc_cfg->cs[6].config4);
+	writel(LOGIC_ISP1760_GPMC_CONFIG5, &gpmc_cfg->cs[6].config5);
+	writel(LOGIC_ISP1760_GPMC_CONFIG6, &gpmc_cfg->cs[6].config6);
+	writel(LOGIC_ISP1760_GPMC_CONFIG7, &gpmc_cfg->cs[6].config7);
+}
+
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG1	0x00001211
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG2	0x00080901
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG3	0x00020201
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG4	0x08010901
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG5	0x0008090a
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG6	0x08030200
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG7	0x00000c50
+
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG1	0x68411213
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG2	0x000C1502
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG3	0x00040402
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG4	0x0B051505
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG5	0x020E0C15
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG6	0x0B0603C3
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG7	0x00000c50
+
+#define LOGIC_FLASH_BASE 0x10000000
+
+/* These are bit definitions for the RCR register of the NOR flash       */
+/* 28FxxxP30 device.  This register sets the bus configration for reads. */
+/* settings, located on address pins A[15:0].                            */
+#define FLASH_28FxxxP30_RCR_RM    0x8000
+#define FLASH_28FxxxP30_RCR_R     0x4000
+#define FLASH_28FxxxP30_RCR_LC(x) ((x & 0x7) << 11)
+#define FLASH_28FxxxP30_RCR_WP    0x0400
+#define FLASH_28FxxxP30_RCR_DH    0x0200
+#define FLASH_28FxxxP30_RCR_WD    0x0100
+#define FLASH_28FxxxP30_RCR_BS    0x0080
+#define FLASH_28FxxxP30_RCR_CE    0x0040
+#define FLASH_28FxxxP30_RCR_BW    0x0008
+#define FLASH_28FxxxP30_RCR_BL(x) ((x & 0x7) << 0)
+#define FLASH_28FxxxP30_BL_4      0x1
+#define FLASH_28FxxxP30_BL_8      0x2
+#define FLASH_28FxxxP30_BL_16     0x3
+#define FLASH_28FxxxP30_BL_CONT   0x7
+
+/*
+ * Routine: fix_flash_sync
+ * Description: Setting up the configuration GPMC registers specific to the
+ *		NOR flash (and place in sync mode if not done).
+ */
+static void fix_flash_sync(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	int arch_number;
+	u16 rcrval;
+
+	/* Check the arch_number - Torpedo doesn't have NOR flash */
+	arch_number = gd->bd->bi_arch_number;
+	if (arch_number == MACH_TYPE_OMAP3_TORPEDO)
+		return;
+
+	/* If no NOR in product, then return */
+	if (productID_has_NOR_flash() <= 0) {
+		printf("NOR: None installed\n");
+		return;
+	}
+
+	/* Check CS2 config, if its already in sync, then return */
+	if (!(readl(&gpmc_cfg->cs[2].config1) & TYPE_READTYPE)) {
+		puts("NOR: initialize in sync mode\n");
+
+		/* clear WAIT1 polarity */
+		writel(readl(&gpmc_cfg->config) & ~0x200, &gpmc_cfg->config);
+
+		/* clear GPMC_TIMEOUT */
+		writel(0x0, &gpmc_cfg->timeout_control);
+
+		/* Configure GPMC registers for async */
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG1, &gpmc_cfg->cs[2].config1);
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG2, &gpmc_cfg->cs[2].config2);
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG3, &gpmc_cfg->cs[2].config3);
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG4, &gpmc_cfg->cs[2].config4);
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG5, &gpmc_cfg->cs[2].config5);
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG6, &gpmc_cfg->cs[2].config6);
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG7, &gpmc_cfg->cs[2].config7);
+
+		/* 1st NOR cycle, send read config register setup 0x60 */
+		*(volatile u16 *)LOGIC_FLASH_BASE = 0x0060;
+
+		/* 2nd NOR cycle, send 0x03 to latch in read
+		 * configuration register setttings, located on A[15:0] */
+		rcrval = FLASH_28FxxxP30_RCR_LC(4) | FLASH_28FxxxP30_RCR_WP |
+		  FLASH_28FxxxP30_RCR_BS | FLASH_28FxxxP30_RCR_CE |
+		  FLASH_28FxxxP30_RCR_BW | FLASH_28FxxxP30_RCR_BL(FLASH_28FxxxP30_BL_4);
+		*(volatile u16 *)(LOGIC_FLASH_BASE | (rcrval << 1)) = 0x0003;
+
+		/* Give a chance for accesses to finish... */
+		sdelay(2000);
+
+		/* Third, set GPMC for sync. */
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG1, &gpmc_cfg->cs[2].config1);
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG2, &gpmc_cfg->cs[2].config2);
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG3, &gpmc_cfg->cs[2].config3);
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG4, &gpmc_cfg->cs[2].config4);
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG5, &gpmc_cfg->cs[2].config5);
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG6, &gpmc_cfg->cs[2].config6);
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG7, &gpmc_cfg->cs[2].config7);
+		/* And lastly, set the WAIT1 polarity high */
+		writel(readl(&gpmc_cfg->config) | 0x200, &gpmc_cfg->config);
+	} else
+		puts ("NOR: Already initialized in sync mode\n");
+}
+
+
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+#ifdef CONFIG_SMC911X
+	rc = smc911x_initialize(0, CONFIG_SMC911X_BASE);
+#endif
+	return rc;
+}
diff -rupN u-boot-2010.06.orig/board/logicpd/alico/alico.h u-boot-2010.06.new/board/logicpd/alico/alico.h
--- u-boot-2010.06.orig/board/logicpd/alico/alico.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/alico/alico.h	2010-06-25 11:38:14.000000000 -0700
@@ -0,0 +1,376 @@
+/*
+ * (C) Copyright 2009
+ * Peter Barada <peterb@logicpd.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _LOGIC_H_
+#define _LOGIC_H_
+
+const omap3_sysinfo sysinfo = {
+	DDR_STACKED,
+	"OMAP3 Logic",
+	"NAND",
+};
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ * The commented string gives the final mux configuration for that pin
+ */
+#define MUX_LOGIC() \
+ /*SDRC*/\
+ MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0)) /*SDRC_D0*/\
+ MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0)) /*SDRC_D1*/\
+ MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0)) /*SDRC_D2*/\
+ MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0)) /*SDRC_D3*/\
+ MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0)) /*SDRC_D4*/\
+ MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0)) /*SDRC_D5*/\
+ MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0)) /*SDRC_D6*/\
+ MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0)) /*SDRC_D7*/\
+ MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0)) /*SDRC_D8*/\
+ MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0)) /*SDRC_D9*/\
+ MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0)) /*SDRC_D10*/\
+ MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0)) /*SDRC_D11*/\
+ MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0)) /*SDRC_D12*/\
+ MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0)) /*SDRC_D13*/\
+ MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0)) /*SDRC_D14*/\
+ MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0)) /*SDRC_D15*/\
+ MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0)) /*SDRC_D16*/\
+ MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0)) /*SDRC_D17*/\
+ MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0)) /*SDRC_D18*/\
+ MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0)) /*SDRC_D19*/\
+ MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0)) /*SDRC_D20*/\
+ MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0)) /*SDRC_D21*/\
+ MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0)) /*SDRC_D22*/\
+ MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0)) /*SDRC_D23*/\
+ MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0)) /*SDRC_D24*/\
+ MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0)) /*SDRC_D25*/\
+ MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0)) /*SDRC_D26*/\
+ MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0)) /*SDRC_D27*/\
+ MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0)) /*SDRC_D28*/\
+ MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0)) /*SDRC_D29*/\
+ MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0)) /*SDRC_D30*/\
+ MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0)) /*SDRC_D31*/\
+ MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0)) /*SDRC_CLK*/\
+ MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS0*/\
+ MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS1*/\
+ MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS2*/\
+ MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS3*/\
+ /*GPMC*/\
+ MUX_VAL(CP(GPMC_A1),		(IDIS | PTD | DIS | M0)) /*GPMC_A1*/\
+ MUX_VAL(CP(GPMC_A2),		(IDIS | PTD | DIS | M0)) /*GPMC_A2*/\
+ MUX_VAL(CP(GPMC_A3),		(IDIS | PTD | DIS | M0)) /*GPMC_A3*/\
+ MUX_VAL(CP(GPMC_A4),		(IDIS | PTD | DIS | M0)) /*GPMC_A4*/\
+ MUX_VAL(CP(GPMC_A5),		(IDIS | PTD | DIS | M0)) /*GPMC_A5*/\
+ MUX_VAL(CP(GPMC_A6),		(IDIS | PTD | DIS | M0)) /*GPMC_A6*/\
+ MUX_VAL(CP(GPMC_A7),		(IDIS | PTD | DIS | M0)) /*GPMC_A7*/\
+ MUX_VAL(CP(GPMC_A8),		(IDIS | PTD | DIS | M0)) /*GPMC_A8*/\
+ MUX_VAL(CP(GPMC_A9),		(IDIS | PTD | DIS | M0)) /*GPMC_A9*/\
+ MUX_VAL(CP(GPMC_A10),		(IDIS | PTD | DIS | M0)) /*GPMC_A10*/\
+ MUX_VAL(CP(GPMC_D0),		(IEN  | PTD | DIS | M0)) /*GPMC_D0*/\
+ MUX_VAL(CP(GPMC_D1),		(IEN  | PTD | DIS | M0)) /*GPMC_D1*/\
+ MUX_VAL(CP(GPMC_D2),		(IEN  | PTD | DIS | M0)) /*GPMC_D2*/\
+ MUX_VAL(CP(GPMC_D3),		(IEN  | PTD | DIS | M0)) /*GPMC_D3*/\
+ MUX_VAL(CP(GPMC_D4),		(IEN  | PTD | DIS | M0)) /*GPMC_D4*/\
+ MUX_VAL(CP(GPMC_D5),		(IEN  | PTD | DIS | M0)) /*GPMC_D5*/\
+ MUX_VAL(CP(GPMC_D6),		(IEN  | PTD | DIS | M0)) /*GPMC_D6*/\
+ MUX_VAL(CP(GPMC_D7),		(IEN  | PTD | DIS | M0)) /*GPMC_D7*/\
+ MUX_VAL(CP(GPMC_D8),		(IEN  | PTD | DIS | M0)) /*GPMC_D8*/\
+ MUX_VAL(CP(GPMC_D9),		(IEN  | PTD | DIS | M0)) /*GPMC_D9*/\
+ MUX_VAL(CP(GPMC_D10),		(IEN  | PTD | DIS | M0)) /*GPMC_D10*/\
+ MUX_VAL(CP(GPMC_D11),		(IEN  | PTD | DIS | M0)) /*GPMC_D11*/\
+ MUX_VAL(CP(GPMC_D12),		(IEN  | PTD | DIS | M0)) /*GPMC_D12*/\
+ MUX_VAL(CP(GPMC_D13),		(IEN  | PTD | DIS | M0)) /*GPMC_D13*/\
+ MUX_VAL(CP(GPMC_D14),		(IEN  | PTD | DIS | M0)) /*GPMC_D14*/\
+ MUX_VAL(CP(GPMC_D15),		(IEN  | PTD | DIS | M0)) /*GPMC_D15*/\
+ MUX_VAL(CP(GPMC_NCS0),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS0*/\
+ MUX_VAL(CP(GPMC_NCS1),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS1*/\
+ MUX_VAL(CP(GPMC_NCS2),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS2*/\
+ MUX_VAL(CP(GPMC_NCS3),		(IEN  | PTD | DIS | M0)) /*GPMC_nCS3*/\
+ MUX_VAL(CP(GPMC_NCS4),		(IDIS | PTU | EN  | M7)) /*GPMC_nCS4*/\
+ MUX_VAL(CP(GPMC_NCS5),		(IDIS | PTD | DIS | M7)) /*GPMC_nCS5*/\
+ MUX_VAL(CP(GPMC_NCS6),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS6*/\
+ MUX_VAL(CP(GPMC_NCS7),		(IEN  | PTU | EN  | M1)) /*GPMC_IO_DIR*/\
+ MUX_VAL(CP(GPMC_NBE1),		(IDIS | PTU | EN  | M0)) /*GPMC_nBE1*/\
+ MUX_VAL(CP(GPMC_WAIT0),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT0*/\
+ MUX_VAL(CP(GPMC_WAIT1),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT1*/\
+ MUX_VAL(CP(GPMC_WAIT2),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT2*/\
+ MUX_VAL(CP(GPMC_WAIT3),	(IEN  | PTU | EN  | M1)) /*uP_DREQ1*/\
+ MUX_VAL(CP(GPMC_CLK),		(IEN  | PTD | DIS | M0)) /*GPMC_CLK*/\
+ MUX_VAL(CP(GPMC_NADV_ALE),	(IDIS | PTD | DIS | M0)) /*GPMC_nADV_ALE*/\
+ MUX_VAL(CP(GPMC_NOE),		(IDIS | PTD | DIS | M0)) /*GPMC_nOE*/\
+ MUX_VAL(CP(GPMC_NWE),		(IDIS | PTD | DIS | M0)) /*GPMC_nWE*/\
+ MUX_VAL(CP(GPMC_NWP),		(IEN  | PTU | EN  | M0)) /*GPMC_nWP*/\
+ MUX_VAL(CP(GPMC_NBE0_CLE),	(IEN  | PTU | EN  | M0)) /*GPMC_nBE0_CLE*/\
+ /*DSS*/\
+ MUX_VAL(CP(DSS_PCLK),		(IDIS | PTD | DIS | M0)) /*DSS_PCLK*/\
+ MUX_VAL(CP(DSS_HSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_HSYNC*/\
+ MUX_VAL(CP(DSS_VSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_VSYNC*/\
+ MUX_VAL(CP(DSS_ACBIAS),	(IDIS | PTD | DIS | M0)) /*DSS_ACBIAS*/\
+ MUX_VAL(CP(DSS_DATA0),		(IDIS | PTD | DIS | M0)) /*DSS_DATA0*/\
+ MUX_VAL(CP(DSS_DATA1),		(IDIS | PTD | DIS | M0)) /*DSS_DATA1*/\
+ MUX_VAL(CP(DSS_DATA2),		(IDIS | PTD | DIS | M0)) /*DSS_DATA2*/\
+ MUX_VAL(CP(DSS_DATA3),		(IDIS | PTD | DIS | M0)) /*DSS_DATA3*/\
+ MUX_VAL(CP(DSS_DATA4),		(IDIS | PTD | DIS | M0)) /*DSS_DATA4*/\
+ MUX_VAL(CP(DSS_DATA5),		(IDIS | PTD | DIS | M0)) /*DSS_DATA5*/\
+ MUX_VAL(CP(DSS_DATA6),		(IDIS | PTD | DIS | M0)) /*DSS_DATA6*/\
+ MUX_VAL(CP(DSS_DATA7),		(IDIS | PTD | DIS | M0)) /*DSS_DATA7*/\
+ MUX_VAL(CP(DSS_DATA8),		(IDIS | PTD | DIS | M0)) /*DSS_DATA8*/\
+ MUX_VAL(CP(DSS_DATA9),		(IDIS | PTD | DIS | M0)) /*DSS_DATA9*/\
+ MUX_VAL(CP(DSS_DATA10),	(IDIS | PTD | DIS | M0)) /*DSS_DATA10*/\
+ MUX_VAL(CP(DSS_DATA11),	(IDIS | PTD | DIS | M0)) /*DSS_DATA11*/\
+ MUX_VAL(CP(DSS_DATA12),	(IDIS | PTD | DIS | M0)) /*DSS_DATA12*/\
+ MUX_VAL(CP(DSS_DATA13),	(IDIS | PTD | DIS | M0)) /*DSS_DATA13*/\
+ MUX_VAL(CP(DSS_DATA14),	(IDIS | PTD | DIS | M0)) /*DSS_DATA14*/\
+ MUX_VAL(CP(DSS_DATA15),	(IDIS | PTD | DIS | M0)) /*DSS_DATA15*/\
+ MUX_VAL(CP(DSS_DATA16),	(IDIS | PTD | DIS | M0)) /*DSS_DATA16*/\
+ MUX_VAL(CP(DSS_DATA17),	(IDIS | PTD | DIS | M0)) /*DSS_DATA17*/\
+ MUX_VAL(CP(DSS_DATA18),	(IDIS | PTD | DIS | M0)) /*DSS_DATA18*/\
+ MUX_VAL(CP(DSS_DATA19),	(IDIS | PTD | DIS | M0)) /*DSS_DATA19*/\
+ MUX_VAL(CP(DSS_DATA20),	(IDIS | PTD | DIS | M0)) /*DSS_DATA20*/\
+ MUX_VAL(CP(DSS_DATA21),	(IDIS | PTD | DIS | M0)) /*DSS_DATA21*/\
+ MUX_VAL(CP(DSS_DATA22),	(IDIS | PTD | DIS | M0)) /*DSS_DATA22*/\
+ MUX_VAL(CP(DSS_DATA23),	(IDIS | PTD | DIS | M0)) /*DSS_DATA23*/\
+ /*CAMERA*/\
+ MUX_VAL(CP(CAM_HS),		(IEN  | PTU | EN  | M0)) /*CAM_HS */\
+ MUX_VAL(CP(CAM_VS),		(IEN  | PTU | EN  | M0)) /*CAM_VS */\
+ MUX_VAL(CP(CAM_XCLKA),		(IDIS | PTD | DIS | M0)) /*CAM_XCLKA*/\
+ MUX_VAL(CP(CAM_PCLK),		(IEN  | PTU | EN  | M0)) /*CAM_PCLK*/\
+ MUX_VAL(CP(CAM_FLD),		(IDIS | PTD | DIS | M4)) /*GPIO_98*/\
+ MUX_VAL(CP(CAM_D0),		(IEN  | PTD | DIS | M0)) /*CAM_D0*/\
+ MUX_VAL(CP(CAM_D1),		(IEN  | PTD | DIS | M0)) /*CAM_D1*/\
+ MUX_VAL(CP(CAM_D2),		(IEN  | PTD | DIS | M0)) /*CAM_D2*/\
+ MUX_VAL(CP(CAM_D3),		(IEN  | PTD | DIS | M0)) /*CAM_D3*/\
+ MUX_VAL(CP(CAM_D4),		(IEN  | PTD | DIS | M0)) /*CAM_D4*/\
+ MUX_VAL(CP(CAM_D5),		(IEN  | PTD | DIS | M0)) /*CAM_D5*/\
+ MUX_VAL(CP(CAM_D6),		(IEN  | PTD | DIS | M0)) /*CAM_D6*/\
+ MUX_VAL(CP(CAM_D7),		(IEN  | PTD | DIS | M0)) /*CAM_D7*/\
+ MUX_VAL(CP(CAM_D8),		(IEN  | PTD | DIS | M0)) /*CAM_D8*/\
+ MUX_VAL(CP(CAM_D9),		(IEN  | PTD | DIS | M0)) /*CAM_D9*/\
+ MUX_VAL(CP(CAM_D10),		(IEN  | PTD | DIS | M0)) /*CAM_D10*/\
+ MUX_VAL(CP(CAM_D11),		(IEN  | PTD | DIS | M0)) /*CAM_D11*/\
+ MUX_VAL(CP(CAM_XCLKB),		(IDIS | PTD | DIS | M0)) /*CAM_XCLKB*/\
+ MUX_VAL(CP(CAM_WEN),		(IEN  | PTD | DIS | M4)) /*GPIO_167*/\
+ MUX_VAL(CP(CAM_STROBE),	(IDIS | PTD | DIS | M0)) /*CAM_STROBE*/\
+ MUX_VAL(CP(CSI2_DX0),		(IEN  | PTD | DIS | M0)) /*CSI2_DX0*/\
+ MUX_VAL(CP(CSI2_DY0),		(IEN  | PTD | DIS | M0)) /*CSI2_DY0*/\
+ MUX_VAL(CP(CSI2_DX1),		(IEN  | PTD | DIS | M0)) /*CSI2_DX1*/\
+ MUX_VAL(CP(CSI2_DY1),		(IEN  | PTD | DIS | M0)) /*CSI2_DY1*/\
+ /*Audio Interface */\
+ MUX_VAL(CP(MCBSP2_FSX),	(IEN  | PTD | DIS | M0)) /*McBSP2_FSX*/\
+ MUX_VAL(CP(MCBSP2_CLKX),	(IEN  | PTD | DIS | M0)) /*McBSP2_CLKX*/\
+ MUX_VAL(CP(MCBSP2_DR),		(IEN  | PTD | DIS | M0)) /*McBSP2_DR*/\
+ MUX_VAL(CP(MCBSP2_DX),		(IDIS | PTD | DIS | M0)) /*McBSP2_DX*/\
+ /*Expansion card */\
+ MUX_VAL(CP(MMC1_CLK),		(IDIS | PTU | EN  | M0)) /*MMC1_CLK*/\
+ MUX_VAL(CP(MMC1_CMD),		(IEN  | PTU | EN  | M0)) /*MMC1_CMD*/\
+ MUX_VAL(CP(MMC1_DAT0),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT0*/\
+ MUX_VAL(CP(MMC1_DAT1),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT1*/\
+ MUX_VAL(CP(MMC1_DAT2),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT2*/\
+ MUX_VAL(CP(MMC1_DAT3),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT3*/\
+ MUX_VAL(CP(MMC1_DAT4),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT4*/\
+ MUX_VAL(CP(MMC1_DAT5),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT5*/\
+ MUX_VAL(CP(MMC1_DAT6),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT6*/\
+ MUX_VAL(CP(MMC1_DAT7),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT7*/\
+ /*Wireless LAN */\
+ MUX_VAL(CP(MMC2_CLK),		(IEN  | PTU | EN  | M4)) /*GPIO_130*/\
+ MUX_VAL(CP(MMC2_CMD),		(IEN  | PTU | EN  | M4)) /*GPIO_131*/\
+ MUX_VAL(CP(MMC2_DAT0),		(IEN  | PTU | EN  | M4)) /*GPIO_132*/\
+ MUX_VAL(CP(MMC2_DAT1),		(IEN  | PTU | EN  | M4)) /*GPIO_133*/\
+ MUX_VAL(CP(MMC2_DAT2),		(IEN  | PTU | EN  | M4)) /*GPIO_134*/\
+ MUX_VAL(CP(MMC2_DAT3),		(IEN  | PTU | EN  | M4)) /*GPIO_135*/\
+ MUX_VAL(CP(MMC2_DAT4),		(IEN  | PTU | EN  | M4)) /*GPIO_136*/\
+ MUX_VAL(CP(MMC2_DAT5),		(IEN  | PTU | EN  | M4)) /*GPIO_137*/\
+ MUX_VAL(CP(MMC2_DAT6),		(IEN  | PTU | EN  | M4)) /*GPIO_138*/\
+ MUX_VAL(CP(MMC2_DAT7),		(IEN  | PTU | EN  | M4)) /*GPIO_139*/\
+ /*Bluetooth*/\
+ MUX_VAL(CP(MCBSP3_DX),		(IEN  | PTD | DIS | M1)) /*UART2_CTS*/\
+ MUX_VAL(CP(MCBSP3_DR),		(IDIS | PTD | DIS | M1)) /*UART2_RTS*/\
+ MUX_VAL(CP(MCBSP3_CLKX),	(IDIS | PTD | DIS | M1)) /*UART2_TX*/\
+ MUX_VAL(CP(MCBSP3_FSX),	(IEN  | PTD | DIS | M1)) /*UART2_RX*/\
+ MUX_VAL(CP(UART2_CTS),		(IEN  | PTD | DIS | M4)) /*GPIO_144*/\
+ MUX_VAL(CP(UART2_RTS),		(IEN  | PTD | DIS | M4)) /*GPIO_145*/\
+ MUX_VAL(CP(UART2_TX),		(IEN  | PTD | DIS | M4)) /*GPIO_146*/\
+ MUX_VAL(CP(UART2_RX),		(IEN  | PTD | DIS | M4)) /*GPIO_147*/\
+ /*Modem Interface */\
+ MUX_VAL(CP(UART1_TX),		(IDIS | PTD | DIS | M0)) /*UART1_TX*/\
+ MUX_VAL(CP(UART1_RTS),		(IDIS | PTD | DIS | M4)) /*GPIO_149*/ \
+ MUX_VAL(CP(UART1_CTS),		(IDIS | PTD | DIS | M4)) /*GPIO_150*/ \
+ MUX_VAL(CP(UART1_RX),		(IEN  | PTD | DIS | M0)) /*UART1_RX*/\
+ MUX_VAL(CP(MCBSP4_CLKX),	(IEN  | PTD | DIS | M1)) /*SSI1_DAT_RX*/\
+ MUX_VAL(CP(MCBSP4_DR),		(IEN  | PTD | DIS | M1)) /*SSI1_FLAG_RX*/\
+ MUX_VAL(CP(MCBSP4_DX),		(IEN  | PTD | DIS | M1)) /*SSI1_RDY_RX*/\
+ MUX_VAL(CP(MCBSP4_FSX),	(IEN  | PTD | DIS | M1)) /*SSI1_WAKE*/\
+ MUX_VAL(CP(MCBSP1_CLKR),	(IDIS | PTD | DIS | M4)) /*GPIO_156*/\
+ MUX_VAL(CP(MCBSP1_FSR),	(IDIS | PTU | EN  | M4)) /*GPIO_157*/\
+ MUX_VAL(CP(MCBSP1_DX),		(IDIS | PTD | DIS | M4)) /*GPIO_158*/\
+ MUX_VAL(CP(MCBSP1_DR),		(IDIS | PTD | DIS | M4)) /*GPIO_159*/\
+ MUX_VAL(CP(MCBSP_CLKS),	(IEN  | PTU | DIS | M0)) /*McBSP_CLKS*/\
+ MUX_VAL(CP(MCBSP1_FSX),	(IDIS | PTD | DIS | M4)) /*GPIO_161*/\
+ MUX_VAL(CP(MCBSP1_CLKX),	(IDIS | PTD | DIS | M4)) /*GPIO_162*/\
+ /*Serial Interface*/\
+ MUX_VAL(CP(UART3_CTS_RCTX),	(IEN  | PTD | EN  | M0)) /*UART3_CTS_RCTX*/\
+ MUX_VAL(CP(UART3_RTS_SD),	(IDIS | PTD | DIS | M0)) /*UART3_RTS_SD */\
+ MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTD | DIS | M0)) /*UART3_RX_IRRX*/\
+ MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0)) /*UART3_TX_IRTX*/\
+ MUX_VAL(CP(HSUSB0_CLK),	(IEN  | PTD | DIS | M0)) /*HSUSB0_CLK*/\
+ MUX_VAL(CP(HSUSB0_STP),	(IDIS | PTU | EN  | M0)) /*HSUSB0_STP*/\
+ MUX_VAL(CP(HSUSB0_DIR),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DIR*/\
+ MUX_VAL(CP(HSUSB0_NXT),	(IEN  | PTD | DIS | M0)) /*HSUSB0_NXT*/\
+ MUX_VAL(CP(HSUSB0_DATA0),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA0*/\
+ MUX_VAL(CP(HSUSB0_DATA1),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA1*/\
+ MUX_VAL(CP(HSUSB0_DATA2),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA2*/\
+ MUX_VAL(CP(HSUSB0_DATA3),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA3*/\
+ MUX_VAL(CP(HSUSB0_DATA4),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA4*/\
+ MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA5*/\
+ MUX_VAL(CP(HSUSB0_DATA6),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA6*/\
+ MUX_VAL(CP(HSUSB0_DATA7),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA7*/\
+ MUX_VAL(CP(I2C1_SCL),		(IEN  | PTU | EN  | M0)) /*I2C1_SCL*/\
+ MUX_VAL(CP(I2C1_SDA),		(IEN  | PTU | EN  | M0)) /*I2C1_SDA*/\
+ MUX_VAL(CP(I2C2_SCL),		(IEN  | PTU | EN  | M4)) /*GPIO_168*/\
+ MUX_VAL(CP(I2C2_SDA),		(IEN  | PTU | EN  | M4)) /*GPIO_183*/\
+ MUX_VAL(CP(I2C3_SCL),		(IEN  | PTU | EN  | M0)) /*I2C3_SCL*/\
+ MUX_VAL(CP(I2C3_SDA),		(IEN  | PTU | EN  | M0)) /*I2C3_SDA*/\
+ MUX_VAL(CP(I2C4_SCL),		(IEN  | PTU | EN  | M0)) /*I2C4_SCL*/\
+ MUX_VAL(CP(I2C4_SDA),		(IEN  | PTU | EN  | M0)) /*I2C4_SDA*/\
+ MUX_VAL(CP(HDQ_SIO),		(IDIS | PTU | EN  | M4)) /*GPIO_170*/\
+ MUX_VAL(CP(MCSPI1_CLK),	(IEN  | PTU | EN  | M4)) /*GPIO_171*/\
+ MUX_VAL(CP(MCSPI1_SIMO),	(IEN  | PTU | EN  | M4)) /*GPIO_172*/\
+ MUX_VAL(CP(MCSPI1_SOMI),	(IEN  | PTD | DIS | M0)) /*McSPI1_SOMI*/\
+ MUX_VAL(CP(MCSPI1_CS0),	(IEN  | PTD | EN  | M0)) /*McSPI1_CS0*/\
+ MUX_VAL(CP(MCSPI1_CS1),	(IDIS | PTD | EN  | M0)) /*McSPI1_CS1*/\
+ MUX_VAL(CP(MCSPI1_CS2),	(IDIS | PTD | DIS | M4)) /*GPIO_176*/\
+ /* USB EHCI (port 2) */\
+ MUX_VAL(CP(MCSPI1_CS3),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA2*/\
+ MUX_VAL(CP(MCSPI2_CLK),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA7*/\
+ MUX_VAL(CP(MCSPI2_SIMO),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA4*/\
+ MUX_VAL(CP(MCSPI2_SOMI),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA5*/\
+ MUX_VAL(CP(MCSPI2_CS0),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA6*/\
+ MUX_VAL(CP(MCSPI2_CS1),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA3*/\
+ MUX_VAL(CP(ETK_D10_ES2),	(IDIS | PTU | DIS | M3)) /*HSUSB2_CLK*/\
+ MUX_VAL(CP(ETK_D11_ES2),	(IDIS | PTU | DIS | M3)) /*HSUSB2_STP*/\
+ MUX_VAL(CP(ETK_D12_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DIR*/\
+ MUX_VAL(CP(ETK_D13_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB2_NXT*/\
+ MUX_VAL(CP(ETK_D14_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA0*/\
+ MUX_VAL(CP(ETK_D15_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA1*/\
+ /*Control and debug */\
+ MUX_VAL(CP(SYS_32K),		(IEN  | PTD | DIS | M0)) /*SYS_32K*/\
+ MUX_VAL(CP(SYS_CLKREQ),	(IEN  | PTD | DIS | M0)) /*SYS_CLKREQ*/\
+ MUX_VAL(CP(SYS_NIRQ),		(IEN  | PTU | EN  | M0)) /*SYS_nIRQ*/\
+ MUX_VAL(CP(SYS_BOOT0),		(IEN  | PTD | DIS | M4)) /*GPIO_2*/\
+ MUX_VAL(CP(SYS_BOOT1),		(IEN  | PTD | DIS | M4)) /*GPIO_3*/\
+ MUX_VAL(CP(SYS_BOOT2),		(IEN  | PTD | DIS | M4)) /*GPIO_4 - MMC1_WP*/\
+ MUX_VAL(CP(SYS_BOOT3),		(IEN  | PTD | DIS | M4)) /*GPIO_5*/\
+ MUX_VAL(CP(SYS_BOOT4),		(IEN  | PTD | DIS | M4)) /*GPIO_6*/\
+ MUX_VAL(CP(SYS_BOOT5),		(IEN  | PTD | DIS | M4)) /*GPIO_7*/\
+ MUX_VAL(CP(SYS_BOOT6),		(IDIS | PTD | DIS | M4)) /*GPIO_8*/ \
+ MUX_VAL(CP(SYS_OFF_MODE),	(IEN  | PTD | DIS | M0)) /*SYS_OFF_MODE*/\
+ MUX_VAL(CP(SYS_CLKOUT1),	(IEN  | PTD | DIS | M0)) /*SYS_CLKOUT1*/\
+ MUX_VAL(CP(SYS_CLKOUT2),	(IEN  | PTU | EN  | M4)) /*GPIO_186*/\
+ MUX_VAL(CP(ETK_CLK_ES2),	(IDIS | PTU | EN  | M3)) /*HSUSB1_STP*/\
+ MUX_VAL(CP(ETK_CTL_ES2),	(IDIS | PTU | DIS | M3)) /*HSUSB1_CLK*/\
+ MUX_VAL(CP(ETK_D0_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA0*/\
+ MUX_VAL(CP(ETK_D1_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA1*/\
+ MUX_VAL(CP(ETK_D2_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA2*/\
+ MUX_VAL(CP(ETK_D3_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA7*/\
+ MUX_VAL(CP(ETK_D4_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA4*/\
+ MUX_VAL(CP(ETK_D5_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA5*/\
+ MUX_VAL(CP(ETK_D6_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA6*/\
+ MUX_VAL(CP(ETK_D7_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA3*/\
+ MUX_VAL(CP(ETK_D8_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DIR*/\
+ MUX_VAL(CP(ETK_D9_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_NXT*/\
+ MUX_VAL(CP(D2D_MCAD1),		(IEN  | PTD | EN  | M0)) /*d2d_mcad1*/\
+ MUX_VAL(CP(D2D_MCAD2),		(IEN  | PTD | EN  | M0)) /*d2d_mcad2*/\
+ MUX_VAL(CP(D2D_MCAD3),		(IEN  | PTD | EN  | M0)) /*d2d_mcad3*/\
+ MUX_VAL(CP(D2D_MCAD4),		(IEN  | PTD | EN  | M0)) /*d2d_mcad4*/\
+ MUX_VAL(CP(D2D_MCAD5),		(IEN  | PTD | EN  | M0)) /*d2d_mcad5*/\
+ MUX_VAL(CP(D2D_MCAD6),		(IEN  | PTD | EN  | M0)) /*d2d_mcad6*/\
+ MUX_VAL(CP(D2D_MCAD7),		(IEN  | PTD | EN  | M0)) /*d2d_mcad7*/\
+ MUX_VAL(CP(D2D_MCAD8),		(IEN  | PTD | EN  | M0)) /*d2d_mcad8*/\
+ MUX_VAL(CP(D2D_MCAD9),		(IEN  | PTD | EN  | M0)) /*d2d_mcad9*/\
+ MUX_VAL(CP(D2D_MCAD10),	(IEN  | PTD | EN  | M0)) /*d2d_mcad10*/\
+ MUX_VAL(CP(D2D_MCAD11),	(IEN  | PTD | EN  | M0)) /*d2d_mcad11*/\
+ MUX_VAL(CP(D2D_MCAD12),	(IEN  | PTD | EN  | M0)) /*d2d_mcad12*/\
+ MUX_VAL(CP(D2D_MCAD13),	(IEN  | PTD | EN  | M0)) /*d2d_mcad13*/\
+ MUX_VAL(CP(D2D_MCAD14),	(IEN  | PTD | EN  | M0)) /*d2d_mcad14*/\
+ MUX_VAL(CP(D2D_MCAD15),	(IEN  | PTD | EN  | M0)) /*d2d_mcad15*/\
+ MUX_VAL(CP(D2D_MCAD16),	(IEN  | PTD | EN  | M0)) /*d2d_mcad16*/\
+ MUX_VAL(CP(D2D_MCAD17),	(IEN  | PTD | EN  | M0)) /*d2d_mcad17*/\
+ MUX_VAL(CP(D2D_MCAD18),	(IEN  | PTD | EN  | M0)) /*d2d_mcad18*/\
+ MUX_VAL(CP(D2D_MCAD19),	(IEN  | PTD | EN  | M0)) /*d2d_mcad19*/\
+ MUX_VAL(CP(D2D_MCAD20),	(IEN  | PTD | EN  | M0)) /*d2d_mcad20*/\
+ MUX_VAL(CP(D2D_MCAD21),	(IEN  | PTD | EN  | M0)) /*d2d_mcad21*/\
+ MUX_VAL(CP(D2D_MCAD22),	(IEN  | PTD | EN  | M0)) /*d2d_mcad22*/\
+ MUX_VAL(CP(D2D_MCAD23),	(IEN  | PTD | EN  | M0)) /*d2d_mcad23*/\
+ MUX_VAL(CP(D2D_MCAD24),	(IEN  | PTD | EN  | M0)) /*d2d_mcad24*/\
+ MUX_VAL(CP(D2D_MCAD25),	(IEN  | PTD | EN  | M0)) /*d2d_mcad25*/\
+ MUX_VAL(CP(D2D_MCAD26),	(IEN  | PTD | EN  | M0)) /*d2d_mcad26*/\
+ MUX_VAL(CP(D2D_MCAD27),	(IEN  | PTD | EN  | M0)) /*d2d_mcad27*/\
+ MUX_VAL(CP(D2D_MCAD28),	(IEN  | PTD | EN  | M0)) /*d2d_mcad28*/\
+ MUX_VAL(CP(D2D_MCAD29),	(IEN  | PTD | EN  | M0)) /*d2d_mcad29*/\
+ MUX_VAL(CP(D2D_MCAD30),	(IEN  | PTD | EN  | M0)) /*d2d_mcad30*/\
+ MUX_VAL(CP(D2D_MCAD31),	(IEN  | PTD | EN  | M0)) /*d2d_mcad31*/\
+ MUX_VAL(CP(D2D_MCAD32),	(IEN  | PTD | EN  | M0)) /*d2d_mcad32*/\
+ MUX_VAL(CP(D2D_MCAD33),	(IEN  | PTD | EN  | M0)) /*d2d_mcad33*/\
+ MUX_VAL(CP(D2D_MCAD34),	(IEN  | PTD | EN  | M0)) /*d2d_mcad34*/\
+ MUX_VAL(CP(D2D_MCAD35),	(IEN  | PTD | EN  | M0)) /*d2d_mcad35*/\
+ MUX_VAL(CP(D2D_MCAD36),	(IEN  | PTD | EN  | M0)) /*d2d_mcad36*/\
+ MUX_VAL(CP(D2D_CLK26MI),	(IEN  | PTD | DIS | M0)) /*d2d_clk26mi*/\
+ MUX_VAL(CP(D2D_NRESPWRON),	(IEN  | PTD | EN  | M0)) /*d2d_nrespwron*/\
+ MUX_VAL(CP(D2D_NRESWARM),	(IEN  | PTU | EN  | M0)) /*d2d_nreswarm */\
+ MUX_VAL(CP(D2D_ARM9NIRQ),	(IEN  | PTD | DIS | M0)) /*d2d_arm9nirq */\
+ MUX_VAL(CP(D2D_UMA2P6FIQ),	(IEN  | PTD | DIS | M0)) /*d2d_uma2p6fiq*/\
+ MUX_VAL(CP(D2D_SPINT),		(IEN  | PTD | EN  | M0)) /*d2d_spint*/\
+ MUX_VAL(CP(D2D_FRINT),		(IEN  | PTD | EN  | M0)) /*d2d_frint*/\
+ MUX_VAL(CP(D2D_DMAREQ0),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq0*/\
+ MUX_VAL(CP(D2D_DMAREQ1),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq1*/\
+ MUX_VAL(CP(D2D_DMAREQ2),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq2*/\
+ MUX_VAL(CP(D2D_DMAREQ3),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq3*/\
+ MUX_VAL(CP(D2D_N3GTRST),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtrst*/\
+ MUX_VAL(CP(D2D_N3GTDI),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdi*/\
+ MUX_VAL(CP(D2D_N3GTDO),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdo*/\
+ MUX_VAL(CP(D2D_N3GTMS),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtms*/\
+ MUX_VAL(CP(D2D_N3GTCK),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtck*/\
+ MUX_VAL(CP(D2D_N3GRTCK),	(IEN  | PTD | DIS | M0)) /*d2d_n3grtck*/\
+ MUX_VAL(CP(D2D_MSTDBY),	(IEN  | PTU | EN  | M0)) /*d2d_mstdby*/\
+ MUX_VAL(CP(D2D_SWAKEUP),	(IEN  | PTD | EN  | M0)) /*d2d_swakeup*/\
+ MUX_VAL(CP(D2D_IDLEREQ),	(IEN  | PTD | DIS | M0)) /*d2d_idlereq*/\
+ MUX_VAL(CP(D2D_IDLEACK),	(IEN  | PTU | EN  | M0)) /*d2d_idleack*/\
+ MUX_VAL(CP(D2D_MWRITE),	(IEN  | PTD | DIS | M0)) /*d2d_mwrite*/\
+ MUX_VAL(CP(D2D_SWRITE),	(IEN  | PTD | DIS | M0)) /*d2d_swrite*/\
+ MUX_VAL(CP(D2D_MREAD),		(IEN  | PTD | DIS | M0)) /*d2d_mread*/\
+ MUX_VAL(CP(D2D_SREAD),		(IEN  | PTD | DIS | M0)) /*d2d_sread*/\
+ MUX_VAL(CP(D2D_MBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_mbusflag*/\
+ MUX_VAL(CP(D2D_SBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_sbusflag*/\
+ MUX_VAL(CP(SDRC_CKE0),		(IDIS | PTU | EN  | M0)) /*sdrc_cke0*/\
+ MUX_VAL(CP(SDRC_CKE1),		(IDIS | PTU | EN  | M0)) /*sdrc_cke1*/
+
+#define MUX_LOGIC_HSUSB0_D5_GPIO_MUX()					\
+ MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M4)) /*GPIO_189*/
+
+#define MUX_LOGIC_HSUSB0_D5_DATA5()					\
+ MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA5*/
+
+#endif
diff -rupN u-boot-2010.06.orig/board/logicpd/alico/config.mk u-boot-2010.06.new/board/logicpd/alico/config.mk
--- u-boot-2010.06.orig/board/logicpd/alico/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/alico/config.mk	2010-06-25 11:38:14.000000000 -0700
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2009
+# Logic Product Development,<www.logicpd.com>
+#
+# LV SOM uses OMAP3 (ARM-CortexA8) cpu
+# see http://www.logicpd.com/ for more information on Logic Product Development
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+# Physical Address:
+# 8000'0000 (bank0)
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+
+# For use with external or internal boots.
+TEXT_BASE = 0x80e80000
diff -rupN u-boot-2010.06.orig/board/logicpd/alico/product_id.h u-boot-2010.06.new/board/logicpd/alico/product_id.h
--- u-boot-2010.06.orig/board/logicpd/alico/product_id.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/alico/product_id.h	2010-06-25 11:38:14.000000000 -0700
@@ -0,0 +1,92 @@
+/*
+ * (C) Copyright 2008
+ * Logic Produc Development, <www.logicpd.com>
+ * Peter Barada <peter.barada@logicpd.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#define LOGIC_HEADER_VERSION_0 0
+struct product_zone_0_rev_0 {
+	char header_version;
+	char part_number[11];
+	char revision;
+	char sn_week;
+	char sn_year;
+	char sn_site;
+	int sn_cnt;
+	char maturity;
+};
+
+#define LOGIC_HEADER_VERSION_1 1
+struct product_zone_0_rev_1 {
+	char header_version;
+	char part_number[11];
+	char reserved; // removed from revision 1
+	char sn_week;
+	char sn_year;
+	char sn_site;
+	int sn_cnt;
+	char maturity;
+	char wifi_trim;
+};
+
+struct product_id_data {
+	struct {
+		union {
+			struct product_zone_0_rev_0 pz_0r0;
+			struct product_zone_0_rev_1 pz_0r1;
+		} u_zone0;
+
+		struct {
+			char model_revision;
+			char model_number[31];
+		} zone1;
+
+		struct {
+			unsigned char mac[4][3];
+			char nor0_size;
+			char nor1_size;
+			char nand0_size;
+			char nand1_size;
+			char sdram0_size;
+			char sdram1_size;
+			short processor_type;
+			int features;
+			int platform_bits;
+		} zone2;
+	} d;
+	unsigned int checksum;
+};
+
+// Only calculate across the data to checksum, compare to stored
+// value(outside of checksummed range)
+static inline int calculate_checksum(void *p, int len)
+{
+	unsigned char *buf = p;
+	unsigned int xsum = 0;
+	int i;
+
+	for (i=0; i<len; ++i)
+		xsum = ((xsum << 3) || (xsum >> 29)) ^ buf[i];
+
+	return xsum;
+}
+
+extern int fetch_production_data(void);
+extern void dump_production_data(void);
+extern void board_get_nth_enetaddr (unsigned char *enetaddr, int which, int position);
+extern int productID_has_NOR_flash(void);
diff -rupN u-boot-2010.06.orig/board/logicpd/logic/Makefile u-boot-2010.06.new/board/logicpd/logic/Makefile
--- u-boot-2010.06.orig/board/logicpd/logic/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/logic/Makefile	2010-06-25 11:38:14.000000000 -0700
@@ -0,0 +1,49 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= logic.o logic-data.o logic-gpio.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+clean:
+	rm -f $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -rupN u-boot-2010.06.orig/board/logicpd/logic/config.mk u-boot-2010.06.new/board/logicpd/logic/config.mk
--- u-boot-2010.06.orig/board/logicpd/logic/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/logic/config.mk	2010-06-25 11:38:14.000000000 -0700
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2009
+# Logic Product Development,<www.logicpd.com>
+#
+# LV SOM uses OMAP3 (ARM-CortexA8) cpu
+# see http://www.logicpd.com/ for more information on Logic Product Development
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+# Physical Address:
+# 8000'0000 (bank0)
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+
+# For use with external or internal boots.
+TEXT_BASE = 0x80e80000
diff -rupN u-boot-2010.06.orig/board/logicpd/logic/logic-data.c u-boot-2010.06.new/board/logicpd/logic/logic-data.c
--- u-boot-2010.06.orig/board/logicpd/logic/logic-data.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/logic/logic-data.c	2010-06-25 11:38:14.000000000 -0700
@@ -0,0 +1,785 @@
+/*
+ * (C) Copyright 2008
+ * Logic Produc Development, <www.logicpd.com>
+ * Peter Barada <peter.barada@logicpd.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/arch/cpu.h>
+#include <asm/io.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/clocks.h>
+#include <asm/arch/mem.h>
+#include <i2c.h>
+#include <asm/mach-types.h>
+#include "product_id.h"
+#include "logic-gpio.h"
+
+// GPIO i2c code to access at88 chip
+
+enum {
+	RX_MODE_FIRST_BYTE,
+	RX_MODE_MIDDLE_BYTE,
+	RX_MODE_NEXT_TO_LAST_BYTE,
+	RX_MODE_LAST_BYTE,
+	RX_MODE_ONE_BYTE
+} I2C_RX_MODE;
+
+typedef enum {
+	GPIO_I2C_SDATA,
+	GPIO_I2C_SCLK,
+} GPIO_I2C_PIN;
+
+static enum {
+	GPIO_I2C_UNINIT,
+	GPIO_I2C_STOPPED,
+	GPIO_I2C_STARTED,
+} gpio_i2c_bus_state;
+
+typedef enum {
+	GPIO_I2C_INPUT,
+	GPIO_I2C_OUTPUT,
+} GPIO_I2C_DIRECTION;
+
+static int gpio_i2c_clock_high_width, gpio_i2c_clock_low_width;
+static int gpio_i2c_coarse_delay;
+
+#define DEBUG_PRODUCTION_DATA 0
+#define DEBUG_PRODUCTION_DATA_BUF 0
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ * The commented string gives the final mux configuration for that pin
+ */
+
+/* Put SCLK/SDA pins connected to the product ID into GPIO mode */
+static void gpio_i2c_config_pins(void)
+{
+	MUX_VAL(CP(I2C3_SCL),       (IEN  | PTU | EN  | M4)); /*I2C3_SCL*/
+	MUX_VAL(CP(I2C3_SDA),       (IEN  | PTU | EN  | M4)); /*I2C3_SDA*/
+}
+
+/* Restore SCLK/SDA pins connected to the product ID back to I2C mode */
+
+static void gpio_i2c_restore_pins(void)
+{
+	MUX_VAL(CP(I2C3_SCL),       (IEN  | PTU | EN  | M0)); /*I2C3_SCL*/
+	MUX_VAL(CP(I2C3_SDA),       (IEN  | PTU | EN  | M0)); /*I2C3_SDA*/
+}
+
+#define GPIO_I2C_GPIO_SCLK  184
+#define GPIO_I2C_GPIO_SDATA 185
+
+static void gpio_i2c_config_pin(GPIO_I2C_PIN pin, GPIO_I2C_DIRECTION dir)
+{
+	if (dir == GPIO_I2C_INPUT) {
+		if (pin == GPIO_I2C_SCLK)
+			pin_init_gpio(GPIO_I2C_GPIO_SCLK, 1);
+		else
+			pin_init_gpio(GPIO_I2C_GPIO_SDATA, 1);
+	} else if (dir == GPIO_I2C_OUTPUT) {
+		if (pin == GPIO_I2C_SCLK)
+			pin_init_gpio(GPIO_I2C_GPIO_SCLK, 0);
+		else
+			pin_init_gpio(GPIO_I2C_GPIO_SDATA, 0);
+	}
+}
+
+static int gpio_i2c_read_pin(GPIO_I2C_PIN pin)
+{
+	if (pin == GPIO_I2C_SCLK)
+		return pin_get_gpio_input(GPIO_I2C_GPIO_SCLK);
+	else
+		return pin_get_gpio_input(GPIO_I2C_GPIO_SDATA);
+	return 0;
+}
+
+static void gpio_i2c_set_pin_level(GPIO_I2C_PIN pin, int level)
+{
+	uint8_t pin_level;
+
+	if (pin == GPIO_I2C_SCLK) {
+		pin_level = pin_get_gpio_input(GPIO_I2C_GPIO_SCLK);
+		if (((level == 1) && (pin_level == 0)) ||
+		    ((level == 0) && (pin_level == 1)))
+			pin_set_gpio_dataout(GPIO_I2C_GPIO_SCLK, level);
+	} else if (pin == GPIO_I2C_SDATA) {
+		if (level == 0) {
+			gpio_i2c_config_pin(pin, GPIO_I2C_OUTPUT);
+			pin_set_gpio_dataout(GPIO_I2C_GPIO_SDATA, 0);
+		} else {
+			gpio_i2c_config_pin(pin, GPIO_I2C_INPUT);
+		}
+	}
+}
+
+
+static void gpio_i2c_init(int bps)
+{
+	gpio_i2c_bus_state = GPIO_I2C_UNINIT;
+
+	// Config SCLK, SDATA pins
+	gpio_i2c_config_pin(GPIO_I2C_SCLK, GPIO_I2C_OUTPUT);
+	gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+
+	gpio_i2c_config_pin(GPIO_I2C_SDATA, GPIO_I2C_INPUT);
+
+	gpio_i2c_config_pins();
+
+	// Assume 1:1 clock duty cycle
+	gpio_i2c_clock_high_width = gpio_i2c_clock_low_width
+	  = 1000000 / bps / 2;
+
+	gpio_i2c_coarse_delay = gpio_i2c_clock_high_width;
+}
+
+static int gpio_i2c_busy(void)
+{
+	return (gpio_i2c_bus_state == GPIO_I2C_STARTED);
+}
+
+static void gpio_i2c_tx_stop(void)
+{
+	if (gpio_i2c_bus_state == GPIO_I2C_STARTED) {
+		udelay(gpio_i2c_coarse_delay);
+
+		// Pull SDATA low
+		gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 0);
+		udelay(gpio_i2c_coarse_delay);
+
+		// Push SCLK high
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+		udelay(gpio_i2c_coarse_delay);
+
+		// Now drive SDATA high - thats a STOP.
+		gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 1);
+		udelay(gpio_i2c_coarse_delay);
+		gpio_i2c_bus_state = GPIO_I2C_STOPPED;
+	}
+}
+
+static void gpio_i2c_tx_start(void)
+{
+	if (gpio_i2c_bus_state == GPIO_I2C_UNINIT
+	    || gpio_i2c_bus_state == GPIO_I2C_STOPPED) {
+		udelay(gpio_i2c_coarse_delay);
+		gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 1);
+		udelay(gpio_i2c_coarse_delay);
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+		udelay(gpio_i2c_coarse_delay);
+		gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 0);
+		udelay(gpio_i2c_coarse_delay);
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 0);
+		udelay(gpio_i2c_coarse_delay);
+		gpio_i2c_bus_state = GPIO_I2C_STARTED;
+	}
+}
+
+// Return !0 if NACK
+static int gpio_i2c_tx_byte(uint8_t data)
+{
+	uint8_t clock, tx_bit_mask=0x80, nack;
+
+	if (gpio_i2c_bus_state != GPIO_I2C_STARTED)
+		printf("%s: Unexpected I2C bus state!\n", __FUNCTION__);
+
+	udelay(gpio_i2c_coarse_delay);
+
+	for (clock=0; clock <= 7; ++clock) {
+		if (data & tx_bit_mask)
+			gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 1);
+		else
+			gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 0);
+		udelay(gpio_i2c_clock_low_width);
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+		udelay(gpio_i2c_clock_high_width);
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 0);
+		tx_bit_mask >>= 1;
+	}
+	gpio_i2c_config_pin(GPIO_I2C_SDATA, GPIO_I2C_INPUT);
+	udelay(gpio_i2c_clock_low_width);
+	gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+	udelay(gpio_i2c_clock_high_width);
+	nack = gpio_i2c_read_pin(GPIO_I2C_SDATA);
+	gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 0);
+	return (nack != 0);
+}
+
+static int gpio_i2c_rx_byte(uint8_t *data, int rx_mode)
+{
+	uint8_t clock, data_bit;
+
+	*data = 0;
+
+	gpio_i2c_config_pin(GPIO_I2C_SDATA, GPIO_I2C_INPUT);
+
+	udelay(gpio_i2c_coarse_delay);
+
+	for (clock=0; clock<=8; ++clock) {
+		if (clock < 8) {
+			gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+			udelay(gpio_i2c_clock_high_width);
+			data_bit = gpio_i2c_read_pin(GPIO_I2C_SDATA);
+			gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 0);
+			*data = (*data << 1) | data_bit;
+		} else {
+			if ((rx_mode == RX_MODE_LAST_BYTE) || (rx_mode == RX_MODE_ONE_BYTE))
+				gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 1);
+			else
+				gpio_i2c_set_pin_level(GPIO_I2C_SDATA, 0);
+
+			gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+			udelay(gpio_i2c_clock_high_width);
+			gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 0);
+		}
+		udelay(gpio_i2c_clock_low_width);
+	}
+
+	return 0;
+}
+
+
+static int send_packet(uint8_t *data, int len, uint8_t *rxbuf, int rxlen)
+{
+	int timeout = 1000;
+	int retry;
+	int rx_mode;
+	int tick, err, idx;
+
+	if (DEBUG_PRODUCTION_DATA) {
+		char buf[3 * len + 2];
+		int i, offset;
+		for (offset = 0, i=0; i<len; ++i) {
+			if (!i)
+				offset = sprintf(buf, "%02x", data[i]);
+			else
+				offset += sprintf(&buf[offset], " %02x", data[i]);
+		}
+		printf("%s: %s\n", __FUNCTION__, buf);
+	}
+
+	// Wait for bus
+	while (gpio_i2c_busy() && timeout--)
+		udelay(100);
+
+	if (!timeout)
+		printf("%s:%d i2c_busy never return zero!\n", __FUNCTION__, __LINE__);
+
+	retry = 0;
+	do {
+		tick = 0;
+		do {
+			gpio_i2c_tx_stop();
+			gpio_i2c_tx_start();
+
+			// send cmd
+			err = gpio_i2c_tx_byte(data[0]);
+			tick++;
+		} while (err && tick < 100);
+
+		if (tick > 3)
+			printf("I2C ACK polling tick %d!\n", tick);
+
+		for (idx = 1; idx<len; ++idx) {
+			err = gpio_i2c_tx_byte(data[idx]);
+			if (err) {
+				printf("%s:%d NACK idx %d\n", __FUNCTION__, __LINE__, idx);
+			}
+		}
+	} while (err && (retry++ < 5));
+
+	if (err)
+		return err;
+
+	// Are we expecting a response?
+	if (rxbuf) {
+		for (idx = 0; idx < rxlen; ++idx) {
+			if (rxlen == 1)
+				rx_mode = RX_MODE_ONE_BYTE;
+			else if (idx == (rxlen - 1))
+				rx_mode = RX_MODE_LAST_BYTE;
+			else if (idx == (rxlen - 2))
+				rx_mode = RX_MODE_NEXT_TO_LAST_BYTE;
+			else if (idx == 0)
+				rx_mode = RX_MODE_FIRST_BYTE;
+			else
+				rx_mode = RX_MODE_MIDDLE_BYTE;
+
+			err = gpio_i2c_rx_byte(&rxbuf[idx], rx_mode);
+			if (DEBUG_PRODUCTION_DATA) {
+				if (err)
+					printf("%s:%d err idx %d\n", __FUNCTION__, __LINE__, idx);
+			}
+		}
+	}
+
+	gpio_i2c_tx_stop();
+	return err;
+}
+
+/*
+ * Identify the device
+ */
+struct device_param {
+	char *name;
+	unsigned char reset[8];	// ATR for part
+	unsigned int zones;		// number of zones
+	unsigned int zonesize;	// bytes per zone
+};
+
+static const struct device_param answers[] = {
+
+  {
+	.name = "AT88SC0104C",
+	.reset = {0x3B, 0xB2, 0x11, 0x00, 0x10, 0x80, 0x00, 0x01},
+	.zones = 4,
+	.zonesize = 32
+  },
+  {
+	.name = "AT88SC0204C",
+	.reset = {0x3B, 0xB2, 0x11, 0x00, 0x10, 0x80, 0x00, 0x02},
+	.zones = 4,
+	.zonesize = 64
+  },
+  {
+	.name = "AT88SC0404C",
+	.reset = {0x3B, 0xB2, 0x11, 0x00, 0x10, 0x80, 0x00, 0x04},
+	.zones = 4,
+	.zonesize = 128
+  },
+  {
+	.name = "AT88SC0808C",
+	.reset = {0x3B, 0xB2, 0x11, 0x00, 0x10, 0x80, 0x00, 0x08},
+	.zones = 8,
+	.zonesize = 128
+  },
+  {
+	.name = "AT88SC1616C",
+	.reset = {0x3B, 0xB2, 0x11, 0x00, 0x10, 0x80, 0x00, 0x16},
+	.zones = 16,
+	.zonesize = 128
+  },
+  {
+	.name = "AT88SC3216C",
+	.reset = {0x3B, 0xB3, 0x11, 0x00, 0x00, 0x00, 0x00, 0x32},
+	.zones = 16,
+	.zonesize = 256
+  },
+  {
+	.name = "AT88SC6416C",
+	.reset = {0x3B, 0xB3, 0x11, 0x00, 0x00, 0x00, 0x00, 0x64},
+	.zones = 16,
+	.zonesize = 512
+  },
+  {
+	.name = "AT88SC12816C",
+	.reset = {0x3B, 0xB3, 0x11, 0x00, 0x00, 0x00, 0x01, 0x28},
+	.zones = 16,
+	.zonesize = 1024
+  },
+  {
+	.name = "AT88SC25616C",
+	.reset = {0x3B, 0xB3, 0x11, 0x00, 0x00, 0x00, 0x02, 0x56},
+	.zones = 16,
+	.zonesize = 2048
+  },
+};
+
+static const struct device_param *devptr; /* pointer to ID'd device */
+
+#define CMD_SYSTEM_READ	0xB6
+
+static int
+identify_device(void)
+{
+	const struct device_param *p;
+	unsigned char cmd[] = { CMD_SYSTEM_READ, 0x00, 0x00, 0x00 };
+	unsigned char buf[8];
+	int err;
+	int i,j;
+
+	err = send_packet(cmd, sizeof(cmd), buf, sizeof(buf));
+	if (err)
+		return err;
+
+	if (DEBUG_PRODUCTION_DATA)
+		printf("%s: ident %02x %02x %02x %02x %02x %02x %02x %02x\n", __FUNCTION__,
+		       buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);
+
+	for (p=answers,i=0; i<sizeof(answers)/sizeof(answers[0]); ++i,++p) {
+		for (j=0; j<8 && (p->reset[j] == buf[j]); ++j)
+			;
+		if (j==8) {
+			devptr = p;
+
+		if (DEBUG_PRODUCTION_DATA)
+			printf("%s: device %s zones %u zonesize %u\n", __FUNCTION__,
+			       devptr->name, devptr->zones, devptr->zonesize);
+
+		return 0;
+		}
+	}
+
+	printf("%s: ID %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x unknown!\n", __FUNCTION__,
+	       buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);
+
+	return -1;
+}
+
+#define CMD_SYSTEM_WRITE    0xB4
+
+static int
+set_user_zone(int zone)
+{
+	unsigned char cmd[] = { CMD_SYSTEM_WRITE, 0x03, 0x00, 0x00 };
+
+	if (DEBUG_PRODUCTION_DATA)
+		printf("%s: zone %d\n", __FUNCTION__, zone);
+	cmd[2] = zone;
+	return send_packet(cmd, sizeof(cmd), NULL, 0);
+}
+
+#define CMD_READ_USER_ZONE  0xB2
+
+static int
+read_user_zone(unsigned int offset, unsigned char *buf, int len)
+{
+	unsigned char cmd[] = { CMD_READ_USER_ZONE, 0x00, 0x00, 0x00 };
+	int ret;
+	unsigned int startzone, endzone;
+
+	if (DEBUG_PRODUCTION_DATA)
+		printf("%s: offset %u len %d\n", __FUNCTION__, offset, len);
+
+	// abort if we're not in one zone, or past the end of the device
+	startzone = offset / devptr->zonesize;
+	endzone = (offset + (len - 1)) / devptr->zonesize;
+	if (startzone != endzone) {
+	  printf("%s: startzone %d != endzone %d (len %d, offset %d)\n", __FUNCTION__, startzone, endzone, offset, len);
+		return -1;
+	}  
+	if (endzone > devptr->zones) {
+		printf("%s: endzone %d > numzones\n", __FUNCTION__, endzone);
+		return -1;
+	}
+
+	// Set the zone
+	if (set_user_zone(startzone))
+		return -1;
+
+	cmd[2] = offset % devptr->zonesize;
+	cmd[3] = len;
+	ret = send_packet(cmd, sizeof(cmd), buf, len);
+
+	if (DEBUG_PRODUCTION_DATA_BUF) {
+		char obuf[128];
+		int i,j,offset;
+		for (i = 0, offset=0; i<len; i+=16) {
+			for (j = 0; j<16 && i+j<len; ++j)
+				if (!j)
+					offset = sprintf(obuf, "%02x", buf[i+j]);
+				else
+					offset += sprintf(&obuf[offset], " %02x", buf[i+j]);
+			printf("%s\n", obuf);
+		}
+	}
+	return ret;
+}
+
+#define XMK_STR(x)	#x
+#define MK_STR(x)	XMK_STR(x)
+int production_data_valid;
+
+struct product_id_data product_id_data;
+
+int valid_mac_address(unsigned char mac[3])
+{
+	if (mac[0] == 0xff && mac[1] == 0xff && mac[2] == 0xff)
+		return 0;
+	if (mac[0] == 0x00 && mac[1] == 0x00 && mac[2] == 0x00)
+		return 0;
+	return !0;
+}
+
+/*
+ * Extract/set an ethernet address.
+ * Which is the address in the environment, position is which MAC address
+ * in the product ID data
+ */
+void board_get_nth_enetaddr (unsigned char *enetaddr, int which, int position)
+{
+	unsigned char *mac = &product_id_data.d.zone2.mac[position][0];
+	char *s = NULL, *e;
+	int i;
+	char ethbuf[18];
+
+	// We only handle the first two interfaces (LAN/WiFi)...
+	if (which >= 2)
+		return;
+
+	if (DEBUG_PRODUCTION_DATA)
+		printf("%s: valid %d which %d %02x:%02x:%02x\n", __FUNCTION__,
+		       production_data_valid, which,
+		       mac[0], mac[1], mac[2]);
+
+	memset(enetaddr, '\0', 6);
+	if (!production_data_valid || 
+		!valid_mac_address(mac)) {
+		s = getenv("ethaddr");
+
+#ifdef CONFIG_ETHADDR
+		if (!s)
+			s = MK_STR(CONFIG_ETHADDR);
+#endif
+
+		/* If no ethaddr found in productID or environment, then punt*/
+		if (!s)
+			return;
+
+		for (i = 0; i < 6; ++i) {
+			enetaddr[i] = s ? simple_strtoul (s, &e, 16) : 0;
+			if (s)
+				s = (*e) ? e + 1 : e;
+		}
+		goto set_it;
+	}
+
+	// Use Logic's prefix
+	enetaddr[0] = 0x00;
+	enetaddr[1] = 0x08;
+	enetaddr[2] = 0xee;
+	enetaddr[3] = mac[0];
+	enetaddr[4] = mac[1];
+	enetaddr[5] = mac[2];
+
+ set_it:
+	if (which == 0) {
+		sprintf(ethbuf, "%02x:%02x:%02x:%02x:%02x:%02x", enetaddr[0], enetaddr[1], enetaddr[2], enetaddr[3], enetaddr[4], enetaddr[5]);
+		setenv("ethaddr", ethbuf);
+	} else {
+		char buf[32];
+		sprintf(ethbuf, "%02x:%02x:%02x:%02x:%02x:%02x", enetaddr[0], enetaddr[1], enetaddr[2], enetaddr[3], enetaddr[4], enetaddr[5]);
+		sprintf(buf, "eth%daddr", which);
+		setenv(buf, ethbuf);
+	}
+}
+
+static int extract_product_id_part_number(struct product_id_data *p, char *buf, int buflen)
+{
+	int size;
+
+	buf[0] = '\0';
+	if (p->d.u_zone0.pz_0r0.header_version == LOGIC_HEADER_VERSION_0) {
+		size = sizeof(p->d.u_zone0.pz_0r0.part_number);
+		if (buflen < sizeof(p->d.u_zone0.pz_0r0.part_number))
+			size = buflen;
+		strncpy(buf, p->d.u_zone0.pz_0r0.part_number, sizeof(p->d.u_zone0.pz_0r0.part_number));
+		buf[sizeof(p->d.u_zone0.pz_0r0.part_number)] = '\0';
+		return 0;
+	}
+
+	if (p->d.u_zone0.pz_0r0.header_version == LOGIC_HEADER_VERSION_1) {
+		size = sizeof(p->d.u_zone0.pz_0r1.part_number);
+		if (buflen < sizeof(p->d.u_zone0.pz_0r1.part_number))
+			size = buflen;
+		strncpy(buf, p->d.u_zone0.pz_0r1.part_number, sizeof(p->d.u_zone0.pz_0r1.part_number));
+		buf[sizeof(p->d.u_zone0.pz_0r1.part_number)] = '\0';
+		return 0;
+	}
+
+	return -1;
+}
+
+
+static int extract_header_version(struct product_id_data *p, int *header_version)
+{
+	if (p->d.u_zone0.pz_0r0.header_version == LOGIC_HEADER_VERSION_0) {
+		*header_version = p->d.u_zone0.pz_0r0.header_version;
+		return 0;
+	}
+
+	if (p->d.u_zone0.pz_0r1.header_version == LOGIC_HEADER_VERSION_1) {
+		*header_version = p->d.u_zone0.pz_0r1.header_version;
+		return 0;
+	}
+
+	*header_version = p->d.u_zone0.pz_0r0.header_version;
+	return -1;
+  
+}
+
+static int extract_serial_number(struct product_id_data *p, char *buf, int buflen)
+{
+	buf[0] = '\0';
+	if (p->d.u_zone0.pz_0r0.header_version == LOGIC_HEADER_VERSION_0) {
+		sprintf(buf, "%02d%02d%c%05d", p->d.u_zone0.pz_0r0.sn_week,
+			 p->d.u_zone0.pz_0r0.sn_year, p->d.u_zone0.pz_0r0.sn_site,
+			 p->d.u_zone0.pz_0r0.sn_cnt);
+		return 0;
+	}
+	if (p->d.u_zone0.pz_0r1.header_version == LOGIC_HEADER_VERSION_1) {
+		sprintf(buf, "%02d%02d%c%05d", p->d.u_zone0.pz_0r1.sn_week,
+			 p->d.u_zone0.pz_0r1.sn_year, p->d.u_zone0.pz_0r1.sn_site,
+			 p->d.u_zone0.pz_0r1.sn_cnt);
+		return 0;
+	}
+	return -1;
+}
+
+static void extract_model_number_revision(struct product_id_data *p, char *buf, int buflen)
+{
+	int i;
+
+	strncpy(buf, product_id_data.d.zone1.model_number, buflen);
+	buf[buflen-1] = '\0';
+	i = strlen(buf);
+	if (i && (i + 3 < buflen)) {
+		buf[i] = '-';
+		buf[i+1] = product_id_data.d.zone1.model_revision;
+		buf[i+2] = '\0';
+	}
+}
+
+/* Return positive non-zero if productID indicates there's
+ * NOR flash on the device - return is size of flash as log2 in bytes */
+int productID_has_NOR_flash(void)
+{
+	if (!production_data_valid)
+		return -1;
+
+	/* Flash exists if its size is non-zero, but 0xff is known to be
+	 * a non-programmed value */
+	if (product_id_data.d.zone2.nor0_size == 0x00
+	    || product_id_data.d.zone2.nor0_size == 0xff)
+		return 0;
+
+	return product_id_data.d.zone2.nor0_size;
+}
+
+int fetch_production_data(void)
+{
+	int err = 0;
+	int header_version;
+	int checksum;
+	int i;
+
+	// Make sure voltage is to productID chip!
+	gpio_i2c_init(50000);
+
+	/* The productID chip wants at least 5 clocks to wake it up... */
+	gpio_i2c_config_pin(GPIO_I2C_SCLK, GPIO_I2C_OUTPUT);
+	gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+	for (i=0; i<10; ++i) {
+		udelay(100);
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 0);
+		udelay(100);
+		gpio_i2c_set_pin_level(GPIO_I2C_SCLK, 1);
+	}
+
+	printf("Read production data: ");
+
+	if (identify_device()) {
+		printf("failed to identify device!\n");
+		err = -1;
+		goto out;
+	}
+
+	if (read_user_zone(0, (unsigned char *)&product_id_data.d.u_zone0, sizeof(product_id_data.d.u_zone0))) {
+		printf("failed!\n");
+		err = -1;
+		goto out;
+	}
+
+	// If the header doesn't match, we can't map any of the data
+	if (extract_header_version(&product_id_data, &header_version)) {
+		printf("failed - invalid header version %d!\n", header_version);
+		err = -2;
+		goto out;
+	}
+
+	if (read_user_zone(32, (unsigned char *)&product_id_data.d.zone1, sizeof(product_id_data.d.zone1))) {
+		printf("failed!\n");
+		err = -3;
+		goto out;
+	}
+
+	if (read_user_zone(64, (unsigned char *)&product_id_data.d.zone2, sizeof(product_id_data.d.zone2))) {
+		printf("failed!\n");
+		err = -4;
+		goto out;
+	}
+
+	printf("done\n");
+
+	// Correct endianess issues
+	product_id_data.d.zone2.processor_type = le16_to_cpu(product_id_data.d.zone2.processor_type);
+	product_id_data.d.zone2.features = le32_to_cpu(product_id_data.d.zone2.features);
+	product_id_data.d.zone2.platform_bits = le32_to_cpu(product_id_data.d.zone2.platform_bits);
+
+ out:
+	production_data_valid = !err;
+
+	// Restore pins back to their intended use
+	gpio_i2c_restore_pins();
+
+	// Clone the production data into SRAM
+	checksum = calculate_checksum(&product_id_data.d, sizeof(product_id_data.d));
+	product_id_data.checksum = checksum;
+	*(struct product_id_data *)(SRAM_BASE) = product_id_data;
+
+	return err;
+}
+
+void dump_production_data(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	char buf[36];
+
+	if (!production_data_valid)
+		return;
+
+	// Print out the name, model number, and set MAC addresses
+	extract_product_id_part_number(&product_id_data, buf, sizeof(buf));
+
+	printf("Part Number  : %s\n", buf);
+	extract_model_number_revision(&product_id_data, buf, sizeof(buf));
+	if (strlen(buf))
+		printf("Model Name   : %s\n", buf);
+	extract_serial_number(&product_id_data, buf, sizeof(buf));
+	printf("Serial Number: %s\n", buf);
+	if (valid_mac_address(product_id_data.d.zone2.mac[1]))
+		printf("Wired Lan MAC: 00:08:ee:%02x:%02x:%02x\n",
+			product_id_data.d.zone2.mac[0][0],
+			product_id_data.d.zone2.mac[0][1],
+			product_id_data.d.zone2.mac[0][2]);
+
+	if (gd->bd->bi_arch_number == MACH_TYPE_OMAP3530_LV_SOM)
+		if (valid_mac_address(product_id_data.d.zone2.mac[1]))
+			printf("Wirless   MAC: 00:08:ee:%02x:%02x:%02x\n",
+				product_id_data.d.zone2.mac[1][0],
+				product_id_data.d.zone2.mac[1][1],
+				product_id_data.d.zone2.mac[1][2]);
+}
diff -rupN u-boot-2010.06.orig/board/logicpd/logic/logic-gpio.c u-boot-2010.06.new/board/logicpd/logic/logic-gpio.c
--- u-boot-2010.06.orig/board/logicpd/logic/logic-gpio.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/logic/logic-gpio.c	2010-06-25 11:38:14.000000000 -0700
@@ -0,0 +1,161 @@
+/*
+ * (C) Copyright 2008
+ * Logic Produc Development, <www.logicpd.com>
+ * Peter Barada <peter.barada@logicpd.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/cpu.h>
+#include <asm/io.h>
+// #include <asm/arch/bits.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+// #include <asm/arch/sys_info.h>
+#include <asm/arch/clocks.h>
+#include <asm/arch/mem.h>
+#include <i2c.h>
+#include <asm/mach-types.h>
+#include "logic-gpio.h"
+
+#define NUM_OF_BITS_IN_REG                 32
+#define MAX_GPIO_PINS                      192
+#define GPIO_PIN                           1
+#define GPIO_MAX_MODULES			       6
+
+/* GPIO base address */
+#define	GPIO1_MODULE_BA                    0x48310000
+#define	GPIO2_MODULE_BA                    0x49050000
+#define GPIO3_MODULE_BA                    0x49052000
+#define GPIO4_MODULE_BA                    0x49054000
+#define GPIO5_MODULE_BA                    0x49056000
+#define GPIO6_MODULE_BA                    0x49058000
+
+#define GPIO_DATAIN			((uint32_t)0x038)
+#define GPIO_DATAOUT			((uint32_t)0x03C)
+#define GPIO_OE				((uint32_t)0x034)
+
+/* int and long both fit to 32 bits */
+typedef volatile uint32_t*  PREG_U32;
+typedef volatile int32_t*  PREG_S32;
+
+#define in_regl(offSet)			(*(PREG_U32)(offSet))
+#define out_regl(offSet, value)       (*(PREG_U32)(offSet) = (uint32_t)(value))
+
+static uint32_t g_gpio_module_base_address[GPIO_MAX_MODULES]
+				= {GPIO1_MODULE_BA, GPIO2_MODULE_BA, GPIO3_MODULE_BA,
+					 GPIO4_MODULE_BA, GPIO5_MODULE_BA, GPIO6_MODULE_BA};
+
+uint32_t check_gpio_pin_num(uint32_t pin_num)
+{
+  return (pin_num > MAX_GPIO_PINS);
+}
+
+uint32_t get_module_pin_mask(uint32_t pin_num, uint32_t *module_num, uint32_t *offset, uint32_t *pinmask)
+{
+  uint32_t snum, ret_val;
+
+  *module_num = pin_num / NUM_OF_BITS_IN_REG + 1;
+  snum = (*module_num-1)*NUM_OF_BITS_IN_REG;
+  *offset = pin_num - snum;
+  ret_val = check_gpio_pin_num(pin_num);
+  if (ret_val)
+    return ret_val;
+
+  *pinmask = GPIO_PIN<<*offset;
+  return 0;
+}
+
+
+void gpio_write_output_pin(int module_num, uint32_t pin_mask, uint32_t data)
+{
+  uint32_t temp, gpio_data_out_reg;
+
+  gpio_data_out_reg = (g_gpio_module_base_address[module_num-1]+GPIO_DATAOUT);
+
+  temp = in_regl(gpio_data_out_reg);
+  temp = temp & ~pin_mask;
+
+  out_regl(gpio_data_out_reg, (temp | (data & pin_mask)));
+}
+
+void gpio_read_input_pin(uint32_t module_num, uint32_t pin_mask, uint32_t *data)
+{
+  uint32_t gpio_data_in_reg, temp;
+
+  gpio_data_in_reg = (g_gpio_module_base_address[module_num-1]+GPIO_DATAIN);
+
+  temp = in_regl(gpio_data_in_reg);
+  *data = temp & pin_mask;
+}
+
+uint32_t pin_get_gpio_input(uint32_t pin_num)
+{
+  uint32_t module_num, pinmask, offset, data;
+
+  get_module_pin_mask(pin_num, &module_num, &offset, &pinmask);
+
+  gpio_read_input_pin(module_num, (1<<offset), &data);
+  data >>= offset;
+
+  // printf("%s:%d pin %d data %d\n", __FUNCTION__, __LINE__, pin_num, data);
+
+  return data;
+}
+
+
+uint32_t pin_set_gpio_dataout(uint32_t pin_num, uint32_t set)
+{
+  uint32_t module_num, pinmask, offset, ret_val;
+
+  // printf("%s:%d pin %d set %d\n", __FUNCTION__, __LINE__, pin_num, set);
+
+  ret_val = get_module_pin_mask(pin_num, &module_num, &offset, &pinmask);
+
+  if (set)
+    gpio_write_output_pin(module_num, (1<<offset), (1<<offset));
+  else
+    gpio_write_output_pin(module_num, (1<<offset), (0<<offset));
+
+  return ret_val;
+}
+
+uint32_t set_gpio_in_out(uint32_t module_num, uint32_t pin_mask, uint32_t io_mask)
+{
+  uint32_t temp_oe, gpio_pin_output_en_reg;
+
+  gpio_pin_output_en_reg = (g_gpio_module_base_address[module_num-1]+GPIO_OE);
+
+  temp_oe = in_regl(gpio_pin_output_en_reg);
+  temp_oe &= ~pin_mask;
+  temp_oe |= io_mask;
+
+  out_regl(gpio_pin_output_en_reg, temp_oe);
+
+  return 0;
+}
+
+uint32_t pin_init_gpio(uint32_t pin_num, uint32_t in_out)
+{
+	uint32_t module_num, pinmask, offset, ret_val;
+
+	ret_val = get_module_pin_mask(pin_num, &module_num, &offset, &pinmask);
+
+	set_gpio_in_out(module_num, pinmask, in_out<<offset);
+
+	return ret_val;
+}
diff -rupN u-boot-2010.06.orig/board/logicpd/logic/logic-gpio.h u-boot-2010.06.new/board/logicpd/logic/logic-gpio.h
--- u-boot-2010.06.orig/board/logicpd/logic/logic-gpio.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/logic/logic-gpio.h	2010-06-25 11:38:14.000000000 -0700
@@ -0,0 +1,7 @@
+// GPIO
+extern unsigned int pin_get_gpio_input(unsigned int pin);
+extern unsigned int pin_set_gpio_dataout(unsigned int pin, unsigned int set);
+extern unsigned int pin_init_gpio(unsigned int pin_num, unsigned int in_out);
+
+// Turn on VAUX1 voltage for Product ID
+extern void init_vaux1_voltage(void);
diff -rupN u-boot-2010.06.orig/board/logicpd/logic/logic.c u-boot-2010.06.new/board/logicpd/logic/logic.c
--- u-boot-2010.06.orig/board/logicpd/logic/logic.c	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/logic/logic.c	2010-07-26 17:22:49.000000000 -0700
@@ -0,0 +1,458 @@
+/*
+ * (C) Copyright 2009
+ * Logic Product Development, <www.logicpd.com>
+ *
+ * Author :
+ *	Peter Barada <peterb@logicpd.com>
+ *
+ * Derived from Beagle Board and 3430 SDP code by
+ *	Richard Woodruff <r-woodruff2@ti.com>
+ *	Syed Mohammed Khasim <khasim@ti.com>
+ *
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <netdev.h>
+#include <twl4030.h>
+#include <asm/io.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/gpio.h>
+#include <asm/mach-types.h>
+#include "logic.h"
+#include "product_id.h"
+#include <nand.h>
+
+/*
+ * Routine: logic_identify
+ * Description: Detect if we are running on a Logic or Torpedo.
+ *              This can be done by GPIO_189. If its low after driving it high,
+ *              then its an LOGIC, else Torpedo.
+ */
+unsigned int logic_identify(void)
+{
+	unsigned int val = 0;
+	int i;
+
+	MUX_LOGIC_HSUSB0_D5_GPIO_MUX();
+
+	if (!omap_request_gpio(189)) {
+
+		omap_set_gpio_direction(189, 0);
+		omap_set_gpio_dataout(189, 1);
+
+		// Let it soak for a bit
+		for (i=0; i<0x100; ++i)
+			asm("nop");
+
+		omap_set_gpio_direction(189, 1);
+		val = omap_get_gpio_datain(189);
+		omap_free_gpio(189);
+
+		printf("Board: ");
+		if (val) {
+			printf("Torpedo\n");
+			val = MACH_TYPE_OMAP3_TORPEDO;
+		} else {
+			printf("LV SOM\n");
+			val = MACH_TYPE_OMAP3530_LV_SOM;
+		}
+	}
+	return val;
+}
+
+
+#define LOGIC_NAND_GPMC_CONFIG1	0x00001800
+#define LOGIC_NAND_GPMC_CONFIG2	0x00070700
+#define LOGIC_NAND_GPMC_CONFIG3	0x00070700
+#define LOGIC_NAND_GPMC_CONFIG4	0x05000500
+#define LOGIC_NAND_GPMC_CONFIG5	0x00060707
+#define LOGIC_NAND_GPMC_CONFIG6	0x000002CF
+#define LOGIC_NAND_GPMC_CONFIG7	0x00000C70
+
+static void setup_nand_settings(void)
+{
+	/* Configure GPMC registers */
+	writel(0x00000000, &gpmc_cfg->cs[0].config7);
+	sdelay(1000);
+	writel(LOGIC_NAND_GPMC_CONFIG1, &gpmc_cfg->cs[0].config1);
+	writel(LOGIC_NAND_GPMC_CONFIG2, &gpmc_cfg->cs[0].config2);
+	writel(LOGIC_NAND_GPMC_CONFIG3, &gpmc_cfg->cs[0].config3);
+	writel(LOGIC_NAND_GPMC_CONFIG4, &gpmc_cfg->cs[0].config4);
+	writel(LOGIC_NAND_GPMC_CONFIG5, &gpmc_cfg->cs[0].config5);
+	writel(LOGIC_NAND_GPMC_CONFIG6, &gpmc_cfg->cs[0].config6);
+	writel(LOGIC_NAND_GPMC_CONFIG7, &gpmc_cfg->cs[0].config7);
+	sdelay(2000);
+}
+
+#define LOGIC_CF_GPMC_CONFIG1	0x00001210
+#define LOGIC_CF_GPMC_CONFIG2	0x00131000
+#define LOGIC_CF_GPMC_CONFIG3	0x001f1f01
+#define LOGIC_CF_GPMC_CONFIG4	0x10030e03
+#define LOGIC_CF_GPMC_CONFIG5	0x010f1411
+#define LOGIC_CF_GPMC_CONFIG6	0x80030600
+#define LOGIC_CF_GPMC_CONFIG7	0x00000f58
+
+static void setup_cf_gpmc_setup(void)
+{
+	/* Configure GPMC registers */
+	writel(0x00000000, &gpmc_cfg->cs[3].config7);
+	sdelay(1000);
+	writel(LOGIC_CF_GPMC_CONFIG1, &gpmc_cfg->cs[3].config1);
+	writel(LOGIC_CF_GPMC_CONFIG2, &gpmc_cfg->cs[3].config2);
+	writel(LOGIC_CF_GPMC_CONFIG3, &gpmc_cfg->cs[3].config3);
+	writel(LOGIC_CF_GPMC_CONFIG4, &gpmc_cfg->cs[3].config4);
+	writel(LOGIC_CF_GPMC_CONFIG5, &gpmc_cfg->cs[3].config5);
+	writel(LOGIC_CF_GPMC_CONFIG6, &gpmc_cfg->cs[3].config6);
+	writel(LOGIC_CF_GPMC_CONFIG7, &gpmc_cfg->cs[3].config7);
+	sdelay(2000);
+}
+
+/*
+ * Routine: board_init
+ * Description: Early hardware init.
+ */
+int board_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	gpmc_init(); /* in SRAM or SDRAM, finish GPMC */
+
+	/* Update NAND settings */
+	setup_nand_settings();
+
+#if 0
+	/* Update CF settings */
+	setup_cf_gpmc_setup();
+#endif
+
+	/* board id for Linux (placeholder until can ID board) */
+	gd->bd->bi_arch_number = MACH_TYPE_OMAP3530_LV_SOM;
+	/* boot param addr */
+	gd->bd->bi_boot_params = (OMAP34XX_SDRC_CS0 + 0x100);
+
+	return 0;
+}
+
+static void setup_net_chip(void);
+static void setup_isp1760_chip(void);
+static void fix_flash_sync(void);
+
+/* Turn on VAUX1 voltage to 3.0 volts to drive level shifters and
+ * power 3.0v parts (tsc2004 and Product ID chip) */
+#define I2C_TRITON2 0x4b /* Address of Triton power group */
+
+void init_vaux1_voltage(void)
+{
+#ifdef CONFIG_DRIVER_OMAP34XX_I2C
+	unsigned char data;
+	unsigned short msg;
+
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+
+	// Select the output voltage
+	data = 0x04;
+	i2c_write(I2C_TRITON2, 0x72, 1, &data, 1);
+	// Select the Processor resource group
+	data = 0x20;
+	i2c_write(I2C_TRITON2, 0x72, 1, &data, 1);
+	// Enable I2C access to the Power bus
+	data = 0x02;
+	i2c_write(I2C_TRITON2, 0x4a, 1, &data, 1);
+	// Send message MSB
+	msg = (1<<13) | (1<<4) | (0xd<<0); // group(process_grp1):resource(vaux1):res_active;
+	data = msg >> 8;
+	i2c_write(I2C_TRITON2, 0x4b, 1, &data, 1);
+	// Send message LSB
+	data = msg & 0xff;
+	i2c_write(I2C_TRITON2, 0x4c, 1, &data, 1);
+#endif
+}
+
+/*
+ * Routine: misc_init_r
+ * Description: Configure board specific parts
+ */
+int misc_init_r(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	struct gpio *gpio5_base = (struct gpio *)OMAP34XX_GPIO5_BASE;
+	struct gpio *gpio6_base = (struct gpio *)OMAP34XX_GPIO6_BASE;
+
+#ifdef CONFIG_DRIVER_OMAP34XX_I2C
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+#endif
+
+	/* Turn on vaux1 to make sure voltage is to the product ID chip.
+	 * Extract production data from ID chip, used to selectively
+	 * initialize portions of the system */
+	init_vaux1_voltage();
+	fetch_production_data();
+
+#if defined(CONFIG_CMD_NET)
+	setup_net_chip();
+#endif
+
+	/* Setup access to the isp1760 chip on CS6 */
+	setup_isp1760_chip();
+
+	twl4030_power_init();
+
+	/* kc: 07/26/2010 */
+	twl4030_led_init(TWL4030_LED_LEDEN_LEDAON | TWL4030_LED_LEDEN_LEDBON);
+
+
+	/* Configure GPIOs to output */
+	writel(~(GPIO23 | GPIO10 | GPIO8 | GPIO2 | GPIO1), &gpio6_base->oe);
+	writel(~(GPIO31 | GPIO30 | GPIO29 | GPIO28 | GPIO22 | GPIO21 |
+		GPIO15 | GPIO14 | GPIO13 | GPIO12), &gpio5_base->oe);
+
+	/* Set GPIOs */
+	writel(GPIO23 | GPIO10 | GPIO8 | GPIO2 | GPIO1,
+		&gpio6_base->setdataout);
+	writel(GPIO31 | GPIO30 | GPIO29 | GPIO28 | GPIO22 | GPIO21 |
+		GPIO15 | GPIO14 | GPIO13 | GPIO12, &gpio5_base->setdataout);
+
+	gd->bd->bi_arch_number = logic_identify();
+
+	/* Fix the flash sync */
+	fix_flash_sync();
+
+	dieid_num_r();
+
+	return 0;
+}
+
+
+/******************************************************************************
+ * Routine: late_board_init
+ * Description: Late hardware init.
+ *****************************************************************************/
+int board_late_init(void)
+{
+	unsigned char enetaddr[6];
+
+	// DECLARE_GLOBAL_DATA_PTR;
+
+	dump_production_data(); // Dump production data
+
+	// Fetch the ethaddr of the LAN
+	board_get_nth_enetaddr(enetaddr, 0, 0);
+#ifdef CONFIG_HAS_ETH1
+	// Fetch the ethaddr of the WiFi
+	board_get_nth_enetaddr(enetaddr, 1, 1);
+#endif
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	// Unlock the whole chip
+	nand_unlock(&nand_info[0], 0x0, nand_info[0].size);
+#endif
+	return 0;
+}
+
+/*
+ * Routine: set_muxconf_regs
+ * Description: Setting up the configuration Mux registers specific to the
+ *		hardware. Many pins need to be moved from protect to primary
+ *		mode.
+ */
+void set_muxconf_regs(void)
+{
+	MUX_LOGIC();
+}
+
+// GPMC settings for LV SOM Ethernet chip
+#define LOGIC_NET_GPMC_CONFIG1  0x00001000
+#define LOGIC_NET_GPMC_CONFIG2  0x00080701
+#define LOGIC_NET_GPMC_CONFIG3  0x00000000
+#define LOGIC_NET_GPMC_CONFIG4  0x08010702
+#define LOGIC_NET_GPMC_CONFIG5  0x00080a0a
+#define LOGIC_NET_GPMC_CONFIG6  0x03000280
+#define LOGIC_NET_GPMC_CONFIG7  0x00000f48
+
+/*
+ * Routine: setup_net_chip
+ * Description: Setting up the configuration GPMC registers specific to the
+ *		Ethernet hardware.
+ */
+static void setup_net_chip(void)
+{
+	struct ctrl *ctrl_base = (struct ctrl *)OMAP34XX_CTRL_BASE;
+
+	/* Configure GPMC registers */
+	writel(LOGIC_NET_GPMC_CONFIG1, &gpmc_cfg->cs[1].config1);
+	writel(LOGIC_NET_GPMC_CONFIG2, &gpmc_cfg->cs[1].config2);
+	writel(LOGIC_NET_GPMC_CONFIG3, &gpmc_cfg->cs[1].config3);
+	writel(LOGIC_NET_GPMC_CONFIG4, &gpmc_cfg->cs[1].config4);
+	writel(LOGIC_NET_GPMC_CONFIG5, &gpmc_cfg->cs[1].config5);
+	writel(LOGIC_NET_GPMC_CONFIG6, &gpmc_cfg->cs[1].config6);
+	writel(LOGIC_NET_GPMC_CONFIG7, &gpmc_cfg->cs[1].config7);
+
+	/* Enable off mode for NWE in PADCONF_GPMC_NWE register */
+	writew(readw(&ctrl_base ->gpmc_nwe) | 0x0E00, &ctrl_base->gpmc_nwe);
+	/* Enable off mode for NOE in PADCONF_GPMC_NADV_ALE register */
+	writew(readw(&ctrl_base->gpmc_noe) | 0x0E00, &ctrl_base->gpmc_noe);
+	/* Enable off mode for ALE in PADCONF_GPMC_NADV_ALE register */
+	writew(readw(&ctrl_base->gpmc_nadv_ale) | 0x0E00,
+		&ctrl_base->gpmc_nadv_ale);
+
+}
+
+// GPMC settings for LOGIC 1760 chip
+#define LOGIC_ISP1760_GPMC_CONFIG1  0x00001200
+#define LOGIC_ISP1760_GPMC_CONFIG2  0x00090901
+#define LOGIC_ISP1760_GPMC_CONFIG3  0x00091001
+#define LOGIC_ISP1760_GPMC_CONFIG4  0x07031002
+#define LOGIC_ISP1760_GPMC_CONFIG5  0x00080c0a
+#define LOGIC_ISP1760_GPMC_CONFIG6  0x08030200
+#define LOGIC_ISP1760_GPMC_CONFIG7  0x00000f5c
+
+/*
+ * Routine: setup_isp1760_chip
+ * Description: Setting up the configuration GPMC registers specific to the
+ *		ISP1760 USB hardware.
+ */
+static void setup_isp1760_chip(void)
+{
+	/* Configure GPMC registers */
+	writel(LOGIC_ISP1760_GPMC_CONFIG1, &gpmc_cfg->cs[6].config1);
+	writel(LOGIC_ISP1760_GPMC_CONFIG2, &gpmc_cfg->cs[6].config2);
+	writel(LOGIC_ISP1760_GPMC_CONFIG3, &gpmc_cfg->cs[6].config3);
+	writel(LOGIC_ISP1760_GPMC_CONFIG4, &gpmc_cfg->cs[6].config4);
+	writel(LOGIC_ISP1760_GPMC_CONFIG5, &gpmc_cfg->cs[6].config5);
+	writel(LOGIC_ISP1760_GPMC_CONFIG6, &gpmc_cfg->cs[6].config6);
+	writel(LOGIC_ISP1760_GPMC_CONFIG7, &gpmc_cfg->cs[6].config7);
+}
+
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG1	0x00001211
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG2	0x00080901
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG3	0x00020201
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG4	0x08010901
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG5	0x0008090a
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG6	0x08030200
+#define LOGIC_STNOR_ASYNC_GPMC_CONFIG7	0x00000c50
+
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG1	0x68411213
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG2	0x000C1502
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG3	0x00040402
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG4	0x0B051505
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG5	0x020E0C15
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG6	0x0B0603C3
+#define LOGIC_STNOR_SYNC_GPMC_CONFIG7	0x00000c50
+
+#define LOGIC_FLASH_BASE 0x10000000
+
+/* These are bit definitions for the RCR register of the NOR flash       */
+/* 28FxxxP30 device.  This register sets the bus configration for reads. */
+/* settings, located on address pins A[15:0].                            */
+#define FLASH_28FxxxP30_RCR_RM    0x8000
+#define FLASH_28FxxxP30_RCR_R     0x4000
+#define FLASH_28FxxxP30_RCR_LC(x) ((x & 0x7) << 11)
+#define FLASH_28FxxxP30_RCR_WP    0x0400
+#define FLASH_28FxxxP30_RCR_DH    0x0200
+#define FLASH_28FxxxP30_RCR_WD    0x0100
+#define FLASH_28FxxxP30_RCR_BS    0x0080
+#define FLASH_28FxxxP30_RCR_CE    0x0040
+#define FLASH_28FxxxP30_RCR_BW    0x0008
+#define FLASH_28FxxxP30_RCR_BL(x) ((x & 0x7) << 0)
+#define FLASH_28FxxxP30_BL_4      0x1
+#define FLASH_28FxxxP30_BL_8      0x2
+#define FLASH_28FxxxP30_BL_16     0x3
+#define FLASH_28FxxxP30_BL_CONT   0x7
+
+/*
+ * Routine: fix_flash_sync
+ * Description: Setting up the configuration GPMC registers specific to the
+ *		NOR flash (and place in sync mode if not done).
+ */
+static void fix_flash_sync(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	int arch_number;
+	u16 rcrval;
+
+	/* Check the arch_number - Torpedo doesn't have NOR flash */
+	arch_number = gd->bd->bi_arch_number;
+	if (arch_number == MACH_TYPE_OMAP3_TORPEDO)
+		return;
+
+	/* If no NOR in product, then return */
+	if (productID_has_NOR_flash() <= 0) {
+		printf("NOR: None installed\n");
+		return;
+	}
+
+	/* Check CS2 config, if its already in sync, then return */
+	if (!(readl(&gpmc_cfg->cs[2].config1) & TYPE_READTYPE)) {
+		puts("NOR: initialize in sync mode\n");
+
+		/* clear WAIT1 polarity */
+		writel(readl(&gpmc_cfg->config) & ~0x200, &gpmc_cfg->config);
+
+		/* clear GPMC_TIMEOUT */
+		writel(0x0, &gpmc_cfg->timeout_control);
+
+		/* Configure GPMC registers for async */
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG1, &gpmc_cfg->cs[2].config1);
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG2, &gpmc_cfg->cs[2].config2);
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG3, &gpmc_cfg->cs[2].config3);
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG4, &gpmc_cfg->cs[2].config4);
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG5, &gpmc_cfg->cs[2].config5);
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG6, &gpmc_cfg->cs[2].config6);
+		writel(LOGIC_STNOR_ASYNC_GPMC_CONFIG7, &gpmc_cfg->cs[2].config7);
+
+		/* 1st NOR cycle, send read config register setup 0x60 */
+		*(volatile u16 *)LOGIC_FLASH_BASE = 0x0060;
+
+		/* 2nd NOR cycle, send 0x03 to latch in read
+		 * configuration register setttings, located on A[15:0] */
+		rcrval = FLASH_28FxxxP30_RCR_LC(4) | FLASH_28FxxxP30_RCR_WP |
+		  FLASH_28FxxxP30_RCR_BS | FLASH_28FxxxP30_RCR_CE |
+		  FLASH_28FxxxP30_RCR_BW | FLASH_28FxxxP30_RCR_BL(FLASH_28FxxxP30_BL_4);
+		*(volatile u16 *)(LOGIC_FLASH_BASE | (rcrval << 1)) = 0x0003;
+
+		/* Give a chance for accesses to finish... */
+		sdelay(2000);
+
+		/* Third, set GPMC for sync. */
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG1, &gpmc_cfg->cs[2].config1);
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG2, &gpmc_cfg->cs[2].config2);
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG3, &gpmc_cfg->cs[2].config3);
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG4, &gpmc_cfg->cs[2].config4);
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG5, &gpmc_cfg->cs[2].config5);
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG6, &gpmc_cfg->cs[2].config6);
+		writel(LOGIC_STNOR_SYNC_GPMC_CONFIG7, &gpmc_cfg->cs[2].config7);
+		/* And lastly, set the WAIT1 polarity high */
+		writel(readl(&gpmc_cfg->config) | 0x200, &gpmc_cfg->config);
+	} else
+		puts ("NOR: Already initialized in sync mode\n");
+}
+
+
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+#ifdef CONFIG_SMC911X
+	rc = smc911x_initialize(0, CONFIG_SMC911X_BASE);
+#endif
+	return rc;
+}
diff -rupN u-boot-2010.06.orig/board/logicpd/logic/logic.h u-boot-2010.06.new/board/logicpd/logic/logic.h
--- u-boot-2010.06.orig/board/logicpd/logic/logic.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/logic/logic.h	2010-06-25 11:38:14.000000000 -0700
@@ -0,0 +1,376 @@
+/*
+ * (C) Copyright 2009
+ * Peter Barada <peterb@logicpd.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _LOGIC_H_
+#define _LOGIC_H_
+
+const omap3_sysinfo sysinfo = {
+	DDR_STACKED,
+	"OMAP3 Logic",
+	"NAND",
+};
+
+/*
+ * IEN  - Input Enable
+ * IDIS - Input Disable
+ * PTD  - Pull type Down
+ * PTU  - Pull type Up
+ * DIS  - Pull type selection is inactive
+ * EN   - Pull type selection is active
+ * M0   - Mode 0
+ * The commented string gives the final mux configuration for that pin
+ */
+#define MUX_LOGIC() \
+ /*SDRC*/\
+ MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0)) /*SDRC_D0*/\
+ MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0)) /*SDRC_D1*/\
+ MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0)) /*SDRC_D2*/\
+ MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0)) /*SDRC_D3*/\
+ MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0)) /*SDRC_D4*/\
+ MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0)) /*SDRC_D5*/\
+ MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0)) /*SDRC_D6*/\
+ MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0)) /*SDRC_D7*/\
+ MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0)) /*SDRC_D8*/\
+ MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0)) /*SDRC_D9*/\
+ MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0)) /*SDRC_D10*/\
+ MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0)) /*SDRC_D11*/\
+ MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0)) /*SDRC_D12*/\
+ MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0)) /*SDRC_D13*/\
+ MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0)) /*SDRC_D14*/\
+ MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0)) /*SDRC_D15*/\
+ MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0)) /*SDRC_D16*/\
+ MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0)) /*SDRC_D17*/\
+ MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0)) /*SDRC_D18*/\
+ MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0)) /*SDRC_D19*/\
+ MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0)) /*SDRC_D20*/\
+ MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0)) /*SDRC_D21*/\
+ MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0)) /*SDRC_D22*/\
+ MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0)) /*SDRC_D23*/\
+ MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0)) /*SDRC_D24*/\
+ MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0)) /*SDRC_D25*/\
+ MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0)) /*SDRC_D26*/\
+ MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0)) /*SDRC_D27*/\
+ MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0)) /*SDRC_D28*/\
+ MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0)) /*SDRC_D29*/\
+ MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0)) /*SDRC_D30*/\
+ MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0)) /*SDRC_D31*/\
+ MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0)) /*SDRC_CLK*/\
+ MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS0*/\
+ MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS1*/\
+ MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS2*/\
+ MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0)) /*SDRC_DQS3*/\
+ /*GPMC*/\
+ MUX_VAL(CP(GPMC_A1),		(IDIS | PTD | DIS | M0)) /*GPMC_A1*/\
+ MUX_VAL(CP(GPMC_A2),		(IDIS | PTD | DIS | M0)) /*GPMC_A2*/\
+ MUX_VAL(CP(GPMC_A3),		(IDIS | PTD | DIS | M0)) /*GPMC_A3*/\
+ MUX_VAL(CP(GPMC_A4),		(IDIS | PTD | DIS | M0)) /*GPMC_A4*/\
+ MUX_VAL(CP(GPMC_A5),		(IDIS | PTD | DIS | M0)) /*GPMC_A5*/\
+ MUX_VAL(CP(GPMC_A6),		(IDIS | PTD | DIS | M0)) /*GPMC_A6*/\
+ MUX_VAL(CP(GPMC_A7),		(IDIS | PTD | DIS | M0)) /*GPMC_A7*/\
+ MUX_VAL(CP(GPMC_A8),		(IDIS | PTD | DIS | M0)) /*GPMC_A8*/\
+ MUX_VAL(CP(GPMC_A9),		(IDIS | PTD | DIS | M0)) /*GPMC_A9*/\
+ MUX_VAL(CP(GPMC_A10),		(IDIS | PTD | DIS | M0)) /*GPMC_A10*/\
+ MUX_VAL(CP(GPMC_D0),		(IEN  | PTD | DIS | M0)) /*GPMC_D0*/\
+ MUX_VAL(CP(GPMC_D1),		(IEN  | PTD | DIS | M0)) /*GPMC_D1*/\
+ MUX_VAL(CP(GPMC_D2),		(IEN  | PTD | DIS | M0)) /*GPMC_D2*/\
+ MUX_VAL(CP(GPMC_D3),		(IEN  | PTD | DIS | M0)) /*GPMC_D3*/\
+ MUX_VAL(CP(GPMC_D4),		(IEN  | PTD | DIS | M0)) /*GPMC_D4*/\
+ MUX_VAL(CP(GPMC_D5),		(IEN  | PTD | DIS | M0)) /*GPMC_D5*/\
+ MUX_VAL(CP(GPMC_D6),		(IEN  | PTD | DIS | M0)) /*GPMC_D6*/\
+ MUX_VAL(CP(GPMC_D7),		(IEN  | PTD | DIS | M0)) /*GPMC_D7*/\
+ MUX_VAL(CP(GPMC_D8),		(IEN  | PTD | DIS | M0)) /*GPMC_D8*/\
+ MUX_VAL(CP(GPMC_D9),		(IEN  | PTD | DIS | M0)) /*GPMC_D9*/\
+ MUX_VAL(CP(GPMC_D10),		(IEN  | PTD | DIS | M0)) /*GPMC_D10*/\
+ MUX_VAL(CP(GPMC_D11),		(IEN  | PTD | DIS | M0)) /*GPMC_D11*/\
+ MUX_VAL(CP(GPMC_D12),		(IEN  | PTD | DIS | M0)) /*GPMC_D12*/\
+ MUX_VAL(CP(GPMC_D13),		(IEN  | PTD | DIS | M0)) /*GPMC_D13*/\
+ MUX_VAL(CP(GPMC_D14),		(IEN  | PTD | DIS | M0)) /*GPMC_D14*/\
+ MUX_VAL(CP(GPMC_D15),		(IEN  | PTD | DIS | M0)) /*GPMC_D15*/\
+ MUX_VAL(CP(GPMC_NCS0),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS0*/\
+ MUX_VAL(CP(GPMC_NCS1),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS1*/\
+ MUX_VAL(CP(GPMC_NCS2),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS2*/\
+ MUX_VAL(CP(GPMC_NCS3),		(IEN  | PTD | DIS | M0)) /*GPMC_nCS3*/\
+ MUX_VAL(CP(GPMC_NCS4),		(IDIS | PTU | EN  | M7)) /*GPMC_nCS4*/\
+ MUX_VAL(CP(GPMC_NCS5),		(IDIS | PTD | DIS | M7)) /*GPMC_nCS5*/\
+ MUX_VAL(CP(GPMC_NCS6),		(IDIS | PTU | EN  | M0)) /*GPMC_nCS6*/\
+ MUX_VAL(CP(GPMC_NCS7),		(IEN  | PTU | EN  | M1)) /*GPMC_IO_DIR*/\
+ MUX_VAL(CP(GPMC_NBE1),		(IDIS | PTU | EN  | M0)) /*GPMC_nBE1*/\
+ MUX_VAL(CP(GPMC_WAIT0),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT0*/\
+ MUX_VAL(CP(GPMC_WAIT1),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT1*/\
+ MUX_VAL(CP(GPMC_WAIT2),	(IEN  | PTU | EN  | M0)) /*GPMC_WAIT2*/\
+ MUX_VAL(CP(GPMC_WAIT3),	(IEN  | PTU | EN  | M1)) /*uP_DREQ1*/\
+ MUX_VAL(CP(GPMC_CLK),		(IEN  | PTD | DIS | M0)) /*GPMC_CLK*/\
+ MUX_VAL(CP(GPMC_NADV_ALE),	(IDIS | PTD | DIS | M0)) /*GPMC_nADV_ALE*/\
+ MUX_VAL(CP(GPMC_NOE),		(IDIS | PTD | DIS | M0)) /*GPMC_nOE*/\
+ MUX_VAL(CP(GPMC_NWE),		(IDIS | PTD | DIS | M0)) /*GPMC_nWE*/\
+ MUX_VAL(CP(GPMC_NWP),		(IEN  | PTU | EN  | M0)) /*GPMC_nWP*/\
+ MUX_VAL(CP(GPMC_NBE0_CLE),	(IEN  | PTU | EN  | M0)) /*GPMC_nBE0_CLE*/\
+ /*DSS*/\
+ MUX_VAL(CP(DSS_PCLK),		(IDIS | PTD | DIS | M0)) /*DSS_PCLK*/\
+ MUX_VAL(CP(DSS_HSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_HSYNC*/\
+ MUX_VAL(CP(DSS_VSYNC),		(IDIS | PTD | DIS | M0)) /*DSS_VSYNC*/\
+ MUX_VAL(CP(DSS_ACBIAS),	(IDIS | PTD | DIS | M0)) /*DSS_ACBIAS*/\
+ MUX_VAL(CP(DSS_DATA0),		(IDIS | PTD | DIS | M0)) /*DSS_DATA0*/\
+ MUX_VAL(CP(DSS_DATA1),		(IDIS | PTD | DIS | M0)) /*DSS_DATA1*/\
+ MUX_VAL(CP(DSS_DATA2),		(IDIS | PTD | DIS | M0)) /*DSS_DATA2*/\
+ MUX_VAL(CP(DSS_DATA3),		(IDIS | PTD | DIS | M0)) /*DSS_DATA3*/\
+ MUX_VAL(CP(DSS_DATA4),		(IDIS | PTD | DIS | M0)) /*DSS_DATA4*/\
+ MUX_VAL(CP(DSS_DATA5),		(IDIS | PTD | DIS | M0)) /*DSS_DATA5*/\
+ MUX_VAL(CP(DSS_DATA6),		(IDIS | PTD | DIS | M0)) /*DSS_DATA6*/\
+ MUX_VAL(CP(DSS_DATA7),		(IDIS | PTD | DIS | M0)) /*DSS_DATA7*/\
+ MUX_VAL(CP(DSS_DATA8),		(IDIS | PTD | DIS | M0)) /*DSS_DATA8*/\
+ MUX_VAL(CP(DSS_DATA9),		(IDIS | PTD | DIS | M0)) /*DSS_DATA9*/\
+ MUX_VAL(CP(DSS_DATA10),	(IDIS | PTD | DIS | M0)) /*DSS_DATA10*/\
+ MUX_VAL(CP(DSS_DATA11),	(IDIS | PTD | DIS | M0)) /*DSS_DATA11*/\
+ MUX_VAL(CP(DSS_DATA12),	(IDIS | PTD | DIS | M0)) /*DSS_DATA12*/\
+ MUX_VAL(CP(DSS_DATA13),	(IDIS | PTD | DIS | M0)) /*DSS_DATA13*/\
+ MUX_VAL(CP(DSS_DATA14),	(IDIS | PTD | DIS | M0)) /*DSS_DATA14*/\
+ MUX_VAL(CP(DSS_DATA15),	(IDIS | PTD | DIS | M0)) /*DSS_DATA15*/\
+ MUX_VAL(CP(DSS_DATA16),	(IDIS | PTD | DIS | M0)) /*DSS_DATA16*/\
+ MUX_VAL(CP(DSS_DATA17),	(IDIS | PTD | DIS | M0)) /*DSS_DATA17*/\
+ MUX_VAL(CP(DSS_DATA18),	(IDIS | PTD | DIS | M0)) /*DSS_DATA18*/\
+ MUX_VAL(CP(DSS_DATA19),	(IDIS | PTD | DIS | M0)) /*DSS_DATA19*/\
+ MUX_VAL(CP(DSS_DATA20),	(IDIS | PTD | DIS | M0)) /*DSS_DATA20*/\
+ MUX_VAL(CP(DSS_DATA21),	(IDIS | PTD | DIS | M0)) /*DSS_DATA21*/\
+ MUX_VAL(CP(DSS_DATA22),	(IDIS | PTD | DIS | M0)) /*DSS_DATA22*/\
+ MUX_VAL(CP(DSS_DATA23),	(IDIS | PTD | DIS | M0)) /*DSS_DATA23*/\
+ /*CAMERA*/\
+ MUX_VAL(CP(CAM_HS),		(IEN  | PTU | EN  | M0)) /*CAM_HS */\
+ MUX_VAL(CP(CAM_VS),		(IEN  | PTU | EN  | M0)) /*CAM_VS */\
+ MUX_VAL(CP(CAM_XCLKA),		(IDIS | PTD | DIS | M0)) /*CAM_XCLKA*/\
+ MUX_VAL(CP(CAM_PCLK),		(IEN  | PTU | EN  | M0)) /*CAM_PCLK*/\
+ MUX_VAL(CP(CAM_FLD),		(IDIS | PTD | DIS | M4)) /*GPIO_98*/\
+ MUX_VAL(CP(CAM_D0),		(IEN  | PTD | DIS | M0)) /*CAM_D0*/\
+ MUX_VAL(CP(CAM_D1),		(IEN  | PTD | DIS | M0)) /*CAM_D1*/\
+ MUX_VAL(CP(CAM_D2),		(IEN  | PTD | DIS | M0)) /*CAM_D2*/\
+ MUX_VAL(CP(CAM_D3),		(IEN  | PTD | DIS | M0)) /*CAM_D3*/\
+ MUX_VAL(CP(CAM_D4),		(IEN  | PTD | DIS | M0)) /*CAM_D4*/\
+ MUX_VAL(CP(CAM_D5),		(IEN  | PTD | DIS | M0)) /*CAM_D5*/\
+ MUX_VAL(CP(CAM_D6),		(IEN  | PTD | DIS | M0)) /*CAM_D6*/\
+ MUX_VAL(CP(CAM_D7),		(IEN  | PTD | DIS | M0)) /*CAM_D7*/\
+ MUX_VAL(CP(CAM_D8),		(IEN  | PTD | DIS | M0)) /*CAM_D8*/\
+ MUX_VAL(CP(CAM_D9),		(IEN  | PTD | DIS | M0)) /*CAM_D9*/\
+ MUX_VAL(CP(CAM_D10),		(IEN  | PTD | DIS | M0)) /*CAM_D10*/\
+ MUX_VAL(CP(CAM_D11),		(IEN  | PTD | DIS | M0)) /*CAM_D11*/\
+ MUX_VAL(CP(CAM_XCLKB),		(IDIS | PTD | DIS | M0)) /*CAM_XCLKB*/\
+ MUX_VAL(CP(CAM_WEN),		(IEN  | PTD | DIS | M4)) /*GPIO_167*/\
+ MUX_VAL(CP(CAM_STROBE),	(IDIS | PTD | DIS | M0)) /*CAM_STROBE*/\
+ MUX_VAL(CP(CSI2_DX0),		(IEN  | PTD | DIS | M0)) /*CSI2_DX0*/\
+ MUX_VAL(CP(CSI2_DY0),		(IEN  | PTD | DIS | M0)) /*CSI2_DY0*/\
+ MUX_VAL(CP(CSI2_DX1),		(IEN  | PTD | DIS | M0)) /*CSI2_DX1*/\
+ MUX_VAL(CP(CSI2_DY1),		(IEN  | PTD | DIS | M0)) /*CSI2_DY1*/\
+ /*Audio Interface */\
+ MUX_VAL(CP(MCBSP2_FSX),	(IEN  | PTD | DIS | M0)) /*McBSP2_FSX*/\
+ MUX_VAL(CP(MCBSP2_CLKX),	(IEN  | PTD | DIS | M0)) /*McBSP2_CLKX*/\
+ MUX_VAL(CP(MCBSP2_DR),		(IEN  | PTD | DIS | M0)) /*McBSP2_DR*/\
+ MUX_VAL(CP(MCBSP2_DX),		(IDIS | PTD | DIS | M0)) /*McBSP2_DX*/\
+ /*Expansion card */\
+ MUX_VAL(CP(MMC1_CLK),		(IDIS | PTU | EN  | M0)) /*MMC1_CLK*/\
+ MUX_VAL(CP(MMC1_CMD),		(IEN  | PTU | EN  | M0)) /*MMC1_CMD*/\
+ MUX_VAL(CP(MMC1_DAT0),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT0*/\
+ MUX_VAL(CP(MMC1_DAT1),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT1*/\
+ MUX_VAL(CP(MMC1_DAT2),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT2*/\
+ MUX_VAL(CP(MMC1_DAT3),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT3*/\
+ MUX_VAL(CP(MMC1_DAT4),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT4*/\
+ MUX_VAL(CP(MMC1_DAT5),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT5*/\
+ MUX_VAL(CP(MMC1_DAT6),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT6*/\
+ MUX_VAL(CP(MMC1_DAT7),		(IEN  | PTU | EN  | M0)) /*MMC1_DAT7*/\
+ /*Wireless LAN */\
+ MUX_VAL(CP(MMC2_CLK),		(IEN  | PTU | EN  | M4)) /*GPIO_130*/\
+ MUX_VAL(CP(MMC2_CMD),		(IEN  | PTU | EN  | M4)) /*GPIO_131*/\
+ MUX_VAL(CP(MMC2_DAT0),		(IEN  | PTU | EN  | M4)) /*GPIO_132*/\
+ MUX_VAL(CP(MMC2_DAT1),		(IEN  | PTU | EN  | M4)) /*GPIO_133*/\
+ MUX_VAL(CP(MMC2_DAT2),		(IEN  | PTU | EN  | M4)) /*GPIO_134*/\
+ MUX_VAL(CP(MMC2_DAT3),		(IEN  | PTU | EN  | M4)) /*GPIO_135*/\
+ MUX_VAL(CP(MMC2_DAT4),		(IEN  | PTU | EN  | M4)) /*GPIO_136*/\
+ MUX_VAL(CP(MMC2_DAT5),		(IEN  | PTU | EN  | M4)) /*GPIO_137*/\
+ MUX_VAL(CP(MMC2_DAT6),		(IEN  | PTU | EN  | M4)) /*GPIO_138*/\
+ MUX_VAL(CP(MMC2_DAT7),		(IEN  | PTU | EN  | M4)) /*GPIO_139*/\
+ /*Bluetooth*/\
+ MUX_VAL(CP(MCBSP3_DX),		(IEN  | PTD | DIS | M1)) /*UART2_CTS*/\
+ MUX_VAL(CP(MCBSP3_DR),		(IDIS | PTD | DIS | M1)) /*UART2_RTS*/\
+ MUX_VAL(CP(MCBSP3_CLKX),	(IDIS | PTD | DIS | M1)) /*UART2_TX*/\
+ MUX_VAL(CP(MCBSP3_FSX),	(IEN  | PTD | DIS | M1)) /*UART2_RX*/\
+ MUX_VAL(CP(UART2_CTS),		(IEN  | PTD | DIS | M4)) /*GPIO_144*/\
+ MUX_VAL(CP(UART2_RTS),		(IEN  | PTD | DIS | M4)) /*GPIO_145*/\
+ MUX_VAL(CP(UART2_TX),		(IEN  | PTD | DIS | M4)) /*GPIO_146*/\
+ MUX_VAL(CP(UART2_RX),		(IEN  | PTD | DIS | M4)) /*GPIO_147*/\
+ /*Modem Interface */\
+ MUX_VAL(CP(UART1_TX),		(IDIS | PTD | DIS | M0)) /*UART1_TX*/\
+ MUX_VAL(CP(UART1_RTS),		(IDIS | PTD | DIS | M4)) /*GPIO_149*/ \
+ MUX_VAL(CP(UART1_CTS),		(IDIS | PTD | DIS | M4)) /*GPIO_150*/ \
+ MUX_VAL(CP(UART1_RX),		(IEN  | PTD | DIS | M0)) /*UART1_RX*/\
+ MUX_VAL(CP(MCBSP4_CLKX),	(IEN  | PTD | DIS | M1)) /*SSI1_DAT_RX*/\
+ MUX_VAL(CP(MCBSP4_DR),		(IEN  | PTD | DIS | M1)) /*SSI1_FLAG_RX*/\
+ MUX_VAL(CP(MCBSP4_DX),		(IEN  | PTD | DIS | M1)) /*SSI1_RDY_RX*/\
+ MUX_VAL(CP(MCBSP4_FSX),	(IEN  | PTD | DIS | M1)) /*SSI1_WAKE*/\
+ MUX_VAL(CP(MCBSP1_CLKR),	(IDIS | PTD | DIS | M4)) /*GPIO_156*/\
+ MUX_VAL(CP(MCBSP1_FSR),	(IDIS | PTU | EN  | M4)) /*GPIO_157*/\
+ MUX_VAL(CP(MCBSP1_DX),		(IDIS | PTD | DIS | M4)) /*GPIO_158*/\
+ MUX_VAL(CP(MCBSP1_DR),		(IDIS | PTD | DIS | M4)) /*GPIO_159*/\
+ MUX_VAL(CP(MCBSP_CLKS),	(IEN  | PTU | DIS | M0)) /*McBSP_CLKS*/\
+ MUX_VAL(CP(MCBSP1_FSX),	(IDIS | PTD | DIS | M4)) /*GPIO_161*/\
+ MUX_VAL(CP(MCBSP1_CLKX),	(IDIS | PTD | DIS | M4)) /*GPIO_162*/\
+ /*Serial Interface*/\
+ MUX_VAL(CP(UART3_CTS_RCTX),	(IEN  | PTD | EN  | M0)) /*UART3_CTS_RCTX*/\
+ MUX_VAL(CP(UART3_RTS_SD),	(IDIS | PTD | DIS | M0)) /*UART3_RTS_SD */\
+ MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTD | DIS | M0)) /*UART3_RX_IRRX*/\
+ MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0)) /*UART3_TX_IRTX*/\
+ MUX_VAL(CP(HSUSB0_CLK),	(IEN  | PTD | DIS | M0)) /*HSUSB0_CLK*/\
+ MUX_VAL(CP(HSUSB0_STP),	(IDIS | PTU | EN  | M0)) /*HSUSB0_STP*/\
+ MUX_VAL(CP(HSUSB0_DIR),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DIR*/\
+ MUX_VAL(CP(HSUSB0_NXT),	(IEN  | PTD | DIS | M0)) /*HSUSB0_NXT*/\
+ MUX_VAL(CP(HSUSB0_DATA0),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA0*/\
+ MUX_VAL(CP(HSUSB0_DATA1),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA1*/\
+ MUX_VAL(CP(HSUSB0_DATA2),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA2*/\
+ MUX_VAL(CP(HSUSB0_DATA3),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA3*/\
+ MUX_VAL(CP(HSUSB0_DATA4),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA4*/\
+ MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA5*/\
+ MUX_VAL(CP(HSUSB0_DATA6),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA6*/\
+ MUX_VAL(CP(HSUSB0_DATA7),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA7*/\
+ MUX_VAL(CP(I2C1_SCL),		(IEN  | PTU | EN  | M0)) /*I2C1_SCL*/\
+ MUX_VAL(CP(I2C1_SDA),		(IEN  | PTU | EN  | M0)) /*I2C1_SDA*/\
+ MUX_VAL(CP(I2C2_SCL),		(IEN  | PTU | EN  | M4)) /*GPIO_168*/\
+ MUX_VAL(CP(I2C2_SDA),		(IEN  | PTU | EN  | M4)) /*GPIO_183*/\
+ MUX_VAL(CP(I2C3_SCL),		(IEN  | PTU | EN  | M0)) /*I2C3_SCL*/\
+ MUX_VAL(CP(I2C3_SDA),		(IEN  | PTU | EN  | M0)) /*I2C3_SDA*/\
+ MUX_VAL(CP(I2C4_SCL),		(IEN  | PTU | EN  | M0)) /*I2C4_SCL*/\
+ MUX_VAL(CP(I2C4_SDA),		(IEN  | PTU | EN  | M0)) /*I2C4_SDA*/\
+ MUX_VAL(CP(HDQ_SIO),		(IDIS | PTU | EN  | M4)) /*GPIO_170*/\
+ MUX_VAL(CP(MCSPI1_CLK),	(IEN  | PTU | EN  | M4)) /*GPIO_171*/\
+ MUX_VAL(CP(MCSPI1_SIMO),	(IEN  | PTU | EN  | M4)) /*GPIO_172*/\
+ MUX_VAL(CP(MCSPI1_SOMI),	(IEN  | PTD | DIS | M0)) /*McSPI1_SOMI*/\
+ MUX_VAL(CP(MCSPI1_CS0),	(IEN  | PTD | EN  | M0)) /*McSPI1_CS0*/\
+ MUX_VAL(CP(MCSPI1_CS1),	(IDIS | PTD | EN  | M0)) /*McSPI1_CS1*/\
+ MUX_VAL(CP(MCSPI1_CS2),	(IDIS | PTD | DIS | M4)) /*GPIO_176*/\
+ /* USB EHCI (port 2) */\
+ MUX_VAL(CP(MCSPI1_CS3),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA2*/\
+ MUX_VAL(CP(MCSPI2_CLK),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA7*/\
+ MUX_VAL(CP(MCSPI2_SIMO),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA4*/\
+ MUX_VAL(CP(MCSPI2_SOMI),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA5*/\
+ MUX_VAL(CP(MCSPI2_CS0),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA6*/\
+ MUX_VAL(CP(MCSPI2_CS1),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA3*/\
+ MUX_VAL(CP(ETK_D10_ES2),	(IDIS | PTU | DIS | M3)) /*HSUSB2_CLK*/\
+ MUX_VAL(CP(ETK_D11_ES2),	(IDIS | PTU | DIS | M3)) /*HSUSB2_STP*/\
+ MUX_VAL(CP(ETK_D12_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DIR*/\
+ MUX_VAL(CP(ETK_D13_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB2_NXT*/\
+ MUX_VAL(CP(ETK_D14_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA0*/\
+ MUX_VAL(CP(ETK_D15_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB2_DATA1*/\
+ /*Control and debug */\
+ MUX_VAL(CP(SYS_32K),		(IEN  | PTD | DIS | M0)) /*SYS_32K*/\
+ MUX_VAL(CP(SYS_CLKREQ),	(IEN  | PTD | DIS | M0)) /*SYS_CLKREQ*/\
+ MUX_VAL(CP(SYS_NIRQ),		(IEN  | PTU | EN  | M0)) /*SYS_nIRQ*/\
+ MUX_VAL(CP(SYS_BOOT0),		(IEN  | PTD | DIS | M4)) /*GPIO_2*/\
+ MUX_VAL(CP(SYS_BOOT1),		(IEN  | PTD | DIS | M4)) /*GPIO_3*/\
+ MUX_VAL(CP(SYS_BOOT2),		(IEN  | PTD | DIS | M4)) /*GPIO_4 - MMC1_WP*/\
+ MUX_VAL(CP(SYS_BOOT3),		(IEN  | PTD | DIS | M4)) /*GPIO_5*/\
+ MUX_VAL(CP(SYS_BOOT4),		(IEN  | PTD | DIS | M4)) /*GPIO_6*/\
+ MUX_VAL(CP(SYS_BOOT5),		(IEN  | PTD | DIS | M4)) /*GPIO_7*/\
+ MUX_VAL(CP(SYS_BOOT6),		(IDIS | PTD | DIS | M4)) /*GPIO_8*/ \
+ MUX_VAL(CP(SYS_OFF_MODE),	(IEN  | PTD | DIS | M0)) /*SYS_OFF_MODE*/\
+ MUX_VAL(CP(SYS_CLKOUT1),	(IEN  | PTD | DIS | M0)) /*SYS_CLKOUT1*/\
+ MUX_VAL(CP(SYS_CLKOUT2),	(IEN  | PTU | EN  | M4)) /*GPIO_186*/\
+ MUX_VAL(CP(ETK_CLK_ES2),	(IDIS | PTU | EN  | M3)) /*HSUSB1_STP*/\
+ MUX_VAL(CP(ETK_CTL_ES2),	(IDIS | PTU | DIS | M3)) /*HSUSB1_CLK*/\
+ MUX_VAL(CP(ETK_D0_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA0*/\
+ MUX_VAL(CP(ETK_D1_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA1*/\
+ MUX_VAL(CP(ETK_D2_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA2*/\
+ MUX_VAL(CP(ETK_D3_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA7*/\
+ MUX_VAL(CP(ETK_D4_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA4*/\
+ MUX_VAL(CP(ETK_D5_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA5*/\
+ MUX_VAL(CP(ETK_D6_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA6*/\
+ MUX_VAL(CP(ETK_D7_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DATA3*/\
+ MUX_VAL(CP(ETK_D8_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_DIR*/\
+ MUX_VAL(CP(ETK_D9_ES2),	(IEN  | PTU | DIS | M3)) /*HSUSB1_NXT*/\
+ MUX_VAL(CP(D2D_MCAD1),		(IEN  | PTD | EN  | M0)) /*d2d_mcad1*/\
+ MUX_VAL(CP(D2D_MCAD2),		(IEN  | PTD | EN  | M0)) /*d2d_mcad2*/\
+ MUX_VAL(CP(D2D_MCAD3),		(IEN  | PTD | EN  | M0)) /*d2d_mcad3*/\
+ MUX_VAL(CP(D2D_MCAD4),		(IEN  | PTD | EN  | M0)) /*d2d_mcad4*/\
+ MUX_VAL(CP(D2D_MCAD5),		(IEN  | PTD | EN  | M0)) /*d2d_mcad5*/\
+ MUX_VAL(CP(D2D_MCAD6),		(IEN  | PTD | EN  | M0)) /*d2d_mcad6*/\
+ MUX_VAL(CP(D2D_MCAD7),		(IEN  | PTD | EN  | M0)) /*d2d_mcad7*/\
+ MUX_VAL(CP(D2D_MCAD8),		(IEN  | PTD | EN  | M0)) /*d2d_mcad8*/\
+ MUX_VAL(CP(D2D_MCAD9),		(IEN  | PTD | EN  | M0)) /*d2d_mcad9*/\
+ MUX_VAL(CP(D2D_MCAD10),	(IEN  | PTD | EN  | M0)) /*d2d_mcad10*/\
+ MUX_VAL(CP(D2D_MCAD11),	(IEN  | PTD | EN  | M0)) /*d2d_mcad11*/\
+ MUX_VAL(CP(D2D_MCAD12),	(IEN  | PTD | EN  | M0)) /*d2d_mcad12*/\
+ MUX_VAL(CP(D2D_MCAD13),	(IEN  | PTD | EN  | M0)) /*d2d_mcad13*/\
+ MUX_VAL(CP(D2D_MCAD14),	(IEN  | PTD | EN  | M0)) /*d2d_mcad14*/\
+ MUX_VAL(CP(D2D_MCAD15),	(IEN  | PTD | EN  | M0)) /*d2d_mcad15*/\
+ MUX_VAL(CP(D2D_MCAD16),	(IEN  | PTD | EN  | M0)) /*d2d_mcad16*/\
+ MUX_VAL(CP(D2D_MCAD17),	(IEN  | PTD | EN  | M0)) /*d2d_mcad17*/\
+ MUX_VAL(CP(D2D_MCAD18),	(IEN  | PTD | EN  | M0)) /*d2d_mcad18*/\
+ MUX_VAL(CP(D2D_MCAD19),	(IEN  | PTD | EN  | M0)) /*d2d_mcad19*/\
+ MUX_VAL(CP(D2D_MCAD20),	(IEN  | PTD | EN  | M0)) /*d2d_mcad20*/\
+ MUX_VAL(CP(D2D_MCAD21),	(IEN  | PTD | EN  | M0)) /*d2d_mcad21*/\
+ MUX_VAL(CP(D2D_MCAD22),	(IEN  | PTD | EN  | M0)) /*d2d_mcad22*/\
+ MUX_VAL(CP(D2D_MCAD23),	(IEN  | PTD | EN  | M0)) /*d2d_mcad23*/\
+ MUX_VAL(CP(D2D_MCAD24),	(IEN  | PTD | EN  | M0)) /*d2d_mcad24*/\
+ MUX_VAL(CP(D2D_MCAD25),	(IEN  | PTD | EN  | M0)) /*d2d_mcad25*/\
+ MUX_VAL(CP(D2D_MCAD26),	(IEN  | PTD | EN  | M0)) /*d2d_mcad26*/\
+ MUX_VAL(CP(D2D_MCAD27),	(IEN  | PTD | EN  | M0)) /*d2d_mcad27*/\
+ MUX_VAL(CP(D2D_MCAD28),	(IEN  | PTD | EN  | M0)) /*d2d_mcad28*/\
+ MUX_VAL(CP(D2D_MCAD29),	(IEN  | PTD | EN  | M0)) /*d2d_mcad29*/\
+ MUX_VAL(CP(D2D_MCAD30),	(IEN  | PTD | EN  | M0)) /*d2d_mcad30*/\
+ MUX_VAL(CP(D2D_MCAD31),	(IEN  | PTD | EN  | M0)) /*d2d_mcad31*/\
+ MUX_VAL(CP(D2D_MCAD32),	(IEN  | PTD | EN  | M0)) /*d2d_mcad32*/\
+ MUX_VAL(CP(D2D_MCAD33),	(IEN  | PTD | EN  | M0)) /*d2d_mcad33*/\
+ MUX_VAL(CP(D2D_MCAD34),	(IEN  | PTD | EN  | M0)) /*d2d_mcad34*/\
+ MUX_VAL(CP(D2D_MCAD35),	(IEN  | PTD | EN  | M0)) /*d2d_mcad35*/\
+ MUX_VAL(CP(D2D_MCAD36),	(IEN  | PTD | EN  | M0)) /*d2d_mcad36*/\
+ MUX_VAL(CP(D2D_CLK26MI),	(IEN  | PTD | DIS | M0)) /*d2d_clk26mi*/\
+ MUX_VAL(CP(D2D_NRESPWRON),	(IEN  | PTD | EN  | M0)) /*d2d_nrespwron*/\
+ MUX_VAL(CP(D2D_NRESWARM),	(IEN  | PTU | EN  | M0)) /*d2d_nreswarm */\
+ MUX_VAL(CP(D2D_ARM9NIRQ),	(IEN  | PTD | DIS | M0)) /*d2d_arm9nirq */\
+ MUX_VAL(CP(D2D_UMA2P6FIQ),	(IEN  | PTD | DIS | M0)) /*d2d_uma2p6fiq*/\
+ MUX_VAL(CP(D2D_SPINT),		(IEN  | PTD | EN  | M0)) /*d2d_spint*/\
+ MUX_VAL(CP(D2D_FRINT),		(IEN  | PTD | EN  | M0)) /*d2d_frint*/\
+ MUX_VAL(CP(D2D_DMAREQ0),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq0*/\
+ MUX_VAL(CP(D2D_DMAREQ1),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq1*/\
+ MUX_VAL(CP(D2D_DMAREQ2),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq2*/\
+ MUX_VAL(CP(D2D_DMAREQ3),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq3*/\
+ MUX_VAL(CP(D2D_N3GTRST),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtrst*/\
+ MUX_VAL(CP(D2D_N3GTDI),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdi*/\
+ MUX_VAL(CP(D2D_N3GTDO),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdo*/\
+ MUX_VAL(CP(D2D_N3GTMS),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtms*/\
+ MUX_VAL(CP(D2D_N3GTCK),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtck*/\
+ MUX_VAL(CP(D2D_N3GRTCK),	(IEN  | PTD | DIS | M0)) /*d2d_n3grtck*/\
+ MUX_VAL(CP(D2D_MSTDBY),	(IEN  | PTU | EN  | M0)) /*d2d_mstdby*/\
+ MUX_VAL(CP(D2D_SWAKEUP),	(IEN  | PTD | EN  | M0)) /*d2d_swakeup*/\
+ MUX_VAL(CP(D2D_IDLEREQ),	(IEN  | PTD | DIS | M0)) /*d2d_idlereq*/\
+ MUX_VAL(CP(D2D_IDLEACK),	(IEN  | PTU | EN  | M0)) /*d2d_idleack*/\
+ MUX_VAL(CP(D2D_MWRITE),	(IEN  | PTD | DIS | M0)) /*d2d_mwrite*/\
+ MUX_VAL(CP(D2D_SWRITE),	(IEN  | PTD | DIS | M0)) /*d2d_swrite*/\
+ MUX_VAL(CP(D2D_MREAD),		(IEN  | PTD | DIS | M0)) /*d2d_mread*/\
+ MUX_VAL(CP(D2D_SREAD),		(IEN  | PTD | DIS | M0)) /*d2d_sread*/\
+ MUX_VAL(CP(D2D_MBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_mbusflag*/\
+ MUX_VAL(CP(D2D_SBUSFLAG),	(IEN  | PTD | DIS | M0)) /*d2d_sbusflag*/\
+ MUX_VAL(CP(SDRC_CKE0),		(IDIS | PTU | EN  | M0)) /*sdrc_cke0*/\
+ MUX_VAL(CP(SDRC_CKE1),		(IDIS | PTU | EN  | M0)) /*sdrc_cke1*/
+
+#define MUX_LOGIC_HSUSB0_D5_GPIO_MUX()					\
+ MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M4)) /*GPIO_189*/
+
+#define MUX_LOGIC_HSUSB0_D5_DATA5()					\
+ MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M0)) /*HSUSB0_DATA5*/
+
+#endif
diff -rupN u-boot-2010.06.orig/board/logicpd/logic/product_id.h u-boot-2010.06.new/board/logicpd/logic/product_id.h
--- u-boot-2010.06.orig/board/logicpd/logic/product_id.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/board/logicpd/logic/product_id.h	2010-06-25 11:38:14.000000000 -0700
@@ -0,0 +1,92 @@
+/*
+ * (C) Copyright 2008
+ * Logic Produc Development, <www.logicpd.com>
+ * Peter Barada <peter.barada@logicpd.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#define LOGIC_HEADER_VERSION_0 0
+struct product_zone_0_rev_0 {
+	char header_version;
+	char part_number[11];
+	char revision;
+	char sn_week;
+	char sn_year;
+	char sn_site;
+	int sn_cnt;
+	char maturity;
+};
+
+#define LOGIC_HEADER_VERSION_1 1
+struct product_zone_0_rev_1 {
+	char header_version;
+	char part_number[11];
+	char reserved; // removed from revision 1
+	char sn_week;
+	char sn_year;
+	char sn_site;
+	int sn_cnt;
+	char maturity;
+	char wifi_trim;
+};
+
+struct product_id_data {
+	struct {
+		union {
+			struct product_zone_0_rev_0 pz_0r0;
+			struct product_zone_0_rev_1 pz_0r1;
+		} u_zone0;
+
+		struct {
+			char model_revision;
+			char model_number[31];
+		} zone1;
+
+		struct {
+			unsigned char mac[4][3];
+			char nor0_size;
+			char nor1_size;
+			char nand0_size;
+			char nand1_size;
+			char sdram0_size;
+			char sdram1_size;
+			short processor_type;
+			int features;
+			int platform_bits;
+		} zone2;
+	} d;
+	unsigned int checksum;
+};
+
+// Only calculate across the data to checksum, compare to stored
+// value(outside of checksummed range)
+static inline int calculate_checksum(void *p, int len)
+{
+	unsigned char *buf = p;
+	unsigned int xsum = 0;
+	int i;
+
+	for (i=0; i<len; ++i)
+		xsum = ((xsum << 3) || (xsum >> 29)) ^ buf[i];
+
+	return xsum;
+}
+
+extern int fetch_production_data(void);
+extern void dump_production_data(void);
+extern void board_get_nth_enetaddr (unsigned char *enetaddr, int which, int position);
+extern int productID_has_NOR_flash(void);
diff -rupN u-boot-2010.06.orig/common/cmd_bootm.c u-boot-2010.06.new/common/cmd_bootm.c
--- u-boot-2010.06.orig/common/cmd_bootm.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/common/cmd_bootm.c	2011-06-03 17:27:17.000000000 -0700
@@ -1,4 +1,6 @@
 /*
+ * kevin.cheng@alicosystems.com adding debugging message 
+ *
  * (C) Copyright 2000-2009
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
@@ -350,7 +352,12 @@ static int bootm_load_os(image_info_t os
 		break;
 #ifdef CONFIG_GZIP
 	case IH_COMP_GZIP:
+                /* kc: adding debugging message if incorrect address */
+#ifdef ALICO_CODE
+	        printf ("   Uncompressing %s from:0x%x(0x%x) to 0x%lx ...", type_name, (unsigned int)image_start, unc_len, load);
+#else
 		printf ("   Uncompressing %s ... ", type_name);
+#endif
 		if (gunzip ((void *)load, unc_len,
 					(uchar *)image_start, &image_len) != 0) {
 			puts ("GUNZIP: uncompress, out-of-mem or overwrite error "
@@ -968,7 +975,13 @@ static void *boot_get_kernel (cmd_tbl_t
 		break;
 #endif
 	default:
+	        /* kc: adding debug information */
+#ifdef ALICO_CODE
+		printf ("Wrong Image Format at addr:0x%08lx for %s command\n", img_addr, cmdtp->name);
+#else 
 		printf ("Wrong Image Format for %s command\n", cmdtp->name);
+#endif
+
 		show_boot_progress (-108);
 		return NULL;
 	}
diff -rupN u-boot-2010.06.orig/common/cmd_nand.c u-boot-2010.06.new/common/cmd_nand.c
--- u-boot-2010.06.orig/common/cmd_nand.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/common/cmd_nand.c	2010-07-30 13:59:03.000000000 -0700
@@ -171,7 +171,14 @@ static void do_nand_status(nand_info_t *
 	int last_status = -1;
 
 	struct nand_chip *nand_chip = nand->priv;
+#ifdef ALICO_CODE
+	/* Check the WP bit. To do so requires resetting the device to
+	   force the status back to its reset value (so WP becomes whether
+	   the WP pin is set). */
+	nand_chip->cmdfunc(nand, NAND_CMD_RESET, -1, -1);
+#else
 	/* check the WP bit */
+#endif
 	nand_chip->cmdfunc(nand, NAND_CMD_STATUS, -1, -1);
 	printf("device is %swrite protected\n",
 		(nand_chip->read_byte(nand) & 0x80 ?
@@ -384,6 +391,22 @@ int do_nand(cmd_tbl_t * cmdtp, int flag,
 			else
 				ret = nand_write_skip_bad(nand, off, &size,
 							  (u_char *)addr);
+#ifdef ALICO_CODE
+		} else if (s != NULL && !strcmp(s, ".yaffs")) {
+			nand_write_options_t opts;
+			memset(&opts, 0, sizeof(opts));
+			opts.buffer	= (u_char *) addr;
+			opts.length	= size;
+			opts.offset	= off;
+			opts.pad	= 0;
+			opts.blockalign = 1;
+			opts.quiet      = quiet;
+			opts.writeoob	= 1;
+			opts.autoplace	= 1;
+			opts.forceyaffs = 1;
+			nand_write_opts(nand, &opts);
+#endif
+
 		} else if (!strcmp(s, ".oob")) {
 			/* out-of-band data */
 			mtd_oob_ops_t ops = {
@@ -465,6 +488,10 @@ int do_nand(cmd_tbl_t * cmdtp, int flag,
 		if (arg_off_size(argc - 2, argv + 2, nand, &off, &size) < 0)
 			return 1;
 
+#ifdef ALICO_CODE
+		printf ("nand_unlock: start: %08x, length: %#x\n",
+			(int)off, (int)size);
+#endif
 		if (!nand_unlock(nand, off, size)) {
 			puts("NAND flash successfully unlocked\n");
 		} else {
@@ -489,6 +516,10 @@ U_BOOT_CMD(nand, CONFIG_SYS_MAXARGS, 1,
 	"nand write - addr off|partition size\n"
 	"    read/write 'size' bytes starting at offset 'off'\n"
 	"    to/from memory address 'addr', skipping bad blocks.\n"
+#ifdef ALICO_CODE
+	"nand write[.yaffs] - addr off size - write `size' byte yaffs2 image\n"
+	"    at offset `off' from memory address `addr'\n"
+#endif
 	"nand erase [clean] [off size] - erase 'size' bytes from\n"
 	"    offset 'off' (entire device if not specified)\n"
 	"nand bad - show bad blocks\n"
diff -rupN u-boot-2010.06.orig/common/env_nand.c u-boot-2010.06.new/common/env_nand.c
--- u-boot-2010.06.orig/common/env_nand.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/common/env_nand.c	2010-07-30 13:59:03.000000000 -0700
@@ -166,12 +166,60 @@ int writeenv(size_t offset, u_char *buf)
 	size_t end = offset + CONFIG_ENV_RANGE;
 	size_t amount_saved = 0;
 	size_t blocksize, len;
+#ifdef ALICO_CODE
+	size_t ncopies = 0;
+#endif
 
 	u_char *char_ptr;
 
 	blocksize = nand_info[0].erasesize;
 	len = min(blocksize, CONFIG_ENV_SIZE);
 
+#ifdef ALICO_CODE
+	/* If the environment fits into a single block, then write that block
+	 * into each block of the range.  This allows readenv to pick *any*
+	 * good block to pull the environment out of which helps if a block
+	 * goes bad between the write and next read.  If envrironment is
+	 * larger than one block, just write one copy of the environment.
+	 */
+
+	if (CONFIG_ENV_SIZE <= blocksize) {
+		while (offset < end) {
+			if (!nand_block_isbad(&nand_info[0], offset)) {
+				char_ptr = &buf[amount_saved];
+				if (nand_write(&nand_info[0], offset, &len,
+					       char_ptr)) {
+					/* write failed, skip it */
+				} else {
+					amount_saved += len;
+					if (amount_saved >= CONFIG_ENV_SIZE) {
+						ncopies++;
+						amount_saved = 0;
+					}
+				}
+			}
+			offset += blocksize;
+		}
+		if (!ncopies)
+			return 1;
+	} else {
+		while (amount_saved < CONFIG_ENV_SIZE && offset < end) {
+			if (nand_block_isbad(&nand_info[0], offset)) {
+				offset += blocksize;
+			} else {
+				char_ptr = &buf[amount_saved];
+				if (nand_write(&nand_info[0], offset, &len,
+						char_ptr))
+					return 1;
+				offset += blocksize;
+				amount_saved += len;
+			}
+		}
+		if (amount_saved != CONFIG_ENV_SIZE)
+			return 1;
+	}
+
+#else
 	while (amount_saved < CONFIG_ENV_SIZE && offset < end) {
 		if (nand_block_isbad(&nand_info[0], offset)) {
 			offset += blocksize;
@@ -187,6 +235,7 @@ int writeenv(size_t offset, u_char *buf)
 	if (amount_saved != CONFIG_ENV_SIZE)
 		return 1;
 
+#endif
 	return 0;
 }
 #ifdef CONFIG_ENV_OFFSET_REDUND
diff -rupN u-boot-2010.06.orig/drivers/mtd/nand/nand_base.c u-boot-2010.06.new/drivers/mtd/nand/nand_base.c
--- u-boot-2010.06.orig/drivers/mtd/nand/nand_base.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/drivers/mtd/nand/nand_base.c	2010-07-30 13:59:03.000000000 -0700
@@ -455,6 +455,12 @@ static int nand_check_wp(struct mtd_info
 {
 	struct nand_chip *chip = mtd->priv;
 	/* Check the WP bit */
+#ifdef ALICO_CODE
+	/* Check the WP bit. To do so requires resetting the device to
+	   force the status back to its reset value (so WP becomes whether
+	   the WP pin is set). */
+	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+#endif
 	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
 	return (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
 }
@@ -1520,6 +1526,11 @@ static int nand_write_oob_std(struct mtd
 
 	status = chip->waitfunc(mtd, chip);
 
+#ifdef ALICO_CODE
+	if ((~status) & NAND_STATUS_WP)
+	  return -EPERM;
+#endif
+
 	return status & NAND_STATUS_FAIL ? -EIO : 0;
 }
 
@@ -1578,6 +1589,10 @@ static int nand_write_oob_syndrome(struc
 
 	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
 	status = chip->waitfunc(mtd, chip);
+#ifdef ALICO_CODE
+	if ((~status) & NAND_STATUS_WP)
+	  return -EPERM;
+#endif
 
 	return status & NAND_STATUS_FAIL ? -EIO : 0;
 }
@@ -1907,6 +1922,13 @@ static int nand_write_page(struct mtd_in
 		 * See if operation failed and additional status checks are
 		 * available
 		 */
+#ifdef ALICO_CODE
+		if ((~status) & NAND_STATUS_WP) {
+			printf("%s: failed to write to write-protected page\n", __FUNCTION__);
+			return -EPERM;
+		}
+#endif
+
 		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
 			status = chip->errstat(mtd, chip, FL_WRITING, status,
 					       page);
@@ -1916,6 +1938,12 @@ static int nand_write_page(struct mtd_in
 	} else {
 		chip->cmdfunc(mtd, NAND_CMD_CACHEDPROG, -1, -1);
 		status = chip->waitfunc(mtd, chip);
+#ifdef ALICO_CODE
+		if ((~status) & NAND_STATUS_WP) {
+			printf("%s: failed to write to write-protected page\n", __FUNCTION__);
+			return -EPERM;
+		}
+#endif
 	}
 
 #ifdef CONFIG_MTD_NAND_VERIFY_WRITE
@@ -2399,6 +2427,16 @@ int nand_erase_nand(struct mtd_info *mtd
 			status = chip->errstat(mtd, chip, FL_ERASING,
 					       status, page);
 
+#ifdef ALICO_CODE
+		/* If block is write-protected, skip to next */
+		if ((~status) & NAND_STATUS_WP) {
+			printk(KERN_WARNING "nand_erase: attempt to erase a "
+			       "write-protected block at page 0x%08x\n", page);
+			instr->state = MTD_ERASE_FAILED;
+			goto erase_exit;
+		}
+#endif
+
 		/* See if block erase succeeded */
 		if (status & NAND_STATUS_FAIL) {
 			MTDDEBUG (MTD_DEBUG_LEVEL0, "nand_erase: "
@@ -2652,7 +2690,7 @@ static struct nand_flash_dev *nand_get_f
 		}
 	}
 
-	if (!type)
+	if (!type) 
 		return ERR_PTR(-ENODEV);
 
 	if (!mtd->name)
diff -rupN u-boot-2010.06.orig/drivers/mtd/nand/nand_util.c u-boot-2010.06.new/drivers/mtd/nand/nand_util.c
--- u-boot-2010.06.orig/drivers/mtd/nand/nand_util.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/drivers/mtd/nand/nand_util.c	2011-06-10 12:52:01.086688001 -0700
@@ -201,8 +201,66 @@ int nand_erase_opts(nand_info_t *meminfo
 
 	return 0;
 }
+#ifdef ALICO_CODE
+/* 1 XXX U-BOOT XXX */
 
-/* XXX U-BOOT XXX */
+#define MAX_PAGE_SIZE	2048
+#define MAX_OOB_SIZE	64
+
+/*
+ * buffer array used for writing data
+ */
+static unsigned char data_buf[MAX_PAGE_SIZE];
+static unsigned char oob_buf[MAX_OOB_SIZE];
+
+/* OOB layouts to pass into the kernel as default */
+static struct nand_ecclayout none_ecclayout = {
+	.eccbytes = 0,
+};
+
+static struct nand_ecclayout jffs2_ecclayout = {
+	.eccbytes = 6,
+	.eccpos = { 0, 1, 2, 3, 6, 7 },
+	.oobfree = { { 8, 8 } },
+	.oobavail = 8,
+};
+
+static struct nand_ecclayout yaffs_ecclayout = {
+	.eccbytes = 6,
+	.eccpos = { 8, 9, 10, 13, 14, 15},
+	.oobfree = { {0, 4}, {6, 2}, {11, 2} },
+	.oobavail = 8,
+};
+
+#ifdef CONFIG_OMAP3_ALICO
+/* ecclayout for OMAP3_ALICO, using omap HW ecc */
+static struct nand_ecclayout yaffs2_ecclayout = {
+	.eccbytes = 12,
+	.eccpos = { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13},
+	.oobfree = { { 14, 50} },
+	.oobavail = 50,
+};
+#else
+/* ecclayout on chips that page_size = 2K, byte 0,1 is bad block marker */
+static struct nand_ecclayout yaffs2_ecclayout = {
+	.eccbytes = 24,
+	.eccpos = {
+		40, 41, 42, 43, 44, 45, 46, 47,
+		48, 49, 50, 51, 52, 53, 54, 55,
+		56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = { {2, 38} },
+	.oobavail = 38,
+};
+#endif
+
+static struct nand_ecclayout autoplace_ecclayout = {
+	.oobavail = 38,
+};
+
+/* 1 XXX U-BOOT XXX */
+
+#else
+/* 2 XXX U-BOOT XXX */
 #if 0
 
 #define MAX_PAGE_SIZE	2048
@@ -236,7 +294,9 @@ static struct nand_ecclayout autoplace_e
 };
 #endif
 
-/* XXX U-BOOT XXX */
+/* 2 XXX U-BOOT XXX */
+#endif
+
 #ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
 
 /******************************************************************************
@@ -314,6 +374,9 @@ int nand_lock(struct mtd_info *mtd, int
 int nand_get_lock_status(struct mtd_info *mtd, loff_t offset)
 {
 	int ret = 0;
+#ifdef ALICO_CODE
+	int flags = 0;
+#endif
 	int chipnr;
 	int page;
 	struct nand_chip *chip = mtd->priv;
@@ -335,9 +398,26 @@ int nand_get_lock_status(struct mtd_info
 	page = (int)(offset >> chip->page_shift);
 	chip->cmdfunc(mtd, NAND_CMD_LOCK_STATUS, -1, page & chip->pagemask);
 
+#ifdef ALICO_CODE
+	ret = chip->read_byte(mtd);
+
+	ret &= (NAND_LOCK_STATUS_TIGHT | NAND_LOCK_STATUS_LOCK | NAND_LOCK_STATUS_UNLOCK);
+
+	if (ret & NAND_LOCK_STATUS_TIGHT)
+		flags |= NAND_LOCK_STATUS_TIGHT;
+
+	if (ret & NAND_LOCK_STATUS_UNLOCK)
+		flags |= NAND_LOCK_STATUS_UNLOCK;
+	else
+		flags |= NAND_LOCK_STATUS_LOCK;
+
+	ret = flags;
+
+#else
 	ret = chip->read_byte(mtd) & (NAND_LOCK_STATUS_TIGHT
 					  | NAND_LOCK_STATUS_LOCK
 					  | NAND_LOCK_STATUS_UNLOCK);
+#endif
 
  out:
 	/* de-select the NAND device */
@@ -363,13 +443,23 @@ int nand_unlock(struct mtd_info *mtd, ul
 	int status;
 	int page;
 	struct nand_chip *chip = mtd->priv;
+#ifndef ALICO_CODE
 	printf ("nand_unlock: start: %08x, length: %d!\n",
 		(int)start, (int)length);
+#endif
 
 	/* select the NAND device */
 	chipnr = (int)(start >> chip->chip_shift);
 	chip->select_chip(mtd, chipnr);
 
+#ifdef ALICO_CODE
+
+	/* Check the WP bit. To do so requires resetting the device to
+	   force the status back to its reset value (so WP becomes whether
+	   the WP pin is set). */
+	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+#endif
+
 	/* check the WP bit */
 	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
 	if (!(chip->read_byte(mtd) & NAND_STATUS_WP)) {
@@ -534,6 +624,254 @@ int nand_write_skip_bad(nand_info_t *nan
 	return 0;
 }
 
+#ifdef ALICO_CODE
+/**
+ * nand_write_opts: - write image to NAND flash with support for various options
+ *
+ * @param meminfo	NAND device to erase
+ * @param opts		write options (@see nand_write_options)
+ * @return		0 in case of success
+ *
+ * This code is ported from nandwrite.c from Linux mtd utils by
+ * Steven J. Hill and Thomas Gleixner.
+ */
+int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts)
+{
+	int imglen = 0;
+	int pagelen;
+	int baderaseblock;
+	int blockstart = -1;
+	loff_t offs;
+	int readlen;
+	int ecclayout_changed = 0;
+	int percent_complete = -1;
+	struct nand_ecclayout *old_ecclayout;
+	struct nand_chip *chip = meminfo->priv;
+	ulong mtdoffset = opts->offset;
+	ulong erasesize_blockalign;
+	u_char *buffer = opts->buffer;
+	size_t written;
+	int result;
+
+	if (opts->pad && opts->writeoob) {
+		printf("Can't pad when oob data is present.\n");
+		return -1;
+	}
+
+	/* set erasesize to specified number of blocks - to match
+	 * jffs2 (virtual) block size */
+	if (opts->blockalign == 0)
+		erasesize_blockalign = meminfo->erasesize;
+	else
+		erasesize_blockalign = meminfo->erasesize * opts->blockalign;
+
+	/* make sure device page sizes are valid */
+	if (!(meminfo->oobsize == 16 && meminfo->writesize == 512)
+	    && !(meminfo->oobsize == 8 && meminfo->writesize == 256)
+	    && !(meminfo->oobsize == 64 && meminfo->writesize == 2048)) {
+		printf("Unknown flash (not normal NAND)\n");
+		return -1;
+	}
+
+	/* read the current ecclayout */
+	old_ecclayout =  meminfo->ecclayout;
+
+	/* write without ecc? */
+	if (opts->noecc) {
+		meminfo->ecclayout = &none_ecclayout;
+		ecclayout_changed = 1;
+	}
+
+	/* autoplace ECC? */
+	if (opts->autoplace && (chip->ecc.mode != MTD_NANDECC_AUTOPLACE)) {
+
+		meminfo->ecclayout = &autoplace_ecclayout,
+		ecclayout_changed = 1;
+	}
+
+	/* force OOB layout for jffs2 or yaffs? */
+	if (opts->forcejffs2 || opts->forceyaffs) {
+		struct nand_ecclayout *oobsel =
+			opts->forcejffs2 ? &jffs2_ecclayout : &yaffs2_ecclayout;
+
+		if (meminfo->oobsize == 8) {
+			if (opts->forceyaffs) {
+				printf("YAFSS cannot operate on "
+				       "256 Byte page size\n");
+				goto restoreoob;
+			}
+		}
+
+		meminfo->ecclayout = oobsel;
+		ecclayout_changed = 1;
+	}
+
+	/* get image length */
+	imglen = opts->length;
+	pagelen = meminfo->writesize
+		+ ((opts->writeoob != 0) ? meminfo->oobsize : 0);
+
+	/* check, if file is pagealigned */
+	if ((!opts->pad) && ((imglen % pagelen) != 0)) {
+		printf("Input block length is not page aligned\n");
+		goto restoreoob;
+	}
+
+	/* check, if length fits into device */
+	if (((imglen / pagelen) * meminfo->writesize)
+	     > (meminfo->size - opts->offset)) {
+		printf("Image %d bytes, NAND page %d bytes, "
+		       "OOB area %u bytes, device size %u bytes\n",
+		       imglen, pagelen, meminfo->writesize, (unsigned int)meminfo->size);
+		printf("Input block does not fit into device\n");
+		goto restoreoob;
+	}
+
+	if (!opts->quiet)
+		printf("\n");
+
+	/* get data from input and write to the device */
+	while (imglen && (mtdoffset < meminfo->size)) {
+
+		WATCHDOG_RESET();
+
+		/*
+		 * new eraseblock, check for bad block(s). Stay in the
+		 * loop to be sure if the offset changes because of
+		 * a bad block, that the next block that will be
+		 * written to is also checked. Thus avoiding errors if
+		 * the block(s) after the skipped block(s) is also bad
+		 * (number of blocks depending on the blockalign
+		 */
+		while (blockstart != (mtdoffset & (~erasesize_blockalign+1))) {
+			blockstart = mtdoffset & (~erasesize_blockalign+1);
+			offs = blockstart;
+			baderaseblock = 0;
+
+			/* check all the blocks in an erase block for
+			 * bad blocks */
+			do {
+				int ret = meminfo->block_isbad(meminfo, offs);
+
+				if (ret < 0) {
+					printf("Bad block check failed\n");
+					goto restoreoob;
+				}
+				if (ret == 1) {
+					baderaseblock = 1;
+					if (!opts->quiet)
+						printf("\rBad block at 0x%lx "
+						       "in erase block from "
+						       "0x%x will be skipped\n",
+						       (long) offs,
+						       blockstart);
+				}
+
+				if (baderaseblock) {
+					mtdoffset = blockstart
+						+ erasesize_blockalign;
+				}
+				offs +=	 erasesize_blockalign
+					/ opts->blockalign;
+			} while (offs < blockstart + erasesize_blockalign);
+		}
+
+		readlen = meminfo->writesize;
+		if (opts->pad && (imglen < readlen)) {
+			readlen = imglen;
+			memset(data_buf + readlen, 0xff,
+			       meminfo->writesize - readlen);
+		}
+
+		/* read page data from input memory buffer */
+		memcpy(data_buf, buffer, readlen);
+		buffer += readlen;
+
+		if (opts->writeoob) {
+			/* read OOB data from input memory block, exit
+			 * on failure */
+			memcpy(oob_buf, buffer, meminfo->oobsize);
+			buffer += meminfo->oobsize;
+
+			struct mtd_oob_ops ops = {
+				.mode = MTD_OOB_AUTO,
+				.len = meminfo->writesize,
+				.retlen = 0,
+				.ooblen = meminfo->ecclayout->oobavail,
+				.oobretlen = 0,
+				.ooboffs = 0,
+				.datbuf = NULL,
+				.oobbuf = oob_buf,
+			};
+
+			result = meminfo->write_oob(meminfo, mtdoffset, &ops);
+
+			if (result != 0) {
+				printf("\nMTD writeoob failure: %d\n",
+				       result);
+				goto restoreoob;
+			}
+			imglen -= meminfo->oobsize;
+		}
+
+		/* write out the page data */
+		result = meminfo->write(meminfo,
+					mtdoffset,
+					meminfo->writesize,
+					&written,
+					(unsigned char *) &data_buf);
+
+		if (result != 0) {
+			printf("writing NAND page at offset 0x%lx failed\n",
+			       mtdoffset);
+			goto restoreoob;
+		}
+		imglen -= readlen;
+
+		if (!opts->quiet) {
+			unsigned long long n =((unsigned long long)(opts->length - imglen)) * 100;
+			int percent;
+
+			do_div(n, opts->length);
+			percent = (int)n;
+			  
+#if 0
+			int percent = (int)
+				((unsigned long long)
+				 (opts->length-imglen) * 100
+				 / opts->length);
+#endif
+			/* output progress message only at whole percent
+			 * steps to reduce the number of messages printed
+			 * on (slow) serial consoles
+			 */
+			if (percent != percent_complete) {
+				printf("\rWriting data at 0x%lx "
+				       "-- %3d%% complete.",
+				       mtdoffset, percent);
+				percent_complete = percent;
+			}
+		}
+
+		mtdoffset += meminfo->writesize;
+	}
+
+	if (!opts->quiet)
+		printf("\n");
+
+restoreoob:
+	if (ecclayout_changed)
+		meminfo->ecclayout = old_ecclayout;
+
+	if (imglen > 0) {
+	  printf("Data did not fit into device(imglen %d), due to bad blocks\n", imglen);
+		return -1;
+	}
+
+	/* return happy */
+	return 0;
+}
+#endif
 /**
  * nand_read_skip_bad:
  *
diff -rupN u-boot-2010.06.orig/drivers/mtd/nand/omap_gpmc.c u-boot-2010.06.new/drivers/mtd/nand/omap_gpmc.c
--- u-boot-2010.06.orig/drivers/mtd/nand/omap_gpmc.c	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/drivers/mtd/nand/omap_gpmc.c	2010-07-30 13:59:03.000000000 -0700
@@ -148,7 +148,9 @@ static int omap_correct_data(struct mtd_
 			 */
 			if ((orig_ecc == 0x0FFF0FFF) && (new_ecc == 0x00000000))
 				return 0;
+#ifndef ALICO_CODE
 			printf("Error: Bad compare! failed\n");
+#endif
 			/* detected 2 bit error */
 			return -1;
 		}
@@ -267,12 +269,12 @@ void omap_nand_switch_ecc(int32_t hardwa
 		nand->ecc.correct = omap_correct_data;
 		nand->ecc.calculate = omap_calculate_ecc;
 		omap_hwecc_init(nand);
-		printf("HW ECC selected\n");
+		printf("NAND HW ECC selected\n");  /* ALICO_CODE */
 	} else {
 		nand->ecc.mode = NAND_ECC_SOFT;
 		/* Use mtd default settings */
 		nand->ecc.layout = NULL;
-		printf("SW ECC selected\n");
+		printf("NAND SW ECC selected\n");  /* ALICO_CODE */
 	}
 
 	/* Update NAND handling after ECC mode switch */
@@ -296,6 +298,17 @@ void omap_nand_switch_ecc(int32_t hardwa
  *   nand_scan about special functionality. See the defines for further
  *   explanation
  */
+
+#ifdef ALICO_CODE
+static uint8_t omap3_lv_som_scan_ff_pattern[] = { 0xff, 0xff };
+static struct nand_bbt_descr omap3_lv_som_largepage_memorybased = {
+	.options = 0,
+	.offs = 0,
+	.len = 2,
+	.pattern = omap3_lv_som_scan_ff_pattern
+};
+#endif
+
 int board_nand_init(struct nand_chip *nand)
 {
 	int32_t gpmc_config = 0;
@@ -340,5 +353,10 @@ int board_nand_init(struct nand_chip *na
 	/* Default ECC mode */
 	nand->ecc.mode = NAND_ECC_SOFT;
 
+#ifdef ALICO_CODE
+	/* Use our specific bad-block definition (first byte only) */
+	nand->badblock_pattern = &omap3_lv_som_largepage_memorybased;
+#endif
+
 	return 0;
 }
diff -rupN u-boot-2010.06.orig/drivers/net/smc911x.h u-boot-2010.06.new/drivers/net/smc911x.h
--- u-boot-2010.06.orig/drivers/net/smc911x.h	2010-06-29 14:28:28.000000000 -0700
+++ u-boot-2010.06.new/drivers/net/smc911x.h	2010-07-30 13:59:03.000000000 -0700
@@ -25,6 +25,8 @@
 #ifndef _SMC911X_H_
 #define _SMC911X_H_
 
+#include <config.h> /* #define ALICO_CODE 1 */
+
 #include <linux/types.h>
 
 #define DRIVERNAME "smc911x"
@@ -447,7 +449,12 @@ static int smc911x_detect_chip(struct et
 		/* Special case -- no chip present */
 		return -1;
 	} else if (val != 0x87654321) {
+#ifdef ALICO_CODE
+		if (val == 0x21436587  || val == 0x43218765 || val == 0x65872143)
+			printf(DRIVERNAME ": Invalid chip endian 0x%08lx\n", val);
+#else
 		printf(DRIVERNAME ": Invalid chip endian 0x%08lx\n", val);
+#endif
 		return -1;
 	}
 
diff -rupN u-boot-2010.06.orig/include/configs/omap3_alico.h u-boot-2010.06.new/include/configs/omap3_alico.h
--- u-boot-2010.06.orig/include/configs/omap3_alico.h	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2010.06.new/include/configs/omap3_alico.h	2011-06-10 13:35:09.854688002 -0700
@@ -0,0 +1,397 @@
+/*
+ * (C) Copyright 2009
+ * Logic Product Development, <www.logicpd.com>
+ * Peter Barada <peterb@logicpd.com>
+ *
+ * Configuration settings for the LogicPD OMAP3530 LV SOM development kit.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+#include <asm/sizes.h>
+
+/*
+ * High Level Configuration Options
+ */
+#define CONFIG_ARMCORTEXA8	1	/* This is an ARM V7 CPU core */
+#define CONFIG_OMAP		1	/* in a TI OMAP core */
+#define CONFIG_OMAP34XX		1	/* which is a 34XX */
+#define CONFIG_OMAP3430		1	/* which is in a 3430 */
+#define CONFIG_OMAP3_LV_SOM	1	/* working with LV_SOM */
+#define CONFIG_OMAP3_ALICO	1	/* working with LV_SOM/Torpedo */
+
+/* kc */
+#define CONFIG_SDRC	/* The chip has SDRC controller */
+#define ALICO_CODE   1
+
+
+#include <asm/arch/cpu.h>		/* get chip and board defs */
+#include <asm/arch/omap3.h>
+
+/*
+ * Display CPU and Board information
+ */
+#define CONFIG_DISPLAY_CPUINFO		1
+#define CONFIG_DISPLAY_BOARDINFO	1
+
+/* Clock Defines */
+#define V_OSCK			26000000	/* Clock output from T2 */
+#define V_SCLK			(V_OSCK >> 1)
+
+#undef CONFIG_USE_IRQ				/* no support for IRQs */
+#define CONFIG_MISC_INIT_R
+
+#define BOARD_LATE_INIT
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+#define CONFIG_REVISION_TAG		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + SZ_128K)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* bytes reserved for */
+						/* initial data */
+
+/*
+ * Hardware drivers
+ */
+
+/*
+ * NS16550 Configuration
+ */
+#define V_NS16550_CLK			48000000	/* 48MHz (APLL96/2) */
+
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_CLK		V_NS16550_CLK
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		OMAP34XX_UART1
+#define CONFIG_SERIAL1			1	/* UART1 on OMAP3 LV SOM */
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{4800, 9600, 19200, 38400, 57600,\
+					115200}
+#define CONFIG_MMC			1
+#define CONFIG_OMAP3_MMC		1
+#define CONFIG_DOS_PARTITION		1
+
+/* kc: see omap3_zoom2.h */
+/* DDR - I use Micron DDR */
+#define CONFIG_OMAP3_MICRON_DDR         1
+
+/* commands to include */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_EXT2		/* EXT2 Support			*/
+#define CONFIG_CMD_FAT		/* FAT support			*/
+#define CONFIG_CMD_JFFS2	/* JFFS2 Support		*/
+#define CONFIG_CMD_MTDPARTS	/* Enable MTD parts commands */
+#define CONFIG_MTD_DEVICE	/* needed for mtdparts commands */
+#define MTDIDS_DEFAULT			"nand0=nand"
+#define MTDPARTS_DEFAULT		"mtdparts=nand:512k(x-loader),"\
+					"1920k(u-boot),128k(u-boot-env),"\
+					"4m(kernel),-(fs)"
+
+#define CONFIG_CMD_I2C		/* I2C serial bus support	*/
+#define CONFIG_CMD_MMC		/* MMC support			*/
+#define CONFIG_CMD_NAND		/* NAND support			*/
+#define CONFIG_CMD_NAND_LOCK_UNLOCK
+
+#undef CONFIG_CMD_FLASH		/* flinfo, erase, protect	*/
+#undef CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+#undef CONFIG_CMD_IMI		/* iminfo			*/
+#undef CONFIG_CMD_IMLS		/* List all found images	*/
+#define CONFIG_CMD_NET		/* bootp, tftpboot, rarpboot	*/
+#define CONFIG_CMD_PING		/* ping */
+#define CONFIG_CMD_DHCP		/* dhcp */
+#undef CONFIG_CMD_NFS		/* NFS support			*/
+#define CONFIG_CMD_ASKENV	/* askenv */
+
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_SYS_I2C_BUS		0
+#define CONFIG_SYS_I2C_BUS_SELECT	1
+#define CONFIG_DRIVER_OMAP34XX_I2C	1
+
+/*
+ * TWL4030
+ */
+#define CONFIG_TWL4030_POWER		1
+#define CONFIG_TWL4030_LED		1
+
+/*
+ * Board NAND Info.
+ */
+#define CONFIG_NAND_OMAP_GPMC
+#define CONFIG_SYS_NAND_ADDR		NAND_BASE	/* physical address */
+							/* to access nand */
+#define CONFIG_SYS_NAND_BASE		NAND_BASE	/* physical address */
+							/* to access nand at */
+							/* CS0 */
+#define GPMC_NAND_ECC_LP_x16_LAYOUT	1
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1		/* Max number of NAND */
+							/* devices */
+#define CONFIG_SYS_64BIT_VSPRINTF		/* needed for nand_util.c */
+
+#define CONFIG_JFFS2_NAND
+/* nand device jffs2 lives on */
+#define CONFIG_JFFS2_DEV		"nand0"
+/* start of jffs2 partition */
+#define CONFIG_JFFS2_PART_OFFSET	0x680000
+#define CONFIG_JFFS2_PART_SIZE		0xf980000	/* size of jffs2 */
+							/* partition */
+
+/* Environment information */
+#define CONFIG_BOOTDELAY		10
+
+#if 1
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"display=15\0"		  \
+	"loadaddr=0x81000000\0"	  \
+	"rootfsaddr=0x81300000\0" \
+	"consoledev=ttyS0\0"		  \
+	"rootpath=/opt/nfs-exports/alico-omap\0" \
+	"ramdisksize=89000\0"			\
+	"kernelimage=uImage\0" \
+	"nfsoptions=,wsize=1500,rsize=1500\0"				\
+	"nfsboot=setenv bootargs display=${display} console=${consoledev},${baudrate} root=/dev/nfs rw nfsroot=${serverip}:${rootpath}${nfsoptions} ip=dhcp ${otherbootargs};tftpboot ${loadaddr} ${kernelimage};bootm ${loadaddr}\0" \
+	"ramboot=setenv bootargs display=${display} console=${consoledev},${baudrate} root=/dev/ram rw ramdisk_size=${ramdisksize} ${otherbootargs};tftpboot ${loadaddr} ${kernelimage};tftpboot ${rootfsaddr} rootfs.ext2.gz.uboot;bootm ${loadaddr} ${rootfsaddr}\0" \
+	"xipboot=setenv bootargs display=${display} console=${consoledev},${baudrate} root=/dev/ram rw ramdisk_size=${ramdisksize} ${otherbootargs};bootm ${loadaddr} ${rootfsaddr}\0" \
+	"rootdevice=/dev/mtdblock4\0" \
+	"rootfstype=yaffs\0" \
+	"mtdboot=setenv bootargs display=${display} console=${consoledev},${baudrate} root=${rootdevice} rootfstype=${rootfstype} rw ${otherbootargs};bootm ${loadaddr}\0" \
+	"sdmtdboot=setenv bootargs display=${display} console=${consoledev},${baudrate} root=${rootdevice} rootfstype=${rootfstype} rw ${otherbootargs};mmcinit;fatload mmc0 ${loadaddr} ${kernelimage}; bootm ${loadaddr}\0"
+
+#define CONFIG_BOOTCOMMAND "run xipboot"
+
+#else
+
+// Beagle ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"loadaddr=0x82000000\0" \
+	"console=ttyS2,115200n8\0" \
+	"videomode=1024x768@60,vxres=1024,vyres=768\0" \
+	"videospec=omapfb:vram:2M,vram:4M\0" \
+	"mmcargs=setenv bootargs console=${console} " \
+		"video=${videospec},mode:${videomode} " \
+		"root=/dev/mmcblk0p2 rw " \
+		"rootfstype=ext3 rootwait\0" \
+	"nandargs=setenv bootargs console=${console} " \
+		"video=${videospec},mode:${videomode} " \
+		"root=/dev/mtdblock4 rw " \
+		"rootfstype=jffs2\0" \
+	"loadbootscript=fatload mmc 0 ${loadaddr} boot.scr\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source ${loadaddr}\0" \
+	"loaduimage=fatload mmc 0 ${loadaddr} uImage\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"bootm ${loadaddr}\0" \
+	"nandboot=echo Booting from nand ...; " \
+		"run nandargs; " \
+		"nand read ${loadaddr} 280000 400000; " \
+		"bootm ${loadaddr}\0" \
+
+// Beagle BOOTCOMMAND
+#define CONFIG_BOOTCOMMAND \
+	"if mmc init; then " \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"else " \
+			"if run loaduimage; then " \
+				"run mmcboot; " \
+			"else run nandboot; " \
+			"fi; " \
+		"fi; " \
+	"else run nandboot; fi"
+#endif
+
+#define CONFIG_PREBOOT \
+	"echo ======================NOTICE============================;"    \
+	"echo This is the first time that you boot up this board. You are;" \
+	"echo required to set a valid display for your LCD panel.;"	\
+	"echo Enter the display number of the LCD panel(none for no LCD panel);" \
+	"echo Pick one of:;"						\
+	"echo   2 == LQ121S1DG31     TFT SVGA    (12.1)  Sharp;"	\
+	"echo   3 == LQ036Q1DA01     TFT QVGA    (3.6)   Sharp w/ASIC;" \
+	"echo   5 == LQ064D343       TFT VGA     (6.4)   Sharp;"	\
+	"echo   7 == LQ10D368        TFT VGA     (10.4)  Sharp;"	\
+	"echo  15 == LQ043T1DG01     TFT WQVGA   (4.3)   Sharp;"	\
+	"echo MAKE SURE YOUR DISPLAY IS CORRECTLY ENTERED!;"		\
+	"askenv display 'Please enter your LCD display number:' 2;"	\
+	"printenv display;"						\
+	"setenv preboot;"						\
+	"saveenv;"
+
+#define CONFIG_CMDLINE_EDITING		1
+#define CONFIG_AUTO_COMPLETE		1
+
+/*
+ * Miscellaneous configurable options
+ */
+#define V_PROMPT			"=> "
+
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_PROMPT		V_PROMPT
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		(CONFIG_SYS_CBSIZE)
+
+#define CONFIG_SYS_MEMTEST_START	(OMAP34XX_SDRC_CS0)	/* memtest */
+								/* works on */
+#define CONFIG_SYS_MEMTEST_END		(OMAP34XX_SDRC_CS0 + \
+					0x01F00000) /* 31MB */
+
+#define CONFIG_SYS_LOAD_ADDR		(OMAP34XX_SDRC_CS0)	/* default */
+							/* load address */
+
+/*
+ * OMAP3 has 12 GP timers, they can be driven by the system clock
+ * (12/13/16.8/19.2/38.4MHz) or by 32KHz clock. We use 13MHz (V_SCLK).
+ * This rate is divided by a local divisor.
+ */
+#define CONFIG_SYS_TIMERBASE		(OMAP34XX_GPT2)
+#define CONFIG_SYS_PTV			2       /* Divisor: 2^(PTV+1) => 8 */
+#define CONFIG_SYS_HZ			1000
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	SZ_128K	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	SZ_4K	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	SZ_4K	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	2	/* CS1 may or may not be populated */
+#define PHYS_SDRAM_1		OMAP34XX_SDRC_CS0
+#define PHYS_SDRAM_1_SIZE	SZ_32M	/* at least 32 meg */
+#define PHYS_SDRAM_2		OMAP34XX_SDRC_CS1
+
+/* SDRAM Bank Allocation method */
+#define SDRC_R_B_C		1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+
+/* **** PISMO SUPPORT *** */
+
+/* Configure the PISMO */
+#define PISMO1_NAND_SIZE		GPMC_SIZE_128M
+
+#define CONFIG_SYS_MAX_FLASH_SECT	520	/* max number of sectors on */
+						/* one chip */
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* max number of flash banks */
+#define CONFIG_SYS_MONITOR_LEN		SZ_256K	/* Reserve 2 sectors */
+
+#define CONFIG_SYS_FLASH_BASE		boot_flash_base
+
+/* Monitor at start of flash */
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_ENV_IS_IN_NAND		1
+#define CONFIG_ENV_SIZE			SZ_128K	/* Total Size Environment */
+#define CONFIG_ENV_RANGE		(CONFIG_ENV_SIZE * 2)	/* Total Size Environment */
+#define SMNAND_ENV_OFFSET		(SZ_256M - CONFIG_ENV_RANGE) /* environment starts here */
+
+#define CONFIG_SYS_ENV_SECT_SIZE	boot_flash_sec
+#define CONFIG_ENV_OFFSET		boot_flash_off
+#define CONFIG_ENV_ADDR			SMNAND_ENV_OFFSET
+
+#if 0
+#define CONFIG_MTD_DEBUG 1
+#define CONFIG_MTD_DEBUG_VERBOSE 2 // Loud MTD debug messages
+#endif
+
+/*-----------------------------------------------------------------------
+ * CFI FLASH driver setup
+ */
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(100 * CONFIG_SYS_HZ)
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(100 * CONFIG_SYS_HZ)
+
+/* Flash banks JFFS2 should use */
+#define CONFIG_SYS_MAX_MTD_BANKS	(CONFIG_SYS_MAX_FLASH_BANKS + \
+					CONFIG_SYS_MAX_NAND_DEVICE)
+#define CONFIG_SYS_JFFS2_MEM_NAND
+/* use flash_info[2] */
+#define CONFIG_SYS_JFFS2_FIRST_BANK	CONFIG_SYS_MAX_FLASH_BANKS
+#define CONFIG_SYS_JFFS2_NUM_BANKS	1
+
+#ifndef __ASSEMBLY__
+extern struct gpmc *gpmc_cfg;
+extern unsigned int boot_flash_base;
+extern volatile unsigned int boot_flash_env_addr;
+extern unsigned int boot_flash_off;
+extern unsigned int boot_flash_sec;
+extern unsigned int boot_flash_type;
+#endif
+
+/*----------------------------------------------------------------------------
+ * SMSC9115 Ethernet from SMSC9118 family
+ *----------------------------------------------------------------------------
+ */
+#if defined(CONFIG_CMD_NET)
+
+#define CONFIG_TFTP_BLOCKSIZE_512  // Force TFTP blocksize to stay at
+				   // 512 - prevents fragmentation
+
+#define CONFIG_NET_MULTI
+#define CONFIG_SMC911X
+#define CONFIG_SMC911X_16_BIT
+#define CONFIG_SMC911X_BASE	0x08000000
+
+#endif /* (CONFIG_CMD_NET) */
+
+/*
+ * BOOTP fields
+ */
+
+#define CONFIG_BOOTP_SUBNETMASK		0x00000001
+#define CONFIG_BOOTP_GATEWAY		0x00000002
+#define CONFIG_BOOTP_HOSTNAME		0x00000004
+#define CONFIG_BOOTP_BOOTPATH		0x00000010
+
+#endif /* __CONFIG_H */
